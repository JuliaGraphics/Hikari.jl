import{_ as r,C as p,o,c as d,j as s,a,E as t,az as n,w as l}from"./chunks/framework.CHOvxG4t.js";const qk=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"api.md","filePath":"api.md","lastUpdated":null}'),k={name:"api.md"},h={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},H={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},I={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},G={class:"jldocstring custom-block",open:""},P={class:"jldocstring custom-block",open:""},V={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},N={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},J={class:"jldocstring custom-block",open:""},W={class:"jldocstring custom-block",open:""},U={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},z={class:"jldocstring custom-block",open:""},K={class:"jldocstring custom-block",open:""},Z={class:"jldocstring custom-block",open:""},X={class:"jldocstring custom-block",open:""},Y={class:"jldocstring custom-block",open:""},Q={class:"jldocstring custom-block",open:""},$={class:"jldocstring custom-block",open:""},ii={class:"jldocstring custom-block",open:""},si={class:"jldocstring custom-block",open:""},ei={class:"jldocstring custom-block",open:""},ti={class:"jldocstring custom-block",open:""},ai={class:"jldocstring custom-block",open:""},li={class:"jldocstring custom-block",open:""},ni={class:"jldocstring custom-block",open:""},ri={class:"jldocstring custom-block",open:""},pi={class:"jldocstring custom-block",open:""},oi={class:"jldocstring custom-block",open:""},di={class:"jldocstring custom-block",open:""},ki={class:"jldocstring custom-block",open:""},hi={class:"jldocstring custom-block",open:""},ui={class:"jldocstring custom-block",open:""},gi={class:"jldocstring custom-block",open:""},ci={class:"jldocstring custom-block",open:""},bi={class:"jldocstring custom-block",open:""},yi={class:"jldocstring custom-block",open:""},mi={class:"jldocstring custom-block",open:""},fi={class:"jldocstring custom-block",open:""},Ei={class:"jldocstring custom-block",open:""},_i={class:"jldocstring custom-block",open:""},Ti={class:"jldocstring custom-block",open:""},ji={class:"jldocstring custom-block",open:""},Fi={class:"jldocstring custom-block",open:""},Ci={class:"jldocstring custom-block",open:""},vi={class:"jldocstring custom-block",open:""},Hi={class:"jldocstring custom-block",open:""},Ai={class:"jldocstring custom-block",open:""},Si={class:"jldocstring custom-block",open:""},xi={class:"jldocstring custom-block",open:""},Bi={class:"jldocstring custom-block",open:""},Di={class:"jldocstring custom-block",open:""},Ii={class:"jldocstring custom-block",open:""},Mi={class:"jldocstring custom-block",open:""},Gi={class:"jldocstring custom-block",open:""},Pi={class:"jldocstring custom-block",open:""},Vi={class:"jldocstring custom-block",open:""},Li={class:"jldocstring custom-block",open:""},wi={class:"jldocstring custom-block",open:""},Ri={class:"jldocstring custom-block",open:""},Ni={class:"jldocstring custom-block",open:""},Oi={class:"jldocstring custom-block",open:""},Ji={class:"jldocstring custom-block",open:""},Wi={class:"jldocstring custom-block",open:""},Ui={class:"jldocstring custom-block",open:""},qi={class:"jldocstring custom-block",open:""},zi={class:"jldocstring custom-block",open:""},Ki={class:"jldocstring custom-block",open:""},Zi={class:"jldocstring custom-block",open:""},Xi={class:"jldocstring custom-block",open:""},Yi={class:"jldocstring custom-block",open:""},Qi={class:"jldocstring custom-block",open:""},$i={class:"jldocstring custom-block",open:""},is={class:"jldocstring custom-block",open:""},ss={class:"jldocstring custom-block",open:""},es={class:"jldocstring custom-block",open:""},ts={class:"jldocstring custom-block",open:""},as={class:"jldocstring custom-block",open:""},ls={class:"jldocstring custom-block",open:""},ns={class:"jldocstring custom-block",open:""},rs={class:"jldocstring custom-block",open:""},ps={class:"jldocstring custom-block",open:""},os={class:"jldocstring custom-block",open:""},ds={class:"jldocstring custom-block",open:""},ks={class:"jldocstring custom-block",open:""},hs={class:"jldocstring custom-block",open:""},us={class:"jldocstring custom-block",open:""},gs={class:"jldocstring custom-block",open:""},cs={class:"jldocstring custom-block",open:""},bs={class:"jldocstring custom-block",open:""},ys={class:"jldocstring custom-block",open:""},ms={class:"jldocstring custom-block",open:""},fs={class:"jldocstring custom-block",open:""},Es={class:"jldocstring custom-block",open:""},_s={class:"jldocstring custom-block",open:""},Ts={class:"jldocstring custom-block",open:""},js={class:"jldocstring custom-block",open:""},Fs={class:"jldocstring custom-block",open:""},Cs={class:"jldocstring custom-block",open:""},vs={class:"jldocstring custom-block",open:""},Hs={class:"jldocstring custom-block",open:""},As={class:"jldocstring custom-block",open:""},Ss={class:"jldocstring custom-block",open:""},xs={class:"jldocstring custom-block",open:""},Bs={class:"jldocstring custom-block",open:""},Ds={class:"jldocstring custom-block",open:""},Is={class:"jldocstring custom-block",open:""},Ms={class:"jldocstring custom-block",open:""},Gs={class:"jldocstring custom-block",open:""},Ps={class:"jldocstring custom-block",open:""},Vs={class:"jldocstring custom-block",open:""},Ls={class:"jldocstring custom-block",open:""},ws={class:"jldocstring custom-block",open:""},Rs={class:"jldocstring custom-block",open:""},Ns={class:"jldocstring custom-block",open:""},Os={class:"jldocstring custom-block",open:""},Js={class:"jldocstring custom-block",open:""},Ws={class:"jldocstring custom-block",open:""},Us={class:"jldocstring custom-block",open:""},qs={class:"jldocstring custom-block",open:""},zs={class:"jldocstring custom-block",open:""},Ks={class:"jldocstring custom-block",open:""},Zs={class:"jldocstring custom-block",open:""},Xs={class:"jldocstring custom-block",open:""},Ys={class:"jldocstring custom-block",open:""},Qs={class:"jldocstring custom-block",open:""},$s={class:"jldocstring custom-block",open:""},ie={class:"jldocstring custom-block",open:""},se={class:"jldocstring custom-block",open:""},ee={class:"jldocstring custom-block",open:""},te={class:"jldocstring custom-block",open:""},ae={class:"jldocstring custom-block",open:""},le={class:"jldocstring custom-block",open:""},ne={class:"jldocstring custom-block",open:""},re={class:"jldocstring custom-block",open:""},pe={class:"jldocstring custom-block",open:""},oe={class:"jldocstring custom-block",open:""},de={class:"jldocstring custom-block",open:""},ke={class:"jldocstring custom-block",open:""},he={class:"jldocstring custom-block",open:""},ue={class:"jldocstring custom-block",open:""},ge={class:"jldocstring custom-block",open:""},ce={class:"jldocstring custom-block",open:""},be={class:"jldocstring custom-block",open:""},ye={class:"jldocstring custom-block",open:""},me={class:"jldocstring custom-block",open:""},fe={class:"jldocstring custom-block",open:""},Ee={class:"jldocstring custom-block",open:""},_e={class:"jldocstring custom-block",open:""},Te={class:"jldocstring custom-block",open:""},je={class:"jldocstring custom-block",open:""},Fe={class:"jldocstring custom-block",open:""},Ce={class:"jldocstring custom-block",open:""},ve={class:"jldocstring custom-block",open:""},He={class:"jldocstring custom-block",open:""},Ae={class:"jldocstring custom-block",open:""},Se={class:"jldocstring custom-block",open:""},xe={class:"jldocstring custom-block",open:""},Be={class:"jldocstring custom-block",open:""},De={class:"jldocstring custom-block",open:""},Ie={class:"jldocstring custom-block",open:""},Me={class:"jldocstring custom-block",open:""},Ge={class:"jldocstring custom-block",open:""},Pe={class:"jldocstring custom-block",open:""},Ve={class:"jldocstring custom-block",open:""},Le={class:"jldocstring custom-block",open:""},we={class:"jldocstring custom-block",open:""},Re={class:"jldocstring custom-block",open:""},Ne={class:"jldocstring custom-block",open:""},Oe={class:"jldocstring custom-block",open:""},Je={class:"jldocstring custom-block",open:""},We={class:"jldocstring custom-block",open:""},Ue={class:"jldocstring custom-block",open:""},qe={class:"jldocstring custom-block",open:""},ze={class:"jldocstring custom-block",open:""},Ke={class:"jldocstring custom-block",open:""},Ze={class:"jldocstring custom-block",open:""},Xe={class:"jldocstring custom-block",open:""},Ye={class:"jldocstring custom-block",open:""},Qe={class:"jldocstring custom-block",open:""},$e={class:"jldocstring custom-block",open:""},it={class:"jldocstring custom-block",open:""},st={class:"jldocstring custom-block",open:""},et={class:"jldocstring custom-block",open:""},tt={class:"jldocstring custom-block",open:""},at={class:"jldocstring custom-block",open:""},lt={class:"jldocstring custom-block",open:""},nt={class:"jldocstring custom-block",open:""},rt={class:"jldocstring custom-block",open:""},pt={class:"jldocstring custom-block",open:""},ot={class:"jldocstring custom-block",open:""},dt={class:"jldocstring custom-block",open:""},kt={class:"jldocstring custom-block",open:""},ht={class:"jldocstring custom-block",open:""},ut={class:"jldocstring custom-block",open:""},gt={class:"jldocstring custom-block",open:""},ct={class:"jldocstring custom-block",open:""},bt={class:"jldocstring custom-block",open:""},yt={class:"jldocstring custom-block",open:""},mt={class:"jldocstring custom-block",open:""},ft={class:"jldocstring custom-block",open:""},Et={class:"jldocstring custom-block",open:""},_t={class:"jldocstring custom-block",open:""},Tt={class:"jldocstring custom-block",open:""},jt={class:"jldocstring custom-block",open:""},Ft={class:"jldocstring custom-block",open:""},Ct={class:"jldocstring custom-block",open:""},vt={class:"jldocstring custom-block",open:""},Ht={class:"jldocstring custom-block",open:""},At={class:"jldocstring custom-block",open:""},St={class:"jldocstring custom-block",open:""},xt={class:"jldocstring custom-block",open:""},Bt={class:"jldocstring custom-block",open:""},Dt={class:"jldocstring custom-block",open:""},It={class:"jldocstring custom-block",open:""},Mt={class:"jldocstring custom-block",open:""},Gt={class:"jldocstring custom-block",open:""},Pt={class:"jldocstring custom-block",open:""},Vt={class:"jldocstring custom-block",open:""},Lt={class:"jldocstring custom-block",open:""},wt={class:"jldocstring custom-block",open:""},Rt={class:"jldocstring custom-block",open:""},Nt={class:"jldocstring custom-block",open:""},Ot={class:"jldocstring custom-block",open:""},Jt={class:"jldocstring custom-block",open:""},Wt={class:"jldocstring custom-block",open:""},Ut={class:"jldocstring custom-block",open:""},qt={class:"jldocstring custom-block",open:""},zt={class:"jldocstring custom-block",open:""},Kt={class:"jldocstring custom-block",open:""},Zt={class:"jldocstring custom-block",open:""},Xt={class:"jldocstring custom-block",open:""},Yt={class:"jldocstring custom-block",open:""},Qt={class:"jldocstring custom-block",open:""},$t={class:"jldocstring custom-block",open:""},ia={class:"jldocstring custom-block",open:""},sa={class:"jldocstring custom-block",open:""},ea={class:"jldocstring custom-block",open:""},ta={class:"jldocstring custom-block",open:""},aa={class:"jldocstring custom-block",open:""},la={class:"jldocstring custom-block",open:""},na={class:"jldocstring custom-block",open:""},ra={class:"jldocstring custom-block",open:""},pa={class:"jldocstring custom-block",open:""},oa={class:"jldocstring custom-block",open:""},da={class:"jldocstring custom-block",open:""},ka={class:"jldocstring custom-block",open:""},ha={class:"jldocstring custom-block",open:""},ua={class:"jldocstring custom-block",open:""},ga={class:"jldocstring custom-block",open:""},ca={class:"jldocstring custom-block",open:""},ba={class:"jldocstring custom-block",open:""},ya={class:"jldocstring custom-block",open:""},ma={class:"jldocstring custom-block",open:""},fa={class:"jldocstring custom-block",open:""},Ea={class:"jldocstring custom-block",open:""},_a={class:"jldocstring custom-block",open:""},Ta={class:"jldocstring custom-block",open:""},ja={class:"jldocstring custom-block",open:""},Fa={class:"jldocstring custom-block",open:""},Ca={class:"jldocstring custom-block",open:""},va={class:"jldocstring custom-block",open:""},Ha={class:"jldocstring custom-block",open:""},Aa={class:"jldocstring custom-block",open:""},Sa={class:"jldocstring custom-block",open:""},xa={class:"jldocstring custom-block",open:""},Ba={class:"jldocstring custom-block",open:""},Da={class:"jldocstring custom-block",open:""},Ia={class:"jldocstring custom-block",open:""},Ma={class:"jldocstring custom-block",open:""},Ga={class:"jldocstring custom-block",open:""},Pa={class:"jldocstring custom-block",open:""},Va={class:"jldocstring custom-block",open:""},La={class:"jldocstring custom-block",open:""},wa={class:"jldocstring custom-block",open:""},Ra={class:"jldocstring custom-block",open:""},Na={class:"jldocstring custom-block",open:""},Oa={class:"jldocstring custom-block",open:""},Ja={class:"jldocstring custom-block",open:""},Wa={class:"jldocstring custom-block",open:""},Ua={class:"jldocstring custom-block",open:""},qa={class:"jldocstring custom-block",open:""},za={class:"jldocstring custom-block",open:""},Ka={class:"jldocstring custom-block",open:""},Za={class:"jldocstring custom-block",open:""},Xa={class:"jldocstring custom-block",open:""},Ya={class:"jldocstring custom-block",open:""},Qa={class:"jldocstring custom-block",open:""},$a={class:"jldocstring custom-block",open:""},il={class:"jldocstring custom-block",open:""},sl={class:"jldocstring custom-block",open:""},el={class:"jldocstring custom-block",open:""},tl={class:"jldocstring custom-block",open:""},al={class:"jldocstring custom-block",open:""},ll={class:"jldocstring custom-block",open:""},nl={class:"jldocstring custom-block",open:""},rl={class:"jldocstring custom-block",open:""},pl={class:"jldocstring custom-block",open:""},ol={class:"jldocstring custom-block",open:""},dl={class:"jldocstring custom-block",open:""},kl={class:"jldocstring custom-block",open:""},hl={class:"jldocstring custom-block",open:""},ul={class:"jldocstring custom-block",open:""},gl={class:"jldocstring custom-block",open:""},cl={class:"jldocstring custom-block",open:""},bl={class:"jldocstring custom-block",open:""},yl={class:"jldocstring custom-block",open:""},ml={class:"jldocstring custom-block",open:""},fl={class:"jldocstring custom-block",open:""},El={class:"jldocstring custom-block",open:""},_l={class:"jldocstring custom-block",open:""},Tl={class:"jldocstring custom-block",open:""},jl={class:"jldocstring custom-block",open:""},Fl={class:"jldocstring custom-block",open:""},Cl={class:"jldocstring custom-block",open:""},vl={class:"jldocstring custom-block",open:""},Hl={class:"jldocstring custom-block",open:""},Al={class:"jldocstring custom-block",open:""},Sl={class:"jldocstring custom-block",open:""},xl={class:"jldocstring custom-block",open:""},Bl={class:"jldocstring custom-block",open:""},Dl={class:"jldocstring custom-block",open:""},Il={class:"jldocstring custom-block",open:""},Ml={class:"jldocstring custom-block",open:""},Gl={class:"jldocstring custom-block",open:""},Pl={class:"jldocstring custom-block",open:""},Vl={class:"jldocstring custom-block",open:""},Ll={class:"jldocstring custom-block",open:""},wl={class:"jldocstring custom-block",open:""},Rl={class:"jldocstring custom-block",open:""},Nl={class:"jldocstring custom-block",open:""},Ol={class:"jldocstring custom-block",open:""},Jl={class:"jldocstring custom-block",open:""},Wl={class:"jldocstring custom-block",open:""},Ul={class:"jldocstring custom-block",open:""},ql={class:"jldocstring custom-block",open:""},zl={class:"jldocstring custom-block",open:""},Kl={class:"jldocstring custom-block",open:""},Zl={class:"jldocstring custom-block",open:""},Xl={class:"jldocstring custom-block",open:""},Yl={class:"jldocstring custom-block",open:""},Ql={class:"jldocstring custom-block",open:""},$l={class:"jldocstring custom-block",open:""},sn={class:"jldocstring custom-block",open:""},en={class:"jldocstring custom-block",open:""},tn={class:"jldocstring custom-block",open:""},an={class:"jldocstring custom-block",open:""},ln={class:"jldocstring custom-block",open:""},nn={class:"jldocstring custom-block",open:""},rn={class:"jldocstring custom-block",open:""},pn={class:"jldocstring custom-block",open:""},on={class:"jldocstring custom-block",open:""},dn={class:"jldocstring custom-block",open:""},kn={class:"jldocstring custom-block",open:""},hn={class:"jldocstring custom-block",open:""},un={class:"jldocstring custom-block",open:""},gn={class:"jldocstring custom-block",open:""},cn={class:"jldocstring custom-block",open:""},bn={class:"jldocstring custom-block",open:""},yn={class:"jldocstring custom-block",open:""},mn={class:"jldocstring custom-block",open:""},fn={class:"jldocstring custom-block",open:""},En={class:"jldocstring custom-block",open:""},_n={class:"jldocstring custom-block",open:""},Tn={class:"jldocstring custom-block",open:""},jn={class:"jldocstring custom-block",open:""},Fn={class:"jldocstring custom-block",open:""},Cn={class:"jldocstring custom-block",open:""},vn={class:"jldocstring custom-block",open:""},Hn={class:"jldocstring custom-block",open:""},An={class:"jldocstring custom-block",open:""},Sn={class:"jldocstring custom-block",open:""},xn={class:"jldocstring custom-block",open:""},Bn={class:"jldocstring custom-block",open:""},Dn={class:"jldocstring custom-block",open:""},In={class:"jldocstring custom-block",open:""},Mn={class:"jldocstring custom-block",open:""},Gn={class:"jldocstring custom-block",open:""},Pn={class:"jldocstring custom-block",open:""},Vn={class:"jldocstring custom-block",open:""},Ln={class:"jldocstring custom-block",open:""},wn={class:"jldocstring custom-block",open:""},Rn={class:"jldocstring custom-block",open:""},Nn={class:"jldocstring custom-block",open:""},On={class:"jldocstring custom-block",open:""},Jn={class:"jldocstring custom-block",open:""},Wn={class:"jldocstring custom-block",open:""},Un={class:"jldocstring custom-block",open:""},qn={class:"jldocstring custom-block",open:""},zn={class:"jldocstring custom-block",open:""},Kn={class:"jldocstring custom-block",open:""},Zn={class:"jldocstring custom-block",open:""},Xn={class:"jldocstring custom-block",open:""},Yn={class:"jldocstring custom-block",open:""},Qn={class:"jldocstring custom-block",open:""},$n={class:"jldocstring custom-block",open:""},ir={class:"jldocstring custom-block",open:""},sr={class:"jldocstring custom-block",open:""},er={class:"jldocstring custom-block",open:""},tr={class:"jldocstring custom-block",open:""},ar={class:"jldocstring custom-block",open:""},lr={class:"jldocstring custom-block",open:""},nr={class:"jldocstring custom-block",open:""},rr={class:"jldocstring custom-block",open:""},pr={class:"jldocstring custom-block",open:""},or={class:"jldocstring custom-block",open:""},dr={class:"jldocstring custom-block",open:""},kr={class:"jldocstring custom-block",open:""},hr={class:"jldocstring custom-block",open:""},ur={class:"jldocstring custom-block",open:""},gr={class:"jldocstring custom-block",open:""},cr={class:"jldocstring custom-block",open:""},br={class:"jldocstring custom-block",open:""},yr={class:"jldocstring custom-block",open:""},mr={class:"jldocstring custom-block",open:""},fr={class:"jldocstring custom-block",open:""},Er={class:"jldocstring custom-block",open:""},_r={class:"jldocstring custom-block",open:""},Tr={class:"jldocstring custom-block",open:""},jr={class:"jldocstring custom-block",open:""},Fr={class:"jldocstring custom-block",open:""},Cr={class:"jldocstring custom-block",open:""},vr={class:"jldocstring custom-block",open:""},Hr={class:"jldocstring custom-block",open:""},Ar={class:"jldocstring custom-block",open:""},Sr={class:"jldocstring custom-block",open:""},xr={class:"jldocstring custom-block",open:""},Br={class:"jldocstring custom-block",open:""},Dr={class:"jldocstring custom-block",open:""},Ir={class:"jldocstring custom-block",open:""},Mr={class:"jldocstring custom-block",open:""},Gr={class:"jldocstring custom-block",open:""},Pr={class:"jldocstring custom-block",open:""},Vr={class:"jldocstring custom-block",open:""},Lr={class:"jldocstring custom-block",open:""},wr={class:"jldocstring custom-block",open:""},Rr={class:"jldocstring custom-block",open:""},Nr={class:"jldocstring custom-block",open:""},Or={class:"jldocstring custom-block",open:""},Jr={class:"jldocstring custom-block",open:""},Wr={class:"jldocstring custom-block",open:""},Ur={class:"jldocstring custom-block",open:""},qr={class:"jldocstring custom-block",open:""},zr={class:"jldocstring custom-block",open:""},Kr={class:"jldocstring custom-block",open:""},Zr={class:"jldocstring custom-block",open:""},Xr={class:"jldocstring custom-block",open:""},Yr={class:"jldocstring custom-block",open:""},Qr={class:"jldocstring custom-block",open:""},$r={class:"jldocstring custom-block",open:""},ip={class:"jldocstring custom-block",open:""},sp={class:"jldocstring custom-block",open:""},ep={class:"jldocstring custom-block",open:""},tp={class:"jldocstring custom-block",open:""},ap={class:"jldocstring custom-block",open:""},lp={class:"jldocstring custom-block",open:""},np={class:"jldocstring custom-block",open:""},rp={class:"jldocstring custom-block",open:""},pp={class:"jldocstring custom-block",open:""},op={class:"jldocstring custom-block",open:""},dp={class:"jldocstring custom-block",open:""},kp={class:"jldocstring custom-block",open:""},hp={class:"jldocstring custom-block",open:""},up={class:"jldocstring custom-block",open:""},gp={class:"jldocstring custom-block",open:""},cp={class:"jldocstring custom-block",open:""},bp={class:"jldocstring custom-block",open:""},yp={class:"jldocstring custom-block",open:""},mp={class:"jldocstring custom-block",open:""},fp={class:"jldocstring custom-block",open:""},Ep={class:"jldocstring custom-block",open:""},_p={class:"jldocstring custom-block",open:""},Tp={class:"jldocstring custom-block",open:""},jp={class:"jldocstring custom-block",open:""},Fp={class:"jldocstring custom-block",open:""},Cp={class:"jldocstring custom-block",open:""},vp={class:"jldocstring custom-block",open:""},Hp={class:"jldocstring custom-block",open:""},Ap={class:"jldocstring custom-block",open:""},Sp={class:"jldocstring custom-block",open:""},xp={class:"jldocstring custom-block",open:""},Bp={class:"jldocstring custom-block",open:""},Dp={class:"jldocstring custom-block",open:""},Ip={class:"jldocstring custom-block",open:""},Mp={class:"jldocstring custom-block",open:""},Gp={class:"jldocstring custom-block",open:""},Pp={class:"jldocstring custom-block",open:""},Vp={class:"jldocstring custom-block",open:""},Lp={class:"jldocstring custom-block",open:""},wp={class:"jldocstring custom-block",open:""},Rp={class:"jldocstring custom-block",open:""},Np={class:"jldocstring custom-block",open:""},Op={class:"jldocstring custom-block",open:""},Jp={class:"jldocstring custom-block",open:""},Wp={class:"jldocstring custom-block",open:""},Up={class:"jldocstring custom-block",open:""},qp={class:"jldocstring custom-block",open:""},zp={class:"jldocstring custom-block",open:""},Kp={class:"jldocstring custom-block",open:""},Zp={class:"jldocstring custom-block",open:""},Xp={class:"jldocstring custom-block",open:""},Yp={class:"jldocstring custom-block",open:""},Qp={class:"jldocstring custom-block",open:""},$p={class:"jldocstring custom-block",open:""},io={class:"jldocstring custom-block",open:""},so={class:"jldocstring custom-block",open:""},eo={class:"jldocstring custom-block",open:""},to={class:"jldocstring custom-block",open:""},ao={class:"jldocstring custom-block",open:""},lo={class:"jldocstring custom-block",open:""},no={class:"jldocstring custom-block",open:""},ro={class:"jldocstring custom-block",open:""},po={class:"jldocstring custom-block",open:""},oo={class:"jldocstring custom-block",open:""},ko={class:"jldocstring custom-block",open:""},ho={class:"jldocstring custom-block",open:""},uo={class:"jldocstring custom-block",open:""},go={class:"jldocstring custom-block",open:""},co={class:"jldocstring custom-block",open:""},bo={class:"jldocstring custom-block",open:""},yo={class:"jldocstring custom-block",open:""},mo={class:"jldocstring custom-block",open:""},fo={class:"jldocstring custom-block",open:""},Eo={class:"jldocstring custom-block",open:""},_o={class:"jldocstring custom-block",open:""},To={class:"jldocstring custom-block",open:""},jo={class:"jldocstring custom-block",open:""},Fo={class:"jldocstring custom-block",open:""},Co={class:"jldocstring custom-block",open:""},vo={class:"jldocstring custom-block",open:""},Ho={class:"jldocstring custom-block",open:""},Ao={class:"jldocstring custom-block",open:""},So={class:"jldocstring custom-block",open:""},xo={class:"jldocstring custom-block",open:""},Bo={class:"jldocstring custom-block",open:""},Do={class:"jldocstring custom-block",open:""},Io={class:"jldocstring custom-block",open:""},Mo={class:"jldocstring custom-block",open:""},Go={class:"jldocstring custom-block",open:""},Po={class:"jldocstring custom-block",open:""},Vo={class:"jldocstring custom-block",open:""},Lo={class:"jldocstring custom-block",open:""},wo={class:"jldocstring custom-block",open:""},Ro={class:"jldocstring custom-block",open:""},No={class:"jldocstring custom-block",open:""},Oo={class:"jldocstring custom-block",open:""},Jo={class:"jldocstring custom-block",open:""},Wo={class:"jldocstring custom-block",open:""},Uo={class:"jldocstring custom-block",open:""},qo={class:"jldocstring custom-block",open:""},zo={class:"jldocstring custom-block",open:""},Ko={class:"jldocstring custom-block",open:""},Zo={class:"jldocstring custom-block",open:""},Xo={class:"jldocstring custom-block",open:""},Yo={class:"jldocstring custom-block",open:""},Qo={class:"jldocstring custom-block",open:""},$o={class:"jldocstring custom-block",open:""},id={class:"jldocstring custom-block",open:""},sd={class:"jldocstring custom-block",open:""},ed={class:"jldocstring custom-block",open:""},td={class:"jldocstring custom-block",open:""},ad={class:"jldocstring custom-block",open:""},ld={class:"jldocstring custom-block",open:""},nd={class:"jldocstring custom-block",open:""},rd={class:"jldocstring custom-block",open:""},pd={class:"jldocstring custom-block",open:""},od={class:"jldocstring custom-block",open:""},dd={class:"jldocstring custom-block",open:""},kd={class:"jldocstring custom-block",open:""},hd={class:"jldocstring custom-block",open:""},ud={class:"jldocstring custom-block",open:""},gd={class:"jldocstring custom-block",open:""},cd={class:"jldocstring custom-block",open:""},bd={class:"jldocstring custom-block",open:""},yd={class:"jldocstring custom-block",open:""},md={class:"jldocstring custom-block",open:""},fd={class:"jldocstring custom-block",open:""},Ed={class:"jldocstring custom-block",open:""},_d={class:"jldocstring custom-block",open:""},Td={class:"jldocstring custom-block",open:""},jd={class:"jldocstring custom-block",open:""},Fd={class:"jldocstring custom-block",open:""},Cd={class:"jldocstring custom-block",open:""},vd={class:"jldocstring custom-block",open:""},Hd={class:"jldocstring custom-block",open:""},Ad={class:"jldocstring custom-block",open:""},Sd={class:"jldocstring custom-block",open:""},xd={class:"jldocstring custom-block",open:""},Bd={class:"jldocstring custom-block",open:""},Dd={class:"jldocstring custom-block",open:""},Id={class:"jldocstring custom-block",open:""},Md={class:"jldocstring custom-block",open:""},Gd={class:"jldocstring custom-block",open:""},Pd={class:"jldocstring custom-block",open:""},Vd={class:"jldocstring custom-block",open:""},Ld={class:"jldocstring custom-block",open:""},wd={class:"jldocstring custom-block",open:""},Rd={class:"jldocstring custom-block",open:""},Nd={class:"jldocstring custom-block",open:""},Od={class:"jldocstring custom-block",open:""},Jd={class:"jldocstring custom-block",open:""},Wd={class:"jldocstring custom-block",open:""},Ud={class:"jldocstring custom-block",open:""},qd={class:"jldocstring custom-block",open:""},zd={class:"jldocstring custom-block",open:""},Kd={class:"jldocstring custom-block",open:""},Zd={class:"jldocstring custom-block",open:""},Xd={class:"jldocstring custom-block",open:""},Yd={class:"jldocstring custom-block",open:""},Qd={class:"jldocstring custom-block",open:""},$d={class:"jldocstring custom-block",open:""},ik={class:"jldocstring custom-block",open:""},sk={class:"jldocstring custom-block",open:""},ek={class:"jldocstring custom-block",open:""},tk={class:"jldocstring custom-block",open:""},ak={class:"jldocstring custom-block",open:""},lk={class:"jldocstring custom-block",open:""},nk={class:"jldocstring custom-block",open:""},rk={class:"jldocstring custom-block",open:""},pk={class:"jldocstring custom-block",open:""},ok={class:"jldocstring custom-block",open:""},dk={class:"jldocstring custom-block",open:""},kk={class:"jldocstring custom-block",open:""},hk={class:"jldocstring custom-block",open:""},uk={class:"jldocstring custom-block",open:""},gk={class:"jldocstring custom-block",open:""},ck={class:"jldocstring custom-block",open:""},bk={class:"jldocstring custom-block",open:""},yk={class:"jldocstring custom-block",open:""},mk={class:"jldocstring custom-block",open:""},fk={class:"jldocstring custom-block",open:""},Ek={class:"jldocstring custom-block",open:""},_k={class:"jldocstring custom-block",open:""},Tk={class:"jldocstring custom-block",open:""},jk={class:"jldocstring custom-block",open:""},Fk={class:"jldocstring custom-block",open:""},Ck={class:"jldocstring custom-block",open:""},vk={class:"jldocstring custom-block",open:""},Hk={class:"jldocstring custom-block",open:""},Ak={class:"jldocstring custom-block",open:""},Sk={class:"jldocstring custom-block",open:""},xk={class:"jldocstring custom-block",open:""},Bk={class:"jldocstring custom-block",open:""},Dk={class:"jldocstring custom-block",open:""},Ik={class:"jldocstring custom-block",open:""},Mk={class:"jldocstring custom-block",open:""},Gk={class:"jldocstring custom-block",open:""},Pk={class:"jldocstring custom-block",open:""},Vk={class:"jldocstring custom-block",open:""},Lk={class:"jldocstring custom-block",open:""};function wk(Rk,i,Nk,Ok,Jk,Wk){const e=p("Badge");return o(),d("div",null,[i[2716]||(i[2716]=s("h2",{id:"Public-API",tabindex:"-1"},[a("Public API "),s("a",{class:"header-anchor",href:"#Public-API","aria-label":'Permalink to "Public API {#Public-API}"'},"​")],-1)),i[2717]||(i[2717]=s("h2",{id:"Internal-API",tabindex:"-1"},[a("Internal API "),s("a",{class:"header-anchor",href:"#Internal-API","aria-label":'Permalink to "Internal API {#Internal-API}"'},"​")],-1)),s("details",h,[s("summary",null,[i[0]||(i[0]=s("a",{id:"Hikari.BXDF_REFLECTION",href:"#Hikari.BXDF_REFLECTION"},[s("span",{class:"jlbinding"},"Hikari.BXDF_REFLECTION")],-1)),i[1]||(i[1]=a()),t(e,{type:"info",class:"jlObjectType jlConstant",text:"Constant"})]),i[3]||(i[3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BxDFReflTransFlags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Flags </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> controlling reflection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transmission sampling</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2]||(i[2]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L940-L942",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",u,[s("summary",null,[i[4]||(i[4]=s("a",{id:"Hikari.D65_ILLUMINANT_VALUES",href:"#Hikari.D65_ILLUMINANT_VALUES"},[s("span",{class:"jlbinding"},"Hikari.D65_ILLUMINANT_VALUES")],-1)),i[5]||(i[5]=a()),t(e,{type:"info",class:"jlObjectType jlConstant",text:"Constant"})]),i[7]||(i[7]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D65_ILLUMINANT_VALUES</span></span></code></pre></div><p>D65 illuminant spectral power distribution values (normalized to 100 at 560nm).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[6]||(i[6]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L407-L411",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",g,[s("summary",null,[i[8]||(i[8]=s("a",{id:"Hikari.D65_ILLUMINANT_WAVELENGTHS",href:"#Hikari.D65_ILLUMINANT_WAVELENGTHS"},[s("span",{class:"jlbinding"},"Hikari.D65_ILLUMINANT_WAVELENGTHS")],-1)),i[9]||(i[9]=a()),t(e,{type:"info",class:"jlObjectType jlConstant",text:"Constant"})]),i[11]||(i[11]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D65_ILLUMINANT_WAVELENGTHS</span></span></code></pre></div><p>Wavelength sample points for D65 illuminant spectrum (300-830nm, 5nm intervals).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[10]||(i[10]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L388-L392",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",c,[s("summary",null,[i[12]||(i[12]=s("a",{id:"Hikari.PRIMES",href:"#Hikari.PRIMES"},[s("span",{class:"jlbinding"},"Hikari.PRIMES")],-1)),i[13]||(i[13]=a()),t(e,{type:"info",class:"jlObjectType jlConstant",text:"Constant"})]),i[15]||(i[15]=s("p",null,[a("First 1023 prime numbers (omitting 2). Used in "),s("code",null,"radical_inverse"),a(" function.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[14]||(i[14]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/primes.jl#L1-L4",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",b,[s("summary",null,[i[16]||(i[16]=s("a",{id:"Hikari.AliasTable",href:"#Hikari.AliasTable"},[s("span",{class:"jlbinding"},"Hikari.AliasTable")],-1)),i[17]||(i[17]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[19]||(i[19]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AliasTable{V1,V2}</span></span></code></pre></div><p>Walker&#39;s alias method for O(1) sampling from a discrete distribution. Each bin stores:</p><ul><li><p><code>p</code>: The PMF (probability) for this index</p></li><li><p><code>q</code>: The threshold for choosing this index vs the alias</p></li><li><p><code>alias</code>: The aliased index if u &gt; q</p></li></ul><p>Following pbrt-v4&#39;s implementation in util/sampling.h</p><p>Parameterized to work with both CPU (Vector) and GPU arrays (CLArray, etc.)</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[18]||(i[18]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L16-L28",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",y,[s("summary",null,[i[20]||(i[20]=s("a",{id:"Hikari.AliasTable-Tuple{AbstractVector{<:Real}}",href:"#Hikari.AliasTable-Tuple{AbstractVector{<:Real}}"},[s("span",{class:"jlbinding"},"Hikari.AliasTable")],-1)),i[21]||(i[21]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[23]||(i[23]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AliasTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(weights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Construct an alias table from weights (need not sum to 1).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[22]||(i[22]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L48-L52",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",m,[s("summary",null,[i[24]||(i[24]=s("a",{id:"Hikari.AmbientLight-Tuple{ColorTypes.RGB{Float32}}",href:"#Hikari.AmbientLight-Tuple{ColorTypes.RGB{Float32}}"},[s("span",{class:"jlbinding"},"Hikari.AmbientLight")],-1)),i[25]||(i[25]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[27]||(i[27]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AmbientLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create an AmbientLight from RGB color with automatic spectral conversion and photometric normalization, matching pbrt-v4&#39;s UniformInfiniteLight creation: <code>scale = 1 / SpectrumToPhotometric(spectrum)</code>.</p><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">light </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AmbientLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[26]||(i[26]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/ambient.jl#L10-L21",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",f,[s("summary",null,[i[28]||(i[28]=s("a",{id:"Hikari.BSDF",href:"#Hikari.BSDF"},[s("span",{class:"jlbinding"},"Hikari.BSDF")],-1)),i[29]||(i[29]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[31]||(i[31]=s("p",null,"Evaluate BSDF function given incident and outgoind directions.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[30]||(i[30]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/bsdf.jl#L93-L95",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",E,[s("summary",null,[i[32]||(i[32]=s("a",{id:"Hikari.BVHLightSampler",href:"#Hikari.BVHLightSampler"},[s("span",{class:"jlbinding"},"Hikari.BVHLightSampler")],-1)),i[33]||(i[33]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[35]||(i[35]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BVHLightSampler</span></span></code></pre></div><p>Spatially-aware light sampler using a BVH over bounded lights. Default light sampler in pbrt-v4 (lightsamplers.h:259-404).</p><p>Construction builds the BVH on CPU from light bounds. The resulting node array and bit trail array are uploaded to GPU for kernel use.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[34]||(i[34]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/bvh-light-sampler.jl#L260-L268",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_,[s("summary",null,[i[36]||(i[36]=s("a",{id:"Hikari.BVHLightSampler-Tuple{Raycore.MultiTypeSet}",href:"#Hikari.BVHLightSampler-Tuple{Raycore.MultiTypeSet}"},[s("span",{class:"jlbinding"},"Hikari.BVHLightSampler")],-1)),i[37]||(i[37]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[39]||(i[39]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BVHLightSampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Raycore.MultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; scene_radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Build a BVHLightSampler from a MultiTypeSet of lights. Separates infinite and bounded lights, builds BVH over bounded lights.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[38]||(i[38]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/bvh-light-sampler.jl#L277-L282",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",T,[s("summary",null,[i[40]||(i[40]=s("a",{id:"Hikari.BoxFilter",href:"#Hikari.BoxFilter"},[s("span",{class:"jlbinding"},"Hikari.BoxFilter")],-1)),i[41]||(i[41]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[43]||(i[43]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BoxFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>Simple box filter with constant weight 1.0 within the support region. This is the simplest filter - uniform sampling within the pixel.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[42]||(i[42]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L28-L33",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",j,[s("summary",null,[i[44]||(i[44]=s("a",{id:"Hikari.CIEXYZTable",href:"#Hikari.CIEXYZTable"},[s("span",{class:"jlbinding"},"Hikari.CIEXYZTable")],-1)),i[45]||(i[45]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[47]||(i[47]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CIEXYZTable{V </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractVector{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>GPU-compatible table for CIE XYZ color matching functions. Use <code>to_gpu(ArrayType, table)</code> to convert to GPU arrays.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[46]||(i[46]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L22-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",F,[s("summary",null,[i[48]||(i[48]=s("a",{id:"Hikari.CIEXYZTable-Tuple{}",href:"#Hikari.CIEXYZTable-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.CIEXYZTable")],-1)),i[49]||(i[49]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[51]||(i[51]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CIEXYZTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CIEXYZTable{Vector{Float32}}</span></span></code></pre></div><p>Create the default CPU CIE XYZ table from built-in data.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[50]||(i[50]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L347-L351",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",C,[s("summary",null,[i[52]||(i[52]=s("a",{id:"Hikari.CloudVolume",href:"#Hikari.CloudVolume"},[s("span",{class:"jlbinding"},"Hikari.CloudVolume")],-1)),i[53]||(i[53]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[55]||(i[55]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CloudVolume</span></span></code></pre></div><p>A 3D grid representing cloud density (e.g., liquid water content in g/m³). The volume is axis-aligned and defined by its bounding box.</p><p>This is both a data structure and a material type - when a ray hits geometry with a CloudVolume material, volumetric rendering is performed.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[54]||(i[54]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L22-L30",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",v,[s("summary",null,[i[56]||(i[56]=s("a",{id:"Hikari.CloudVolume-Tuple{AbstractArray{<:Real, 3}, Tuple{Real, Real, Real}}",href:"#Hikari.CloudVolume-Tuple{AbstractArray{<:Real, 3}, Tuple{Real, Real, Real}}"},[s("span",{class:"jlbinding"},"Hikari.CloudVolume")],-1)),i[57]||(i[57]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[59]||(i[59]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CloudVolume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(qˡ_data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{&lt;:Real,3}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, grid_extent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a CloudVolume from raw LWC data with physical grid info.</p><p><strong>Arguments</strong></p><ul><li><p><code>qˡ_data</code>: 3D array of liquid water specific humidity (kg/kg)</p></li><li><p><code>grid_extent</code>: Tuple (Lx, Ly, Lz) of domain size in meters</p></li><li><p><code>r_eff</code>: Effective droplet radius in meters (default: 10μm)</p></li><li><p><code>ρ_air</code>: Air density in kg/m³ (default: 1.0)</p></li><li><p><code>scale</code>: Additional scaling factor for visualization (default: 1.0)</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[58]||(i[58]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L432-L443",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",H,[s("summary",null,[i[60]||(i[60]=s("a",{id:"Hikari.CoatedConductor",href:"#Hikari.CoatedConductor"},[s("span",{class:"jlbinding"},"Hikari.CoatedConductor")],-1)),i[61]||(i[61]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[63]||(i[63]=s("p",null,[a("Type alias: "),s("code",null,"CoatedConductor"),a(" is the same as "),s("code",null,"CoatedConductorMaterial")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[62]||(i[62]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/coated-conductor.jl#L248",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",A,[s("summary",null,[i[64]||(i[64]=s("a",{id:"Hikari.CoatedConductorMaterial",href:"#Hikari.CoatedConductorMaterial"},[s("span",{class:"jlbinding"},"Hikari.CoatedConductorMaterial")],-1)),i[65]||(i[65]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[67]||(i[67]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CoatedConductorMaterial</span></span></code></pre></div><p>A layered material with a dielectric coating over a conductor (metal) base. This implements pbrt-v4&#39;s coatedconductor material using random walk sampling between the layers (LayeredBxDF algorithm).</p><p><strong>Fields</strong></p><p><strong>Interface (coating) layer</strong></p><ul><li><p><code>interface_u_roughness</code>: U roughness for the dielectric coating</p></li><li><p><code>interface_v_roughness</code>: V roughness for the dielectric coating</p></li><li><p><code>interface_eta</code>: Index of refraction of the dielectric coating</p></li></ul><p><strong>Conductor (base) layer</strong></p><ul><li><p><code>conductor_eta</code>: Complex index of refraction (real part) - OR use reflectance</p></li><li><p><code>conductor_k</code>: Complex index of refraction (imaginary part)</p></li><li><p><code>reflectance</code>: Alternative to eta/k - artist-friendly reflectance color</p></li><li><p><code>conductor_u_roughness</code>: U roughness for the conductor</p></li><li><p><code>conductor_v_roughness</code>: V roughness for the conductor</p></li></ul><p><strong>Volumetric scattering (between layers)</strong></p><ul><li><p><code>thickness</code>: Thickness of the coating layer (affects absorption)</p></li><li><p><code>albedo</code>: Single-scattering albedo of medium between layers (0 = no absorption)</p></li><li><p><code>g</code>: Henyey-Greenstein asymmetry parameter for medium scattering</p></li></ul><p><strong>Random walk parameters</strong></p><ul><li><p><code>max_depth</code>: Maximum random walk depth</p></li><li><p><code>n_samples</code>: Number of samples for estimating the BSDF</p></li><li><p><code>remap_roughness</code>: Whether to remap roughness to microfacet alpha</p></li></ul><p><strong>Notes</strong></p><ul><li><p><strong>Critical:</strong> Conductor eta/k are scaled by interface IOR: ce /= ieta, ck /= ieta</p></li><li><p>If <code>conductor_eta</code> is nothing, uses reflectance-based approach</p></li></ul>',13)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[66]||(i[66]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/coated-conductor.jl#L14-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",S,[s("summary",null,[i[68]||(i[68]=s("a",{id:"Hikari.CoatedConductorMaterial-Tuple{}",href:"#Hikari.CoatedConductorMaterial-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.CoatedConductorMaterial")],-1)),i[69]||(i[69]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[71]||(i[71]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; interface_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, interface_eta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a coated conductor material with keyword arguments.</p><p><strong>Arguments</strong></p><p><strong>Interface (coating)</strong></p><ul><li><p><code>interface_roughness</code>: Coating roughness (scalar or (u,v) tuple), default 0</p></li><li><p><code>interface_eta</code>: Coating IOR (default 1.5)</p></li></ul><p><strong>Conductor (base) - use EITHER eta/k OR reflectance</strong></p><ul><li><p><code>conductor_eta</code>: Complex IOR real part (RGBSpectrum, tuple, or Texture)</p></li><li><p><code>conductor_k</code>: Complex IOR imaginary part</p></li><li><p><code>reflectance</code>: Alternative artist-friendly color (if eta/k not specified)</p></li><li><p><code>conductor_roughness</code>: Conductor roughness (scalar or (u,v) tuple), default 0.01</p></li></ul><p><strong>Volumetric</strong></p><ul><li><p><code>thickness</code>: Coating thickness (default 0.01)</p></li><li><p><code>albedo</code>: Medium albedo (default 0 = no medium)</p></li><li><p><code>g</code>: HG asymmetry (default 0 = isotropic)</p></li></ul><p><strong>Algorithm</strong></p><ul><li><p><code>max_depth</code>: Max random walk depth (default 10)</p></li><li><p><code>n_samples</code>: Number of samples (default 1)</p></li><li><p><code>remap_roughness</code>: Remap roughness to alpha (default true)</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Glossy coated gold</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    interface_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    conductor_eta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.143</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.374</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.442</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Gold</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    conductor_k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.983</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.385</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.603</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Coated copper using reflectance</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.95</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.54</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Copper-like</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    conductor_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Car paint effect (rough coating over smooth metal)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    interface_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    conductor_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Red metallic</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,13)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[70]||(i[70]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/coated-conductor.jl#L118-L166",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",x,[s("summary",null,[i[72]||(i[72]=s("a",{id:"Hikari.CoatedDiffuse",href:"#Hikari.CoatedDiffuse"},[s("span",{class:"jlbinding"},"Hikari.CoatedDiffuse")],-1)),i[73]||(i[73]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[75]||(i[75]=s("p",null,[a("Type alias: "),s("code",null,"CoatedDiffuse"),a(" is the same as "),s("code",null,"CoatedDiffuseMaterial")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[74]||(i[74]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/coated-diffuse.jl#L130",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",B,[s("summary",null,[i[76]||(i[76]=s("a",{id:"Hikari.CoatedDiffuseMaterial",href:"#Hikari.CoatedDiffuseMaterial"},[s("span",{class:"jlbinding"},"Hikari.CoatedDiffuseMaterial")],-1)),i[77]||(i[77]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[79]||(i[79]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CoatedDiffuseMaterial</span></span></code></pre></div><p>A layered material with a dielectric coating over a diffuse base. This implements pbrt-v4&#39;s coateddiffuse material using random walk sampling between the layers (LayeredBxDF algorithm).</p><p><strong>Fields</strong></p><ul><li><p><code>reflectance</code>: Diffuse reflectance of the base layer (RGB color)</p></li><li><p><code>u_roughness</code>: Roughness in U direction for the dielectric coating</p></li><li><p><code>v_roughness</code>: Roughness in V direction for the dielectric coating</p></li><li><p><code>thickness</code>: Thickness of the coating layer (affects absorption)</p></li><li><p><code>eta</code>: Index of refraction of the dielectric coating</p></li><li><p><code>albedo</code>: Single-scattering albedo of medium between layers (0 = no absorption)</p></li><li><p><code>g</code>: Henyey-Greenstein asymmetry parameter for medium scattering</p></li><li><p><code>max_depth</code>: Maximum random walk depth</p></li><li><p><code>n_samples</code>: Number of samples for estimating the BSDF</p></li><li><p><code>remap_roughness</code>: Whether to remap roughness to microfacet alpha</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[78]||(i[78]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/coated-diffuse.jl#L13-L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",D,[s("summary",null,[i[80]||(i[80]=s("a",{id:"Hikari.CoatedDiffuseMaterial-Tuple{}",href:"#Hikari.CoatedDiffuseMaterial-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.CoatedDiffuseMaterial")],-1)),i[81]||(i[81]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[83]||(i[83]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedDiffuseMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; reflectance, roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, thickness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, eta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a coated diffuse material with keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><p><code>reflectance</code>: Diffuse color (RGBSpectrum, tuple, or Texture)</p></li><li><p><code>roughness</code>: Surface roughness (scalar or (u,v) tuple)</p></li><li><p><code>thickness</code>: Coating thickness (default 0.01)</p></li><li><p><code>eta</code>: Index of refraction (default 1.5 for typical dielectric)</p></li><li><p><code>albedo</code>: Medium albedo for absorption (default 0 = no medium)</p></li><li><p><code>g</code>: HG asymmetry parameter (default 0 = isotropic)</p></li><li><p><code>max_depth</code>: Max random walk depth (default 10)</p></li><li><p><code>n_samples</code>: Number of samples (default 1)</p></li><li><p><code>remap_roughness</code>: Remap roughness to alpha (default true)</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Simple coated diffuse (glossy plastic-like)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedDiffuseMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.45</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Rough coating</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedDiffuseMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># With absorbing medium</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedDiffuseMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), albedo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[82]||(i[82]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/coated-diffuse.jl#L67-L94",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",I,[s("summary",null,[i[84]||(i[84]=s("a",{id:"Hikari.Conductor",href:"#Hikari.Conductor"},[s("span",{class:"jlbinding"},"Hikari.Conductor")],-1)),i[85]||(i[85]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[87]||(i[87]=s("p",null,[a("Type alias: "),s("code",null,"Conductor"),a(" is the same as "),s("code",null,"ConductorMaterial")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[86]||(i[86]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L444",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",M,[s("summary",null,[i[88]||(i[88]=s("a",{id:"Hikari.ConductorMaterial",href:"#Hikari.ConductorMaterial"},[s("span",{class:"jlbinding"},"Hikari.ConductorMaterial")],-1)),i[89]||(i[89]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[91]||(i[91]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ConductorMaterial{EtaTex, KTex, RoughTex, ReflTex}</span></span></code></pre></div><p>A metal/conductor material with wavelength-dependent complex index of refraction.</p><p>Metals reflect light based on Fresnel equations for conductors, characterized by:</p><ul><li><p>η (eta): Real part of complex IOR (PiecewiseLinearSpectrum for presets, or RGB texture)</p></li><li><p>k: Imaginary part (extinction coefficient)</p></li><li><p>roughness: Surface roughness for microfacet model</p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>eta</code>: Real part of complex index of refraction (PiecewiseLinearSpectrum or texture)</p></li><li><p><code>k</code>: Extinction coefficient (PiecewiseLinearSpectrum or texture)</p></li><li><p><code>roughness</code>: Surface roughness</p></li><li><p><code>reflectance</code>: Color multiplier for Fresnel reflectance (for tinting)</p></li><li><p><code>remap_roughness</code>: Whether to remap roughness to alpha</p></li></ul>',6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[90]||(i[90]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L361-L377",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",G,[s("summary",null,[i[92]||(i[92]=s("a",{id:"Hikari.ConductorMaterial-Tuple{}",href:"#Hikari.ConductorMaterial-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.ConductorMaterial")],-1)),i[93]||(i[93]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[95]||(i[95]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; eta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, remap_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a metal/conductor material with Fresnel reflectance.</p><p><strong>Arguments</strong></p><ul><li><p><code>eta</code>: Real part of complex IOR - PiecewiseLinearSpectrum, (r,g,b) tuple, RGBSpectrum, or Texture</p></li><li><p><code>k</code>: Extinction coefficient - PiecewiseLinearSpectrum, (r,g,b) tuple, RGBSpectrum, or Texture</p></li><li><p><code>roughness</code>: Surface roughness (0 = mirror-like, higher = more diffuse)</p></li><li><p><code>reflectance</code>: Color multiplier for tinting the metal (default white = no tint)</p></li><li><p><code>remap_roughness</code>: Whether to remap roughness to microfacet alpha</p></li></ul><p><strong>Presets</strong></p><p>Use the provided metal constants for realistic materials:</p><ul><li><code>METAL_COPPER</code>, <code>METAL_GOLD</code>, <code>METAL_SILVER</code>, <code>METAL_ALUMINUM</code></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                                        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Generic metal</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; METAL_COPPER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Polished copper</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(eta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Custom green-tinted metal</span></span></code></pre></div>`,9)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[94]||(i[94]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L395-L417",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",P,[s("summary",null,[i[96]||(i[96]=s("a",{id:"Hikari.DDAMajorantIterator",href:"#Hikari.DDAMajorantIterator"},[s("span",{class:"jlbinding"},"Hikari.DDAMajorantIterator")],-1)),i[97]||(i[97]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[99]||(i[99]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DDAMajorantIterator</span></span></code></pre></div><p>3D DDA iterator for traversing voxels along a ray through a majorant grid. Returns per-voxel majorant bounds for tight delta tracking.</p><p>Following PBRT-v4&#39;s DDAMajorantIterator implementation. The iterator state is immutable - dda_next returns a new iterator with updated state.</p><p>Note: Uses NTuple instead of Vec types for GPU compatibility.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[98]||(i[98]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L218-L228",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",V,[s("summary",null,[i[100]||(i[100]=s("a",{id:"Hikari.DDAMajorantIterator-Tuple{M} where M<:Hikari.MajorantGrid",href:"#Hikari.DDAMajorantIterator-Tuple{M} where M<:Hikari.MajorantGrid"},[s("span",{class:"jlbinding"},"Hikari.DDAMajorantIterator")],-1)),i[101]||(i[101]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[103]||(i[103]=s("p",null,"Create an empty/invalid DDA iterator (for rays that miss the grid)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[102]||(i[102]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L250",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",L,[s("summary",null,[i[104]||(i[104]=s("a",{id:"Hikari.DenoiseConfig",href:"#Hikari.DenoiseConfig"},[s("span",{class:"jlbinding"},"Hikari.DenoiseConfig")],-1)),i[105]||(i[105]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[107]||(i[107]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DenoiseConfig</span></span></code></pre></div><p>Configuration parameters for the à-trous wavelet denoiser.</p><p><strong>Fields</strong></p><ul><li><p><code>iterations</code>: Number of filter passes (each doubles the filter radius)</p></li><li><p><code>sigma_color</code>: Color edge-stopping threshold (luminance sensitivity)</p></li><li><p><code>sigma_normal</code>: Normal edge-stopping threshold (angular sensitivity)</p></li><li><p><code>sigma_depth</code>: Depth edge-stopping threshold (distance sensitivity)</p></li><li><p><code>use_variance</code>: Whether to use per-pixel variance to guide filtering</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[106]||(i[106]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/denoise.jl#L16-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",w,[s("summary",null,[i[108]||(i[108]=s("a",{id:"Hikari.DenoiseConfig-Tuple{}",href:"#Hikari.DenoiseConfig-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.DenoiseConfig")],-1)),i[109]||(i[109]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[111]||(i[111]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DenoiseConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; iterations</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sigma_color</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sigma_normal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">128.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sigma_depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, use_variance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a denoiser configuration with sensible defaults.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[110]||(i[110]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/denoise.jl#L36-L40",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",R,[s("summary",null,[i[112]||(i[112]=s("a",{id:"Hikari.Dielectric",href:"#Hikari.Dielectric"},[s("span",{class:"jlbinding"},"Hikari.Dielectric")],-1)),i[113]||(i[113]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[115]||(i[115]=s("p",null,[a("Type alias: "),s("code",null,"Dielectric"),a(" is the same as "),s("code",null,"GlassMaterial")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[114]||(i[114]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L438",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",N,[s("summary",null,[i[116]||(i[116]=s("a",{id:"Hikari.Diffuse",href:"#Hikari.Diffuse"},[s("span",{class:"jlbinding"},"Hikari.Diffuse")],-1)),i[117]||(i[117]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[119]||(i[119]=s("p",null,[a("Type alias: "),s("code",null,"Diffuse"),a(" is the same as "),s("code",null,"MatteMaterial")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[118]||(i[118]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L432",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",O,[s("summary",null,[i[120]||(i[120]=s("a",{id:"Hikari.DiffuseAreaLight",href:"#Hikari.DiffuseAreaLight"},[s("span",{class:"jlbinding"},"Hikari.DiffuseAreaLight")],-1)),i[121]||(i[121]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[123]||(i[123]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DiffuseAreaLight{LeTex}</span></span></code></pre></div><p>Per-triangle area light for emissive surfaces. Following pbrt-v4&#39;s DiffuseAreaLight, stores triangle geometry for sampling and emission texture/color for evaluation.</p><p>Each emissive triangle creates one DiffuseAreaLight. The light sampler (PowerLightSampler) includes these for importance sampling, enabling MIS with BSDF sampling.</p><p><strong>Fields</strong></p><ul><li><p><code>vertices</code>: Triangle vertex positions (for uniform sampling)</p></li><li><p><code>normal</code>: Geometric normal of the triangle</p></li><li><p><code>area</code>: Triangle area (precomputed)</p></li><li><p><code>uv</code>: Vertex UV coordinates (for texture evaluation via barycentric interpolation)</p></li><li><p><code>Le</code>: Emitted radiance — <code>RGBSpectrum</code> for constant, <code>TextureRef</code> for textured emission</p></li><li><p><code>scale</code>: Intensity multiplier applied to Le</p></li><li><p><code>two_sided</code>: If true, emits from both sides of the surface</p></li></ul>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[122]||(i[122]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/diffuse-area.jl#L6-L24",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",J,[s("summary",null,[i[124]||(i[124]=s("a",{id:"Hikari.DiffuseTransmission",href:"#Hikari.DiffuseTransmission"},[s("span",{class:"jlbinding"},"Hikari.DiffuseTransmission")],-1)),i[125]||(i[125]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[127]||(i[127]=s("p",null,[a("Type alias: "),s("code",null,"DiffuseTransmission"),a(" is the same as "),s("code",null,"DiffuseTransmissionMaterial")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[126]||(i[126]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/diffuse-transmission.jl#L90",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",W,[s("summary",null,[i[128]||(i[128]=s("a",{id:"Hikari.DiffuseTransmissionMaterial",href:"#Hikari.DiffuseTransmissionMaterial"},[s("span",{class:"jlbinding"},"Hikari.DiffuseTransmissionMaterial")],-1)),i[129]||(i[129]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[131]||(i[131]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DiffuseTransmissionMaterial{RTex, TTex}</span></span></code></pre></div><p>A material that diffusely reflects and transmits light.</p><p>Models surfaces like paper, thin fabric, or leaves where light scatters diffusely on both sides. The reflection and transmission are independent Lambertian distributions.</p><p><strong>Fields</strong></p><ul><li><p><code>reflectance</code>: Diffuse reflectance color (same hemisphere as incident)</p></li><li><p><code>transmittance</code>: Diffuse transmittance color (opposite hemisphere)</p></li><li><p><code>scale</code>: Intensity multiplier applied to both R and T</p></li></ul><p><strong>Physics</strong></p><ul><li><p>Reflection: f = R/π (same hemisphere)</p></li><li><p>Transmission: f = T/π (opposite hemisphere)</p></li><li><p>Sampling: probability proportional to max(R) and max(T)</p></li></ul><p><strong>Usage</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Thin white paper (equal reflection and transmission)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">paper </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DiffuseTransmission</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), transmittance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Green leaf (green transmission, less reflection)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">leaf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DiffuseTransmission</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), transmittance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div>`,9)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[130]||(i[130]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/diffuse-transmission.jl#L11-L38",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",U,[s("summary",null,[i[132]||(i[132]=s("a",{id:"Hikari.DiffuseTransmissionMaterial-Tuple{}",href:"#Hikari.DiffuseTransmissionMaterial-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.DiffuseTransmissionMaterial")],-1)),i[133]||(i[133]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[135]||(i[135]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiffuseTransmissionMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; reflectance, transmittance, scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a diffuse transmission material with keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><p><code>reflectance</code>: Diffuse reflection color (RGBSpectrum, tuple, or Texture)</p></li><li><p><code>transmittance</code>: Diffuse transmission color (RGBSpectrum, tuple, or Texture)</p></li><li><p><code>scale</code>: Intensity multiplier (default 1.0)</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Thin translucent material</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiffuseTransmission</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), transmittance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Pure transmission (no reflection)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiffuseTransmission</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), transmittance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[134]||(i[134]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/diffuse-transmission.jl#L56-L74",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",q,[s("summary",null,[i[136]||(i[136]=s("a",{id:"Hikari.DirectionCone",href:"#Hikari.DirectionCone"},[s("span",{class:"jlbinding"},"Hikari.DirectionCone")],-1)),i[137]||(i[137]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[139]||(i[139]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DirectionCone</span></span></code></pre></div><p>Represents a cone of directions with axis <code>w</code> and half-angle <code>cosθ</code>.</p><ul><li><p><code>cosθ = 1</code>: point direction (degenerate cone)</p></li><li><p><code>cosθ = -1</code>: entire sphere</p></li><li><p><code>cosθ = Inf32</code>: empty cone (no directions)</p></li></ul><p>Following pbrt-v4&#39;s DirectionCone (vecmath.h:1784-1850).</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[138]||(i[138]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-bounds.jl#L14-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",z,[s("summary",null,[i[140]||(i[140]=s("a",{id:"Hikari.DirectionalLight",href:"#Hikari.DirectionalLight"},[s("span",{class:"jlbinding"},"Hikari.DirectionalLight")],-1)),i[141]||(i[141]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[143]||(i[143]=s("p",null,"Directional light does not take medium interface, since only reasonable interface for it is vacuum, otherwise all the light would've been absorbed by the medium, since the light is infinitely far away.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[142]||(i[142]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/directional.jl#L1-L5",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",K,[s("summary",null,[i[144]||(i[144]=s("a",{id:"Hikari.DirectionalLight-Tuple{ColorTypes.RGB{Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.DirectionalLight-Tuple{ColorTypes.RGB{Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.DirectionalLight")],-1)),i[145]||(i[145]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[147]||(i[147]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DirectionalLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, direction; illuminance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a DirectionalLight from RGB color with automatic spectral conversion and photometric normalization, matching pbrt-v4&#39;s light creation pattern.</p><p><strong>Arguments</strong></p><ul><li><p><code>rgb</code>: RGB color (intensity encoded in color values)</p></li><li><p><code>direction</code>: Direction the light travels (away from source)</p></li><li><p><code>illuminance</code>: Optional target illuminance in lux. If specified, overrides the RGB intensity.</p></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Directional light traveling in -Y direction (sunlight from above)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">light </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DirectionalLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[146]||(i[146]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/directional.jl#L35-L51",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Z,[s("summary",null,[i[148]||(i[148]=s("a",{id:"Hikari.Distribution2D",href:"#Hikari.Distribution2D"},[s("span",{class:"jlbinding"},"Hikari.Distribution2D")],-1)),i[149]||(i[149]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[151]||(i[151]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Distribution2D{V</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, M</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMatrix{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>GPU-compatible 2D distribution that stores all data in flat arrays/matrices. Avoids nested device arrays which cause SPIR-V validation errors on OpenCL.</p><p>The conditional distribution data is stored as 2D matrices where each column represents one conditional distribution:</p><ul><li><p><code>conditional_func[i, v]</code> = func value at index i for row v</p></li><li><p><code>conditional_cdf[i, v]</code> = cdf value at index i for row v</p></li><li><p><code>conditional_func_int[v]</code> = func_int for row v</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[150]||(i[150]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sampling.jl#L167-L178",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",X,[s("summary",null,[i[152]||(i[152]=s("a",{id:"Hikari.Distribution2D-Tuple{Matrix{Float32}}",href:"#Hikari.Distribution2D-Tuple{Matrix{Float32}}"},[s("span",{class:"jlbinding"},"Hikari.Distribution2D")],-1)),i[153]||(i[153]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[155]||(i[155]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Distribution2D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(func</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Matrix{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Construct a GPU-friendly 2D distribution directly from a function matrix. The matrix has dimensions (nv, nu) where nv is height (rows) and nu is width (columns).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[154]||(i[154]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sampling.jl#L195-L200",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Y,[s("summary",null,[i[156]||(i[156]=s("a",{id:"Hikari.Emissive",href:"#Hikari.Emissive"},[s("span",{class:"jlbinding"},"Hikari.Emissive")],-1)),i[157]||(i[157]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[159]||(i[159]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Emissive{LeTex}</span></span></code></pre></div><p>Emission data for area lights. Always used inside <code>MediumInterface.arealight</code> to add light emission to surfaces. A surface with an arealight both reflects light (via the MediumInterface&#39;s BSDF material) AND emits light.</p><p><strong>Fields</strong></p><ul><li><p><code>Le</code>: Emitted radiance (color/intensity texture or TextureRef)</p></li><li><p><code>scale</code>: Intensity multiplier applied to Le</p></li><li><p><code>two_sided</code>: If true, emits from both sides of the surface</p></li></ul><p><strong>Usage</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Surface that reflects AND glows:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MediumInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatteMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">diffuse_tex);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    arealight</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Le</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">glow_color, scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Pure emitter (no reflection):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MediumInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Le</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bright_tex, scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[158]||(i[158]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/emissive.jl#L8-L29",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Q,[s("summary",null,[i[160]||(i[160]=s("a",{id:"Hikari.Emissive-Tuple{}",href:"#Hikari.Emissive-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Emissive")],-1)),i[161]||(i[161]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[163]||(i[163]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; Le</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, two_sided</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create emission data for use in <code>MediumInterface.arealight</code>.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Diffuse surface with warm glow</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MediumInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatteMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">wood_tex);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    arealight</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Le</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">12</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, two_sided</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Pure area light</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MediumInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Le</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div>`,4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[162]||(i[162]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/emissive.jl#L40-L54",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$,[s("summary",null,[i[164]||(i[164]=s("a",{id:"Hikari.EnvironmentLight",href:"#Hikari.EnvironmentLight"},[s("span",{class:"jlbinding"},"Hikari.EnvironmentLight")],-1)),i[165]||(i[165]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[167]||(i[167]=s("p",null,"Environment light that illuminates the scene from all directions using an HDR environment map. Uses equirectangular (lat-long) mapping.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[166]||(i[166]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/environment.jl#L1-L4",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ii,[s("summary",null,[i[168]||(i[168]=s("a",{id:"Hikari.EnvironmentLight-Tuple{String}",href:"#Hikari.EnvironmentLight-Tuple{String}"},[s("span",{class:"jlbinding"},"Hikari.EnvironmentLight")],-1)),i[169]||(i[169]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[171]||(i[171]=s("p",null,"Convenience constructor that loads an environment map from a file. rotation: Mat3f rotation matrix (use rotation_matrix(angle_deg, axis) to create)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[170]||(i[170]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/environment.jl#L24-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",si,[s("summary",null,[i[172]||(i[172]=s("a",{id:"Hikari.EnvironmentMap",href:"#Hikari.EnvironmentMap"},[s("span",{class:"jlbinding"},"Hikari.EnvironmentMap")],-1)),i[173]||(i[173]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[175]||(i[175]=s("p",null,"Environment map texture for HDR image-based lighting. Supports sampling by direction vector (for environment lights). Includes importance sampling distribution based on luminance.",-1)),i[176]||(i[176]=s("p",null,"Uses equal-area (octahedral) mapping like pbrt-v4's ImageInfiniteLight. Expects SQUARE images in equal-area format.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[174]||(i[174]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L1-L8",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ei,[s("summary",null,[i[177]||(i[177]=s("a",{id:"Hikari.EnvironmentMap-Union{Tuple{D}, Tuple{T}, Tuple{S}, Tuple{GeometryBasics.Vec{3, Float32}, Any}} where {S<:Hikari.Spectrum, T, D}",href:"#Hikari.EnvironmentMap-Union{Tuple{D}, Tuple{T}, Tuple{S}, Tuple{GeometryBasics.Vec{3, Float32}, Any}} where {S<:Hikari.Spectrum, T, D}"},[s("span",{class:"jlbinding"},"Hikari.EnvironmentMap")],-1)),i[178]||(i[178]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[180]||(i[180]=s("p",null,[a("Sample the environment map by direction vector. The "),s("code",null,"textures"),a(" parameter is used to deref TextureRef fields when EnvironmentMap is stored in a MultiTypeSet.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[179]||(i[179]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L286-L289",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ti,[s("summary",null,[i[181]||(i[181]=s("a",{id:"Hikari.FastMaterialProps",href:"#Hikari.FastMaterialProps"},[s("span",{class:"jlbinding"},"Hikari.FastMaterialProps")],-1)),i[182]||(i[182]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[184]||(i[184]=s("p",null,"Simple material properties extracted from Hikari materials for fast shading.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[183]||(i[183]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/fast-wavefront.jl#L59-L61",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ai,[s("summary",null,[i[185]||(i[185]=s("a",{id:"Hikari.Film-Tuple{GeometryBasics.Point{2, Float32}}",href:"#Hikari.Film-Tuple{GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.Film")],-1)),i[186]||(i[186]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[188]||(i[188]=s("ul",null,[s("li",null,[s("p",null,"resolution: full resolution of the image in pixels.")]),s("li",null,[s("p",null,"crop_bounds: subset of the image to render in [0, 1] range.")]),s("li",null,[s("p",null,"diagonal: length of the diagonal of the film's physical area in mm.")]),s("li",null,[s("p",null,"scale: scale factor that is applied to the samples when writing image.")])],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[187]||(i[187]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/film.jl#L109-L114",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",li,[s("summary",null,[i[189]||(i[189]=s("a",{id:"Hikari.FilmSensor",href:"#Hikari.FilmSensor"},[s("span",{class:"jlbinding"},"Hikari.FilmSensor")],-1)),i[190]||(i[190]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[192]||(i[192]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FilmSensor</span></span></code></pre></div><p>Film sensor parameters for physically-based image formation. Matches pbrt-v4&#39;s film sensor simulation.</p><p><strong>Fields</strong></p><ul><li><p><code>iso</code>: ISO sensitivity (default 100). Higher = brighter.</p></li><li><p><code>exposure_time</code>: Exposure time in seconds (default 1.0).</p></li><li><p><code>white_balance</code>: Color temperature in Kelvin for white balance (default 0 = disabled). When set, applies Bradford chromatic adaptation from the illuminant to D65.</p></li></ul><p>The imaging ratio is computed as: <code>imagingRatio = exposure_time * iso / 100</code> This matches pbrt-v4&#39;s PixelSensor behavior.</p><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Nikon D850 settings from pbrt bunny-cloud scene</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sensor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FilmSensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iso</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">90</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, exposure_time</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, white_balance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">postprocess!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film; sensor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sensor, tonemap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:aces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,7)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[191]||(i[191]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/postprocess.jl#L15-L36",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ni,[s("summary",null,[i[193]||(i[193]=s("a",{id:"Hikari.FilterSample",href:"#Hikari.FilterSample"},[s("span",{class:"jlbinding"},"Hikari.FilterSample")],-1)),i[194]||(i[194]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[196]||(i[196]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FilterSample</span></span></code></pre></div><p>Result of sampling a filter. Contains the offset position and the weight for this sample (filter value / pdf).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[195]||(i[195]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L13-L18",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ri,[s("summary",null,[i[197]||(i[197]=s("a",{id:"Hikari.FilterSampler",href:"#Hikari.FilterSampler"},[s("span",{class:"jlbinding"},"Hikari.FilterSampler")],-1)),i[198]||(i[198]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[200]||(i[200]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FilterSampler{F</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Importance sampler for filters that don&#39;t have analytical sampling. Tabulates the filter function and uses PiecewiseConstant2D for sampling.</p><p>For BoxFilter and TriangleFilter, direct analytical sampling is used instead.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[199]||(i[199]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L488-L495",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",pi,[s("summary",null,[i[201]||(i[201]=s("a",{id:"Hikari.FilterSampler-Tuple{F} where F<:Hikari.AbstractFilter",href:"#Hikari.FilterSampler-Tuple{F} where F<:Hikari.AbstractFilter"},[s("span",{class:"jlbinding"},"Hikari.FilterSampler")],-1)),i[202]||(i[202]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[204]||(i[204]=s("p",null,"Create a FilterSampler for the given filter.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[203]||(i[203]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L502-L504",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",oi,[s("summary",null,[i[205]||(i[205]=s("a",{id:"Hikari.GPUFilterParams",href:"#Hikari.GPUFilterParams"},[s("span",{class:"jlbinding"},"Hikari.GPUFilterParams")],-1)),i[206]||(i[206]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[208]||(i[208]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GPUFilterParams</span></span></code></pre></div><p>GPU-compatible filter parameters for kernel use. For filters requiring tabulated importance sampling (Gaussian, Mitchell, Lanczos), the table data must be passed separately to the kernel.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[207]||(i[207]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L567-L573",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",di,[s("summary",null,[i[209]||(i[209]=s("a",{id:"Hikari.GPUFilterSamplerData",href:"#Hikari.GPUFilterSamplerData"},[s("span",{class:"jlbinding"},"Hikari.GPUFilterSamplerData")],-1)),i[210]||(i[210]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[212]||(i[212]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GPUFilterSamplerData</span></span></code></pre></div><p>GPU-compatible tabulated data for importance sampling filters. Stores the distribution data needed for sampling Gaussian/Mitchell/Lanczos filters.</p><p>This matches pbrt-v4&#39;s FilterSampler which uses PiecewiseConstant2D.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[211]||(i[211]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L603-L610",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ki,[s("summary",null,[i[213]||(i[213]=s("a",{id:"Hikari.GPUFilterSamplerData-Tuple{Hikari.AbstractFilter}",href:"#Hikari.GPUFilterSamplerData-Tuple{Hikari.AbstractFilter}"},[s("span",{class:"jlbinding"},"Hikari.GPUFilterSamplerData")],-1)),i[214]||(i[214]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[216]||(i[216]=s("p",null,"Build GPU-compatible filter sampler data from a filter. Returns nothing for Box/Triangle filters (they use analytical sampling).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[215]||(i[215]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L634-L637",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",hi,[s("summary",null,[i[217]||(i[217]=s("a",{id:"Hikari.GaussianFilter",href:"#Hikari.GaussianFilter"},[s("span",{class:"jlbinding"},"Hikari.GaussianFilter")],-1)),i[218]||(i[218]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[220]||(i[220]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GaussianFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), sigma</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Gaussian filter with configurable sigma. The filter is truncated at the radius and normalized by subtracting the value at the boundary.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[219]||(i[219]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L129-L135",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ui,[s("summary",null,[i[221]||(i[221]=s("a",{id:"Hikari.GlassMaterial",href:"#Hikari.GlassMaterial"},[s("span",{class:"jlbinding"},"Hikari.GlassMaterial")],-1)),i[222]||(i[222]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[224]||(i[224]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GlassMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kr, Kt, u_roughness, v_roughness, index, remap_roughness)</span></span></code></pre></div><p>Glass/dielectric material with reflection and transmission.</p><ul><li><p><code>Kr</code>: Spectral reflectance (Texture or TextureRef)</p></li><li><p><code>Kt</code>: Spectral transmittance (Texture or TextureRef)</p></li><li><p><code>u_roughness</code>: Roughness in u direction (0 = perfect specular)</p></li><li><p><code>v_roughness</code>: Roughness in v direction (0 = perfect specular)</p></li><li><p><code>index</code>: Index of refraction</p></li><li><p><code>remap_roughness</code>: Whether to remap roughness to alpha</p></li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[223]||(i[223]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L197-L208",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",gi,[s("summary",null,[i[225]||(i[225]=s("a",{id:"Hikari.GlassMaterial-Tuple{}",href:"#Hikari.GlassMaterial-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.GlassMaterial")],-1)),i[226]||(i[226]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[228]||(i[228]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GlassMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; Kr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), Kt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, remap_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a glass/dielectric material with reflection and transmission.</p><p><strong>Arguments</strong></p><ul><li><p><code>Kr</code>: Reflectance color</p></li><li><p><code>Kt</code>: Transmittance color</p></li><li><p><code>roughness</code>: Surface roughness (0 = perfect specular, can be single value or (u,v) tuple)</p></li><li><p><code>index</code>: Index of refraction (1.5 for glass, 1.33 for water, 2.4 for diamond)</p></li><li><p><code>remap_roughness</code>: Whether to remap roughness to microfacet alpha</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GlassMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                                </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Clear glass</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GlassMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Amber tinted</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GlassMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)                   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Frosted glass</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GlassMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Anisotropic roughness</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[227]||(i[227]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L279-L298",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ci,[s("summary",null,[i[229]||(i[229]=s("a",{id:"Hikari.GridMedium",href:"#Hikari.GridMedium"},[s("span",{class:"jlbinding"},"Hikari.GridMedium")],-1)),i[230]||(i[230]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[232]||(i[232]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GridMedium</span></span></code></pre></div><p>A participating medium with spatially varying density. Uses a 3D grid for density and a coarser majorant grid for efficient sampling.</p><p>Note: Uses Vec{3, Int32} for density_res for GPU compatibility.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[231]||(i[231]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L865-L872",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",bi,[s("summary",null,[i[233]||(i[233]=s("a",{id:"Hikari.HGPhaseFunction",href:"#Hikari.HGPhaseFunction"},[s("span",{class:"jlbinding"},"Hikari.HGPhaseFunction")],-1)),i[234]||(i[234]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[236]||(i[236]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HGPhaseFunction</span></span></code></pre></div><p>Henyey-Greenstein phase function for anisotropic scattering.</p><ul><li><p>g &gt; 0: Forward scattering (clouds typically g ≈ 0.85)</p></li><li><p>g = 0: Isotropic scattering</p></li><li><p>g &lt; 0: Backward scattering</p></li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[235]||(i[235]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L8-L15",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",yi,[s("summary",null,[i[237]||(i[237]=s("a",{id:"Hikari.HomogeneousMajorantIterator",href:"#Hikari.HomogeneousMajorantIterator"},[s("span",{class:"jlbinding"},"Hikari.HomogeneousMajorantIterator")],-1)),i[238]||(i[238]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[240]||(i[240]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HomogeneousMajorantIterator</span></span></code></pre></div><p>Simple iterator that returns a single majorant segment for homogeneous media. Provides consistent iterator interface with DDAMajorantIterator.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[239]||(i[239]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L126-L131",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",mi,[s("summary",null,[i[241]||(i[241]=s("a",{id:"Hikari.HomogeneousMedium",href:"#Hikari.HomogeneousMedium"},[s("span",{class:"jlbinding"},"Hikari.HomogeneousMedium")],-1)),i[242]||(i[242]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[244]||(i[244]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HomogeneousMedium</span></span></code></pre></div><p>A participating medium with constant properties throughout. Simplest medium type - majorant equals actual extinction everywhere.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[243]||(i[243]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L756-L761",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fi,[s("summary",null,[i[245]||(i[245]=s("a",{id:"Hikari.LanczosSincFilter",href:"#Hikari.LanczosSincFilter"},[s("span",{class:"jlbinding"},"Hikari.LanczosSincFilter")],-1)),i[246]||(i[246]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[248]||(i[248]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LanczosSincFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), tau</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Lanczos-windowed sinc filter for high-quality reconstruction. The sinc function is windowed by another sinc to reduce ringing.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[247]||(i[247]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L263-L268",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ei,[s("summary",null,[i[249]||(i[249]=s("a",{id:"Hikari.LayeredBSDFSample",href:"#Hikari.LayeredBSDFSample"},[s("span",{class:"jlbinding"},"Hikari.LayeredBSDFSample")],-1)),i[250]||(i[250]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[252]||(i[252]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LayeredBSDFSample </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Internal sample result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LayeredBxDF interfaces</span></span></code></pre></div><p>Contains the sampled direction, BSDF value, pdf, and flags indicating whether the sample is reflection/transmission and specular/glossy.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[251]||(i[251]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L947-L952",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_i,[s("summary",null,[i[253]||(i[253]=s("a",{id:"Hikari.LightBVHNode",href:"#Hikari.LightBVHNode"},[s("span",{class:"jlbinding"},"Hikari.LightBVHNode")],-1)),i[254]||(i[254]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[256]||(i[256]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LightBVHNode</span></span></code></pre></div><p>BVH node for the light sampler. Stores unquantized LightBounds fields plus tree connectivity. Interior nodes store child1 index; child0 is always at <code>node_idx + 1</code> (left child immediately follows parent in array).</p><p>Simplification vs pbrt-v4: we skip CompactLightBounds quantization. Node is ~64 bytes instead of 32, but avoids OctahedralVector/bit-packing complexity. With 37k lights this is ~5MB — negligible on GPU.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[255]||(i[255]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/bvh-light-sampler.jl#L15-L25",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ti,[s("summary",null,[i[257]||(i[257]=s("a",{id:"Hikari.LightBounds",href:"#Hikari.LightBounds"},[s("span",{class:"jlbinding"},"Hikari.LightBounds")],-1)),i[258]||(i[258]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[260]||(i[260]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LightBounds</span></span></code></pre></div><p>Stores spatial and directional bounds for a light or group of lights. Used by BVHLightSampler for importance-based light selection.</p><p>Following pbrt-v4&#39;s LightBounds (lights.h:104-125).</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[259]||(i[259]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-bounds.jl#L115-L122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ji,[s("summary",null,[i[261]||(i[261]=s("a",{id:"Hikari.LightSamplerData",href:"#Hikari.LightSamplerData"},[s("span",{class:"jlbinding"},"Hikari.LightSamplerData")],-1)),i[262]||(i[262]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[264]||(i[264]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LightSamplerData</span></span></code></pre></div><p>GPU-compatible light sampler data structure. Stores alias table as flat arrays that can be uploaded to GPU.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[263]||(i[263]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L462-L467",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fi,[s("summary",null,[i[265]||(i[265]=s("a",{id:"Hikari.MajorantGrid",href:"#Hikari.MajorantGrid"},[s("span",{class:"jlbinding"},"Hikari.MajorantGrid")],-1)),i[266]||(i[266]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[268]||(i[268]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MajorantGrid</span></span></code></pre></div><p>Coarse grid storing maximum extinction coefficients for DDA traversal. Used to provide tight majorant bounds in heterogeneous media.</p><p>Note: Uses Vec{3, Int32} instead of Vec3i (Int64) for GPU compatibility.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[267]||(i[267]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L170-L177",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ci,[s("summary",null,[i[269]||(i[269]=s("a",{id:"Hikari.MatrixCamera",href:"#Hikari.MatrixCamera"},[s("span",{class:"jlbinding"},"Hikari.MatrixCamera")],-1)),i[270]||(i[270]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[272]||(i[272]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MatrixCamera </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Camera</span></span></code></pre></div><p>A camera defined by view and projection matrices, matching the convention used by Makie&#39;s <code>Camera</code> struct (OpenGL-style: camera looks along -z in camera space).</p><p>This is a fallback camera for scenes that don&#39;t use <code>Camera3D</code> (e.g. <code>Axis3</code> which uses its own camera type but still sets view/projection matrices on the scene camera).</p><p>The view matrix is world-to-camera, and the projection matrix is camera-to-clip (NDC). Both use OpenGL conventions (right-handed, camera looks along -z, clip z in [-1, 1]).</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[271]||(i[271]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/camera/matrix.jl#L1-L12",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",vi,[s("summary",null,[i[273]||(i[273]=s("a",{id:"Hikari.MatrixCamera-Tuple{StaticArraysCore.SMatrix{4, 4, Float32, 16}, StaticArraysCore.SMatrix{4, 4, Float32, 16}, GeometryBasics.Point{2, Float32}, Raycore.Bounds2}",href:"#Hikari.MatrixCamera-Tuple{StaticArraysCore.SMatrix{4, 4, Float32, 16}, StaticArraysCore.SMatrix{4, 4, Float32, 16}, GeometryBasics.Point{2, Float32}, Raycore.Bounds2}"},[s("span",{class:"jlbinding"},"Hikari.MatrixCamera")],-1)),i[274]||(i[274]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[276]||(i[276]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatrixCamera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(view, projection, resolution, screen_window)</span></span></code></pre></div><p>Construct a <code>MatrixCamera</code> with a custom screen window (NDC sub-region). Used for rendering a cropped viewport where film pixels correspond to a sub-region of the full projection.</p><ul><li><code>screen_window</code>: NDC bounds for the visible region (default full: [-1,-1] to [1,1])</li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[275]||(i[275]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/camera/matrix.jl#L60-L68",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Hi,[s("summary",null,[i[277]||(i[277]=s("a",{id:"Hikari.MatrixCamera-Tuple{StaticArraysCore.SMatrix{4, 4, Float32, 16}, StaticArraysCore.SMatrix{4, 4, Float32, 16}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.MatrixCamera-Tuple{StaticArraysCore.SMatrix{4, 4, Float32, 16}, StaticArraysCore.SMatrix{4, 4, Float32, 16}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.MatrixCamera")],-1)),i[278]||(i[278]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[280]||(i[280]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatrixCamera</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(view</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Mat4f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, projection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Mat4f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, resolution</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Construct a <code>MatrixCamera</code> from Makie-style view and projection matrices.</p><ul><li><p><code>view</code>: world-to-camera matrix (OpenGL convention, camera looks along -z)</p></li><li><p><code>projection</code>: camera-to-clip matrix (OpenGL perspective projection)</p></li><li><p><code>resolution</code>: film resolution as <code>Point2f(width, height)</code></p></li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[279]||(i[279]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/camera/matrix.jl#L21-L29",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ai,[s("summary",null,[i[281]||(i[281]=s("a",{id:"Hikari.MatteMaterial",href:"#Hikari.MatteMaterial"},[s("span",{class:"jlbinding"},"Hikari.MatteMaterial")],-1)),i[282]||(i[282]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[284]||(i[284]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatteMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Texture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, σ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Texture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Matte (diffuse) material with Lambertian or Oren-Nayar BRDF.</p><ul><li><p><code>Kd</code>: Spectral diffuse reflection (color texture or TextureRef)</p></li><li><p><code>σ</code>: Scalar roughness for Oren-Nayar model (0 = Lambertian)</p></li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[283]||(i[283]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L172-L179",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Si,[s("summary",null,[i[285]||(i[285]=s("a",{id:"Hikari.MatteMaterial-Tuple{}",href:"#Hikari.MatteMaterial-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.MatteMaterial")],-1)),i[286]||(i[286]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[288]||(i[288]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatteMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), σ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a matte (diffuse) material with optional Oren-Nayar roughness.</p><p><strong>Arguments</strong></p><ul><li><p><code>Kd</code>: Diffuse color - can be RGBSpectrum, (r,g,b) tuple, or Texture</p></li><li><p><code>σ</code>: Roughness angle in degrees (0 = Lambertian, &gt;0 = Oren-Nayar)</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatteMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Red matte</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatteMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), σ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Red with roughness</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatteMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">my_texture)                   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Textured</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[287]||(i[287]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L240-L255",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xi,[s("summary",null,[i[289]||(i[289]=s("a",{id:"Hikari.MediumInteraction",href:"#Hikari.MediumInteraction"},[s("span",{class:"jlbinding"},"Hikari.MediumInteraction")],-1)),i[290]||(i[290]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[292]||(i[292]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MediumInteraction</span></span></code></pre></div><p>Represents an interaction point within a participating medium. Created when a real scattering event occurs during delta tracking.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[291]||(i[291]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L735-L740",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Bi,[s("summary",null,[i[293]||(i[293]=s("a",{id:"Hikari.MediumInterface",href:"#Hikari.MediumInterface"},[s("span",{class:"jlbinding"},"Hikari.MediumInterface")],-1)),i[294]||(i[294]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[296]||(i[296]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MediumInterface{M</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Material</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, I, O}</span></span></code></pre></div><p>Material wrapper that combines a surface BSDF with medium boundaries. Surfaces define boundaries between media.</p><p>Emission is handled separately by DiffuseAreaLight (registered per-triangle in scene.lights, not on the material).</p><p><strong>Fields</strong></p><ul><li><p><code>material</code>: The underlying BSDF material (e.g., MatteMaterial, GlassMaterial)</p></li><li><p><code>inside</code>: Medium for inside the surface, or <code>nothing</code> for vacuum</p></li><li><p><code>outside</code>: Medium for outside the surface, or <code>nothing</code> for vacuum</p></li></ul><p><strong>Usage</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Glass with fog inside</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MediumInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GlassMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); inside</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fog)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Simple material with no medium transition</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MediumInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatteMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kd, σ))</span></span></code></pre></div>`,7)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[295]||(i[295]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/medium-interface.jl#L16-L38",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Di,[s("summary",null,[i[297]||(i[297]=s("a",{id:"Hikari.MediumInterfaceIdx",href:"#Hikari.MediumInterfaceIdx"},[s("span",{class:"jlbinding"},"Hikari.MediumInterfaceIdx")],-1)),i[298]||(i[298]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[300]||(i[300]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MediumInterfaceIdx</span></span></code></pre></div><p>Internal index wrapper with material and medium indices for GPU-compatible dispatch. Created during scene building from <code>MediumInterface</code>.</p><p><strong>Fields (all SetKey indices)</strong></p><ul><li><p><code>material</code>: SetKey into materials container (BSDF material)</p></li><li><p><code>inside</code>: SetKey for inside medium (invalid = vacuum)</p></li><li><p><code>outside</code>: SetKey for outside medium (invalid = vacuum)</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[299]||(i[299]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/medium-interface.jl#L65-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ii,[s("summary",null,[i[301]||(i[301]=s("a",{id:"Hikari.MediumProperties",href:"#Hikari.MediumProperties"},[s("span",{class:"jlbinding"},"Hikari.MediumProperties")],-1)),i[302]||(i[302]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[304]||(i[304]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MediumProperties</span></span></code></pre></div><p>Properties of a participating medium at a specific point. Returned by medium sampling functions.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[303]||(i[303]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L82-L87",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Mi,[s("summary",null,[i[305]||(i[305]=s("a",{id:"Hikari.Metal",href:"#Hikari.Metal"},[s("span",{class:"jlbinding"},"Hikari.Metal")],-1)),i[306]||(i[306]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[308]||(i[308]=s("p",null,[a("Type alias: "),s("code",null,"Metal"),a(" is the same as "),s("code",null,"ConductorMaterial"),a(" (legacy alias)")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[307]||(i[307]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L447",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Gi,[s("summary",null,[i[309]||(i[309]=s("a",{id:"Hikari.MetalMaterial",href:"#Hikari.MetalMaterial"},[s("span",{class:"jlbinding"},"Hikari.MetalMaterial")],-1)),i[310]||(i[310]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[312]||(i[312]=s("p",null,[a("Type alias: "),s("code",null,"MetalMaterial"),a(" is the same as "),s("code",null,"ConductorMaterial"),a(" (legacy alias)")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[311]||(i[311]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L450",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Pi,[s("summary",null,[i[313]||(i[313]=s("a",{id:"Hikari.Mirror",href:"#Hikari.Mirror"},[s("span",{class:"jlbinding"},"Hikari.Mirror")],-1)),i[314]||(i[314]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[316]||(i[316]=s("p",null,[a("Type alias: "),s("code",null,"Mirror"),a(" is the same as "),s("code",null,"MirrorMaterial")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[315]||(i[315]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L435",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Vi,[s("summary",null,[i[317]||(i[317]=s("a",{id:"Hikari.MirrorMaterial",href:"#Hikari.MirrorMaterial"},[s("span",{class:"jlbinding"},"Hikari.MirrorMaterial")],-1)),i[318]||(i[318]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[320]||(i[320]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MirrorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Texture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Perfect mirror (specular reflection) material.</p><ul><li><code>Kr</code>: Spectral reflectance (color texture or TextureRef)</li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[319]||(i[319]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L186-L192",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Li,[s("summary",null,[i[321]||(i[321]=s("a",{id:"Hikari.MirrorMaterial-Tuple{}",href:"#Hikari.MirrorMaterial-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.MirrorMaterial")],-1)),i[322]||(i[322]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[324]||(i[324]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MirrorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; Kr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>Create a perfect mirror (specular reflection) material.</p><p><strong>Arguments</strong></p><ul><li><code>Kr</code>: Reflectance color - can be RGBSpectrum, (r,g,b) tuple, or Texture</li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MirrorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                               </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Default silver mirror</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MirrorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.95</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.93</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.88</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Gold-tinted</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MirrorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))            </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Using tuple</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[323]||(i[323]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L260-L274",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",wi,[s("summary",null,[i[325]||(i[325]=s("a",{id:"Hikari.MitchellFilter",href:"#Hikari.MitchellFilter"},[s("span",{class:"jlbinding"},"Hikari.MitchellFilter")],-1)),i[326]||(i[326]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[328]||(i[328]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MitchellFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, C</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Mitchell-Netravali filter - a family of cubic filters parameterized by B and C. Default B=C=1/3 gives a good balance between ringing and blurring.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[327]||(i[327]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L209-L214",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ri,[s("summary",null,[i[329]||(i[329]=s("a",{id:"Hikari.Mix",href:"#Hikari.Mix"},[s("span",{class:"jlbinding"},"Hikari.Mix")],-1)),i[330]||(i[330]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[332]||(i[332]=s("p",null,[a("Type alias: "),s("code",null,"Mix"),a(" is the same as "),s("code",null,"MixMaterial")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[331]||(i[331]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/mix-material.jl#L274",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ni,[s("summary",null,[i[333]||(i[333]=s("a",{id:"Hikari.MixMaterial",href:"#Hikari.MixMaterial"},[s("span",{class:"jlbinding"},"Hikari.MixMaterial")],-1)),i[334]||(i[334]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[336]||(i[336]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MixMaterial{M1, M2, AmountTex}</span></span></code></pre></div><p>A material that stochastically blends between two sub-materials based on a mixing amount.</p><p>Following pbrt-v4, the material selection is deterministic based on:</p><ul><li><p>The intersection position and viewing direction</p></li><li><p>A hash function to generate deterministic randomness</p></li><li><p>The <code>amount</code> texture value at the hit point</p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>material1</code>: First material (selected when amount → 0)</p></li><li><p><code>material2</code>: Second material (selected when amount → 1)</p></li><li><p><code>amount</code>: Texture controlling the blend ratio (0 = material1, 1 = material2)</p></li><li><p><code>material1_idx</code>: Index of material1 in the materials tuple</p></li><li><p><code>material2_idx</code>: Index of material2 in the materials tuple</p></li></ul><p><strong>Usage</strong></p><p>MixMaterial is resolved at intersection time before material evaluation. The integrator should call <code>choose_material()</code> to get the actual material index to use for the hit point, then proceed with normal material evaluation.</p>',8)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[335]||(i[335]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/mix-material.jl#L17-L38",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Oi,[s("summary",null,[i[337]||(i[337]=s("a",{id:"Hikari.MixMaterial-Tuple{}",href:"#Hikari.MixMaterial-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.MixMaterial")],-1)),i[338]||(i[338]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[340]||(i[340]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MixMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; materials, amount, material_indices)</span></span></code></pre></div><p>Create a MixMaterial with keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><p><code>materials</code>: Tuple of two materials (material1, material2)</p></li><li><p><code>amount</code>: Mixing amount (0-1 scalar, texture, or image path)</p></li><li><p><code>material_indices</code>: Tuple of SetKey for each material</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Simple 50-50 blend</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MixMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gold_material, red_diffuse),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    amount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    material_indices</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gold_idx, diffuse_idx)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Texture-based blend (e.g., mask texture)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MixMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gold_material, red_diffuse),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    amount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mask_texture,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    material_indices</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gold_idx, diffuse_idx)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[339]||(i[339]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/mix-material.jl#L59-L85",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ji,[s("summary",null,[i[341]||(i[341]=s("a",{id:"Hikari.MultiMaterialQueue",href:"#Hikari.MultiMaterialQueue"},[s("span",{class:"jlbinding"},"Hikari.MultiMaterialQueue")],-1)),i[342]||(i[342]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[344]||(i[344]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MultiMaterialQueue{N}</span></span></code></pre></div><p>Container holding N separate work queues, one per material type. Items are routed to the correct queue based on SetKey.material_type.</p><p>Following pbrt-v4&#39;s MultiWorkQueue pattern where:</p><ul><li><p>Push routes to correct sub-queue based on type</p></li><li><p>Each sub-queue is processed with type-specialized kernel</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[343]||(i[343]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/multi-material-eval.jl#L13-L22",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Wi,[s("summary",null,[i[345]||(i[345]=s("a",{id:"Hikari.NanoVDBMedium",href:"#Hikari.NanoVDBMedium"},[s("span",{class:"jlbinding"},"Hikari.NanoVDBMedium")],-1)),i[346]||(i[346]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[348]||(i[348]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">NanoVDBMedium</span></span></code></pre></div><p>Direct NanoVDB volume sampling medium that keeps the buffer in native format. Matches pbrt-v4&#39;s NanoVDBMedium implementation exactly.</p><p>The buffer contains the entire decompressed NanoVDB grid data. Tree traversal is done on-the-fly using byte offsets.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[347]||(i[347]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L144-L152",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ui,[s("summary",null,[i[349]||(i[349]=s("a",{id:"Hikari.NanoVDBMedium-Tuple{Array{Float32, 3}}",href:"#Hikari.NanoVDBMedium-Tuple{Array{Float32, 3}}"},[s("span",{class:"jlbinding"},"Hikari.NanoVDBMedium")],-1)),i[350]||(i[350]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[352]||(i[352]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NanoVDBMedium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Array{Float32,3}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; bounds, σ_a, σ_s, g, majorant_res, buffer_alloc)</span></span></code></pre></div><p>Construct a NanoVDBMedium from a dense 3D array by building a sparse NanoVDB tree. Only leaf blocks (8³) containing non-zero voxels are stored, giving significant memory savings for sparse volumetric data like cloud fields.</p><p><strong>Arguments</strong></p><ul><li><p><code>data</code>: Dense 3D Float32 array of density/opacity values</p></li><li><p><code>bounds</code>: World-space bounding box (<code>Bounds3</code>)</p></li><li><p><code>σ_a</code>: Absorption coefficient (default: 0 for pure scattering clouds)</p></li><li><p><code>σ_s</code>: Scattering coefficient (default: 1)</p></li><li><p><code>g</code>: Henyey-Greenstein asymmetry parameter</p></li><li><p><code>majorant_res</code>: Resolution of majorant grid (default: 64³)</p></li><li><p><code>buffer_alloc</code>: Array constructor for target device (default: <code>Vector{UInt8}</code>)</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[351]||(i[351]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L948-L963",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",qi,[s("summary",null,[i[353]||(i[353]=s("a",{id:"Hikari.NanoVDBMedium-Tuple{String}",href:"#Hikari.NanoVDBMedium-Tuple{String}"},[s("span",{class:"jlbinding"},"Hikari.NanoVDBMedium")],-1)),i[354]||(i[354]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[356]||(i[356]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NanoVDBMedium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filepath</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; σ_a, σ_s, g, transform, majorant_res)</span></span></code></pre></div><p>Construct a NanoVDBMedium from a NanoVDB file.</p><p><strong>Arguments</strong></p><ul><li><p><code>filepath</code>: Path to the .nvdb file</p></li><li><p><code>σ_a</code>: Absorption coefficient (RGBSpectrum)</p></li><li><p><code>σ_s</code>: Scattering coefficient (RGBSpectrum)</p></li><li><p><code>g</code>: Henyey-Greenstein asymmetry parameter</p></li><li><p><code>transform</code>: Optional 3x3 rotation matrix (medium-to-world, like pbrt&#39;s Rotate)</p></li><li><p><code>majorant_res</code>: Resolution of majorant grid (default 64³)</p></li></ul><p>For pbrt bunny-cloud scene, use: transform = RotZ(π) * RotX(π/2) # Rotate 180° around Z, then 90° around X</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[355]||(i[355]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L1304-L1319",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",zi,[s("summary",null,[i[357]||(i[357]=s("a",{id:"Hikari.PCG32State",href:"#Hikari.PCG32State"},[s("span",{class:"jlbinding"},"Hikari.PCG32State")],-1)),i[358]||(i[358]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[360]||(i[360]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PCG32State</span></span></code></pre></div><p>GPU-compatible immutable PCG32 random number generator state. Uses tuple-like struct for stack allocation on GPU.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[359]||(i[359]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L749-L754",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ki,[s("summary",null,[i[361]||(i[361]=s("a",{id:"Hikari.PWDirectLightingResult",href:"#Hikari.PWDirectLightingResult"},[s("span",{class:"jlbinding"},"Hikari.PWDirectLightingResult")],-1)),i[362]||(i[362]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[364]||(i[364]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWDirectLightingResult</span></span></code></pre></div><p>Result of direct lighting calculation for one light sample.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[363]||(i[363]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L492-L496",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Zi,[s("summary",null,[i[365]||(i[365]=s("a",{id:"Hikari.PWEscapedRayWorkItem",href:"#Hikari.PWEscapedRayWorkItem"},[s("span",{class:"jlbinding"},"Hikari.PWEscapedRayWorkItem")],-1)),i[366]||(i[366]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[368]||(i[368]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWEscapedRayWorkItem</span></span></code></pre></div><p>A ray that escaped the scene (missed all geometry). Used to compute contribution from environment/infinite lights.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[367]||(i[367]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L95-L100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xi,[s("summary",null,[i[369]||(i[369]=s("a",{id:"Hikari.PWHitAreaLightWorkItem",href:"#Hikari.PWHitAreaLightWorkItem"},[s("span",{class:"jlbinding"},"Hikari.PWHitAreaLightWorkItem")],-1)),i[370]||(i[370]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[372]||(i[372]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWHitAreaLightWorkItem</span></span></code></pre></div><p>A ray that hit an emissive surface (area light). Contains info needed to compute emission contribution with MIS.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[371]||(i[371]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L129-L134",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Yi,[s("summary",null,[i[373]||(i[373]=s("a",{id:"Hikari.PWLightSample",href:"#Hikari.PWLightSample"},[s("span",{class:"jlbinding"},"Hikari.PWLightSample")],-1)),i[374]||(i[374]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[376]||(i[376]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWLightSample</span></span></code></pre></div><p>Result of sampling a light source with spectral radiance.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[375]||(i[375]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L8-L12",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Qi,[s("summary",null,[i[377]||(i[377]=s("a",{id:"Hikari.PWLightSampleContext",href:"#Hikari.PWLightSampleContext"},[s("span",{class:"jlbinding"},"Hikari.PWLightSampleContext")],-1)),i[378]||(i[378]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[380]||(i[380]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWLightSampleContext</span></span></code></pre></div><p>Context for sampling lights - position, geometric normal, shading normal. Used for MIS weight computation.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[379]||(i[379]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L32-L37",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$i,[s("summary",null,[i[381]||(i[381]=s("a",{id:"Hikari.PWMISContext",href:"#Hikari.PWMISContext"},[s("span",{class:"jlbinding"},"Hikari.PWMISContext")],-1)),i[382]||(i[382]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[384]||(i[384]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWMISContext</span></span></code></pre></div><p>Context needed for computing MIS weights between light and BSDF sampling.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[383]||(i[383]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L237-L241",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",is,[s("summary",null,[i[385]||(i[385]=s("a",{id:"Hikari.PWMaterialEvalResult",href:"#Hikari.PWMaterialEvalResult"},[s("span",{class:"jlbinding"},"Hikari.PWMaterialEvalResult")],-1)),i[386]||(i[386]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[388]||(i[388]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWMaterialEvalResult</span></span></code></pre></div><p>Result of evaluating a material for the wavefront pipeline.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[387]||(i[387]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L146-L150",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ss,[s("summary",null,[i[389]||(i[389]=s("a",{id:"Hikari.PWMaterialEvalWorkItem",href:"#Hikari.PWMaterialEvalWorkItem"},[s("span",{class:"jlbinding"},"Hikari.PWMaterialEvalWorkItem")],-1)),i[390]||(i[390]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[392]||(i[392]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWMaterialEvalWorkItem</span></span></code></pre></div><p>Work item for material/BSDF evaluation after ray intersection. Contains all intersection data needed for shading.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[391]||(i[391]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L171-L176",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",es,[s("summary",null,[i[393]||(i[393]=s("a",{id:"Hikari.PWPixelSampleState",href:"#Hikari.PWPixelSampleState"},[s("span",{class:"jlbinding"},"Hikari.PWPixelSampleState")],-1)),i[394]||(i[394]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[396]||(i[396]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWPixelSampleState</span></span></code></pre></div><p>Per-pixel state accumulated during spectral path tracing.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[395]||(i[395]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L208-L212",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ts,[s("summary",null,[i[397]||(i[397]=s("a",{id:"Hikari.PWRaySamples",href:"#Hikari.PWRaySamples"},[s("span",{class:"jlbinding"},"Hikari.PWRaySamples")],-1)),i[398]||(i[398]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[400]||(i[400]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWRaySamples</span></span></code></pre></div><p>Random samples used for direct and indirect lighting at each path vertex.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[399]||(i[399]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L9-L13",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",as,[s("summary",null,[i[401]||(i[401]=s("a",{id:"Hikari.PWRayWorkItem",href:"#Hikari.PWRayWorkItem"},[s("span",{class:"jlbinding"},"Hikari.PWRayWorkItem")],-1)),i[402]||(i[402]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[404]||(i[404]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWRayWorkItem</span></span></code></pre></div><p>A ray to be traced, along with full path state. This is the main work item flowing through the ray queue.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[403]||(i[403]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L54-L59",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ls,[s("summary",null,[i[405]||(i[405]=s("a",{id:"Hikari.PWRayWorkItem-Tuple{Raycore.Ray, Hikari.SampledWavelengths{4}, Int32}",href:"#Hikari.PWRayWorkItem-Tuple{Raycore.Ray, Hikari.SampledWavelengths{4}, Int32}"},[s("span",{class:"jlbinding"},"Hikari.PWRayWorkItem")],-1)),i[406]||(i[406]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[408]||(i[408]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PWRayWorkItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ray, lambda, pixel_index)</span></span></code></pre></div><p>Create a new camera ray work item with default path state.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[407]||(i[407]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L74-L78",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ns,[s("summary",null,[i[409]||(i[409]=s("a",{id:"Hikari.PWShadowRayWorkItem",href:"#Hikari.PWShadowRayWorkItem"},[s("span",{class:"jlbinding"},"Hikari.PWShadowRayWorkItem")],-1)),i[410]||(i[410]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[412]||(i[412]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PWShadowRayWorkItem</span></span></code></pre></div><p>A shadow ray for direct lighting visibility test.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[411]||(i[411]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L156-L160",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",rs,[s("summary",null,[i[413]||(i[413]=s("a",{id:"Hikari.PiecewiseConstant2D",href:"#Hikari.PiecewiseConstant2D"},[s("span",{class:"jlbinding"},"Hikari.PiecewiseConstant2D")],-1)),i[414]||(i[414]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[416]||(i[416]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PiecewiseConstant2D</span></span></code></pre></div><p>2D piecewise constant distribution for importance sampling. Stores a 2D function tabulated on a grid and allows efficient sampling proportional to the function values.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[415]||(i[415]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L329-L335",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ps,[s("summary",null,[i[417]||(i[417]=s("a",{id:"Hikari.PiecewiseConstant2D-Tuple{AbstractMatrix{Float32}, GeometryBasics.Point{2, Float32}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.PiecewiseConstant2D-Tuple{AbstractMatrix{Float32}, GeometryBasics.Point{2, Float32}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.PiecewiseConstant2D")],-1)),i[418]||(i[418]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[420]||(i[420]=s("p",null,"Build a PiecewiseConstant2D from a 2D function array. func[y, x] = function value at grid cell (x, y).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[419]||(i[419]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L356-L359",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",os,[s("summary",null,[i[421]||(i[421]=s("a",{id:"Hikari.PixelSample",href:"#Hikari.PixelSample"},[s("span",{class:"jlbinding"},"Hikari.PixelSample")],-1)),i[422]||(i[422]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[424]||(i[424]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PixelSample</span></span></code></pre></div><p>Holds all sample values needed for a single pixel sample in path tracing. This is a stateless struct computed deterministically from (pixel, sample_index).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[423]||(i[423]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L158-L163",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ds,[s("summary",null,[i[425]||(i[425]=s("a",{id:"Hikari.PointLight-Tuple{ColorTypes.RGB{Float32}, Any}",href:"#Hikari.PointLight-Tuple{ColorTypes.RGB{Float32}, Any}"},[s("span",{class:"jlbinding"},"Hikari.PointLight")],-1)),i[426]||(i[426]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[428]||(i[428]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PointLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, position; power</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PointLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, position; power</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a PointLight from RGB color with automatic spectral conversion and photometric normalization, matching pbrt-v4&#39;s light creation pattern.</p><p>Converts RGB to RGBIlluminantSpectrum and applies photometric normalization: <code>scale = 1 / SpectrumToPhotometric(spectrum)</code> where SpectrumToPhotometric extracts the D65 illuminant component.</p><p><strong>Arguments</strong></p><ul><li><p><code>rgb</code>: RGB color (intensity encoded in color values, e.g., RGB(50,50,50) for bright white)</p></li><li><p><code>position</code>: World-space position of the light</p></li><li><p><code>power</code>: Optional radiant power in Watts. If specified, overrides the RGB intensity.</p></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Equivalent to pbrt-v4&#39;s: LightSource &quot;point&quot; &quot;rgb I&quot; [50 50 50]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">light </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PointLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Or with Makie&#39;s RGBf:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">light </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> PointLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div>`,7)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[427]||(i[427]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/point.jl#L30-L54",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ks,[s("summary",null,[i[429]||(i[429]=s("a",{id:"Hikari.PowerLightSampler",href:"#Hikari.PowerLightSampler"},[s("span",{class:"jlbinding"},"Hikari.PowerLightSampler")],-1)),i[430]||(i[430]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[432]||(i[432]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">PowerLightSampler</span></span></code></pre></div><p>Sample lights proportional to their total power using an alias table. O(1) sampling with O(N) construction. Good for scenes with varying light intensities.</p><p>Following pbrt-v4&#39;s PowerLightSampler which uses light.Phi() to estimate power.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[431]||(i[431]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L222-L229",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",hs,[s("summary",null,[i[433]||(i[433]=s("a",{id:"Hikari.RGBAlbedoSpectrum",href:"#Hikari.RGBAlbedoSpectrum"},[s("span",{class:"jlbinding"},"Hikari.RGBAlbedoSpectrum")],-1)),i[434]||(i[434]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[436]||(i[436]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RGBAlbedoSpectrum</span></span></code></pre></div><p>Bounded [0,1] spectrum for surface reflectance/albedo.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[435]||(i[435]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L278-L282",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",us,[s("summary",null,[i[437]||(i[437]=s("a",{id:"Hikari.RGBGridMedium",href:"#Hikari.RGBGridMedium"},[s("span",{class:"jlbinding"},"Hikari.RGBGridMedium")],-1)),i[438]||(i[438]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[440]||(i[440]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RGBGridMedium</span></span></code></pre></div><p>A participating medium with spatially varying per-voxel RGB absorption and scattering coefficients. Following pbrt-v4&#39;s RGBGridMedium implementation exactly.</p><p>Key design (matching pbrt-v4):</p><ul><li><p>Optional σ_a grid: 3D array of RGBSpectrum absorption coefficients (if absent, defaults to 1.0)</p></li><li><p>Optional σ_s grid: 3D array of RGBSpectrum scattering coefficients (if absent, defaults to 1.0)</p></li><li><p>Optional Le grid: 3D array of RGBSpectrum emission coefficients (for emissive volumes)</p></li><li><p>sigma_scale: Global multiplier for σ_a and σ_s grids</p></li><li><p>Le_scale: Global multiplier for Le grid</p></li><li><p>The majorant grid stores <code>sigma_scale * max(σ_a + σ_s)</code> per coarse voxel</p></li><li><p>In SampleRay, uses unit σ_t since scaling is already in the majorant grid</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[439]||(i[439]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L987-L1001",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",gs,[s("summary",null,[i[441]||(i[441]=s("a",{id:"Hikari.RGBGridMedium-Tuple{}",href:"#Hikari.RGBGridMedium-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.RGBGridMedium")],-1)),i[442]||(i[442]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[444]||(i[444]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBGridMedium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; σ_a_grid, σ_s_grid, Le_grid, sigma_scale, Le_scale, g, bounds, transform, majorant_res)</span></span></code></pre></div><p>Create an RGBGridMedium following pbrt-v4&#39;s design exactly.</p><p>At least one of σ_a_grid or σ_s_grid must be provided. The grids contain per-voxel RGBSpectrum values that are multiplied by sigma_scale (or Le_scale for emission).</p><p><strong>Arguments</strong></p><ul><li><p><code>σ_a_grid</code>: Optional 3D array of RGBSpectrum absorption coefficients</p></li><li><p><code>σ_s_grid</code>: Optional 3D array of RGBSpectrum scattering coefficients</p></li><li><p><code>Le_grid</code>: Optional 3D array of RGBSpectrum emission coefficients (requires σ_a_grid)</p></li><li><p><code>sigma_scale</code>: Global multiplier for σ_a and σ_s grids (default: 1.0)</p></li><li><p><code>Le_scale</code>: Global multiplier for Le grid (default: 0.0)</p></li><li><p><code>g</code>: Henyey-Greenstein asymmetry parameter (default: 0.0)</p></li><li><p><code>bounds</code>: Volume bounds in medium space (default: unit cube)</p></li><li><p><code>transform</code>: Transform from medium to render space (default: identity)</p></li><li><p><code>majorant_res</code>: Resolution of the majorant grid (default: 16³)</p></li></ul>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[443]||(i[443]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1042-L1060",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",cs,[s("summary",null,[i[445]||(i[445]=s("a",{id:"Hikari.RGBIlluminantSpectrum",href:"#Hikari.RGBIlluminantSpectrum"},[s("span",{class:"jlbinding"},"Hikari.RGBIlluminantSpectrum")],-1)),i[446]||(i[446]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[448]||(i[448]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RGBIlluminantSpectrum</span></span></code></pre></div><p>Illuminant spectrum for light sources, matching pbrt-v4&#39;s RGBIlluminantSpectrum. Stores RGB coefficients and multiplies by D65 illuminant when sampled.</p><p>Fields:</p><ul><li><p><code>poly::RGBSigmoidPolynomial</code> - Sigmoid polynomial for spectral shape</p></li><li><p><code>scale::Float32</code> - Scale factor (2 * max(r,g,b) from construction)</p></li></ul><p>When sampled at wavelength λ: returns <code>scale * poly(λ) * D65(λ)</code></p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[447]||(i[447]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L319-L330",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",bs,[s("summary",null,[i[449]||(i[449]=s("a",{id:"Hikari.RGBSigmoidPolynomial",href:"#Hikari.RGBSigmoidPolynomial"},[s("span",{class:"jlbinding"},"Hikari.RGBSigmoidPolynomial")],-1)),i[450]||(i[450]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[452]||(i[452]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RGBSigmoidPolynomial</span></span></code></pre></div><p>Represents a smooth spectrum using a sigmoid-wrapped polynomial. The spectrum value at wavelength λ is: sigmoid(c0_λ² + c1_λ + c2) where sigmoid(x) = 0.5 + x / (2*sqrt(1 + x²))</p><p>This provides a smooth, bounded [0,1] spectrum from just 3 coefficients.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[451]||(i[451]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L8-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ys,[s("summary",null,[i[453]||(i[453]=s("a",{id:"Hikari.RGBSigmoidPolynomial-Tuple{Float32}",href:"#Hikari.RGBSigmoidPolynomial-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.RGBSigmoidPolynomial")],-1)),i[454]||(i[454]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[456]||(i[456]=s("p",null,"Evaluate spectrum at wavelength λ (in nm)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[455]||(i[455]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ms,[s("summary",null,[i[457]||(i[457]=s("a",{id:"Hikari.RGBToSpectrumTable",href:"#Hikari.RGBToSpectrumTable"},[s("span",{class:"jlbinding"},"Hikari.RGBToSpectrumTable")],-1)),i[458]||(i[458]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[460]||(i[460]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RGBToSpectrumTable{V1, V5}</span></span></code></pre></div><p>Precomputed lookup table for converting RGB colors to RGBSigmoidPolynomial coefficients. Uses trilinear interpolation for smooth results.</p><p>Parameterized by array types for GPU compatibility:</p><ul><li><p>V1: 1D array type for scale (AbstractVector{Float32})</p></li><li><p>V5: 5D array type for coeffs (AbstractArray{Float32, 5})</p></li></ul><p>Use <code>to_gpu(ArrayType, table)</code> to convert to GPU-compatible arrays.</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[459]||(i[459]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L59-L70",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fs,[s("summary",null,[i[461]||(i[461]=s("a",{id:"Hikari.RGBUnboundedSpectrum",href:"#Hikari.RGBUnboundedSpectrum"},[s("span",{class:"jlbinding"},"Hikari.RGBUnboundedSpectrum")],-1)),i[462]||(i[462]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[464]||(i[464]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RGBUnboundedSpectrum</span></span></code></pre></div><p>Unbounded spectrum for illumination/emission. Scales the sigmoid polynomial to match the maximum RGB component.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[463]||(i[463]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L289-L294",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Es,[s("summary",null,[i[465]||(i[465]=s("a",{id:"Hikari.RayMajorantIterator",href:"#Hikari.RayMajorantIterator"},[s("span",{class:"jlbinding"},"Hikari.RayMajorantIterator")],-1)),i[466]||(i[466]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[468]||(i[468]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RayMajorantIterator</span></span></code></pre></div><p>Unified majorant iterator that can represent either homogeneous or DDA iteration. This avoids Union types which cause GPU compilation issues.</p><p>Following pbrt-v4&#39;s RayMajorantIterator which is a TaggedPointer variant.</p><p>Mode:</p><ul><li><p>mode = 0: Invalid/exhausted iterator</p></li><li><p>mode = 1: Homogeneous mode (single segment)</p></li><li><p>mode = 2: DDA mode (voxel traversal)</p></li></ul>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[467]||(i[467]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L504-L516",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_s,[s("summary",null,[i[469]||(i[469]=s("a",{id:"Hikari.RayMajorantIterator-Tuple{M} where M<:Hikari.MajorantGrid",href:"#Hikari.RayMajorantIterator-Tuple{M} where M<:Hikari.MajorantGrid"},[s("span",{class:"jlbinding"},"Hikari.RayMajorantIterator")],-1)),i[470]||(i[470]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[472]||(i[472]=s("p",null,"Create an invalid/exhausted iterator",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[471]||(i[471]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L544",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ts,[s("summary",null,[i[473]||(i[473]=s("a",{id:"Hikari.RayMajorantIterator-Union{Tuple{Hikari.DDAMajorantIterator{M}}, Tuple{M}} where M<:Hikari.MajorantGrid",href:"#Hikari.RayMajorantIterator-Union{Tuple{Hikari.DDAMajorantIterator{M}}, Tuple{M}} where M<:Hikari.MajorantGrid"},[s("span",{class:"jlbinding"},"Hikari.RayMajorantIterator")],-1)),i[474]||(i[474]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[476]||(i[476]=s("p",null,"Create a DDA mode iterator (from DDAMajorantIterator)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[475]||(i[475]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L600",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",js,[s("summary",null,[i[477]||(i[477]=s("a",{id:"Hikari.RayMajorantIterator-Union{Tuple{M}, Tuple{Hikari.HomogeneousMajorantIterator, M}} where M<:Hikari.MajorantGrid",href:"#Hikari.RayMajorantIterator-Union{Tuple{M}, Tuple{Hikari.HomogeneousMajorantIterator, M}} where M<:Hikari.MajorantGrid"},[s("span",{class:"jlbinding"},"Hikari.RayMajorantIterator")],-1)),i[478]||(i[478]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[480]||(i[480]=s("p",null,"Create a homogeneous mode iterator (from HomogeneousMajorantIterator)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[479]||(i[479]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L581",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fs,[s("summary",null,[i[481]||(i[481]=s("a",{id:"Hikari.RayMajorantSegment",href:"#Hikari.RayMajorantSegment"},[s("span",{class:"jlbinding"},"Hikari.RayMajorantSegment")],-1)),i[482]||(i[482]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[484]||(i[484]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RayMajorantSegment</span></span></code></pre></div><p>A segment along a ray with a majorant (upper bound) extinction coefficient. Used for delta tracking in heterogeneous media.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[483]||(i[483]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L108-L113",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Cs,[s("summary",null,[i[485]||(i[485]=s("a",{id:"Hikari.SampledSpectrum",href:"#Hikari.SampledSpectrum"},[s("span",{class:"jlbinding"},"Hikari.SampledSpectrum")],-1)),i[486]||(i[486]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[488]||(i[488]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SampledSpectrum{N}</span></span></code></pre></div><p>A spectrum sampled at N wavelengths. Default is 4 for GPU efficiency (matches Float4). Used by PhysicalWavefront for spectral path tracing.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[487]||(i[487]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/spectral.jl#L4-L9",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",vs,[s("summary",null,[i[489]||(i[489]=s("a",{id:"Hikari.SampledWavelengths",href:"#Hikari.SampledWavelengths"},[s("span",{class:"jlbinding"},"Hikari.SampledWavelengths")],-1)),i[490]||(i[490]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[492]||(i[492]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SampledWavelengths{N}</span></span></code></pre></div><p>Represents N sampled wavelengths and their PDFs for hero wavelength sampling.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[491]||(i[491]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/spectral.jl#L116-L120",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Hs,[s("summary",null,[i[493]||(i[493]=s("a",{id:"Hikari.SamplerIntegrator-Tuple{Hikari.AbstractScene, Any, Any}",href:"#Hikari.SamplerIntegrator-Tuple{Hikari.AbstractScene, Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.SamplerIntegrator")],-1)),i[494]||(i[494]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[496]||(i[496]=s("p",null,"Render scene using KernelAbstractions.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[495]||(i[495]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/sampler.jl#L94-L96",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",As,[s("summary",null,[i[497]||(i[497]=s("a",{id:"Hikari.Scene-Tuple{}",href:"#Hikari.Scene-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Scene")],-1)),i[498]||(i[498]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[500]||(i[500]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Scene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">KA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CPU</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Create an empty mutable Scene for incremental construction.</p><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">scene </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Scene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene, mesh, material)           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Add geometry</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PointLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Add lights</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AmbientLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sync!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Build acceleration structure</span></span></code></pre></div>`,4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[499]||(i[499]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/scene.jl#L36-L49",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ss,[s("summary",null,[i[501]||(i[501]=s("a",{id:"Hikari.SmitsSpectralBasis",href:"#Hikari.SmitsSpectralBasis"},[s("span",{class:"jlbinding"},"Hikari.SmitsSpectralBasis")],-1)),i[502]||(i[502]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[504]||(i[504]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SmitsSpectralBasis</span></span></code></pre></div><p>Precomputed basis spectra for Smits&#39; RGB to spectrum conversion. Contains white, cyan, magenta, yellow, red, green, blue basis spectra.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[503]||(i[503]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L88-L93",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xs,[s("summary",null,[i[505]||(i[505]=s("a",{id:"Hikari.SobolRNG",href:"#Hikari.SobolRNG"},[s("span",{class:"jlbinding"},"Hikari.SobolRNG")],-1)),i[506]||(i[506]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[508]||(i[508]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SobolRNG{M}</span></span></code></pre></div><p>GPU-compatible Sobol random number generator. Holds the Sobol matrices and precomputed parameters for ZSobol sampling.</p><p>This struct can be passed directly to GPU kernels via Adapt.jl integration. All sampling state is computed on-the-fly from pixel coordinates and sample index, making it stateless and thread-safe.</p><p><strong>Fields</strong></p><ul><li><p><code>matrices::M</code>: GPU array of Sobol generator matrices (UInt32)</p></li><li><p><code>log2_spp::Int32</code>: log2 of samples per pixel</p></li><li><p><code>n_base4_digits::Int32</code>: number of base-4 digits for Morton encoding</p></li><li><p><code>seed::UInt32</code>: scrambling seed</p></li><li><p><code>width::Int32</code>: image width (for pixel coordinate recovery)</p></li></ul>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[507]||(i[507]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L335-L351",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Bs,[s("summary",null,[i[509]||(i[509]=s("a",{id:"Hikari.SobolRNG-Tuple{Any, UInt32, Integer, Integer, Integer}",href:"#Hikari.SobolRNG-Tuple{Any, UInt32, Integer, Integer, Integer}"},[s("span",{class:"jlbinding"},"Hikari.SobolRNG")],-1)),i[510]||(i[510]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[512]||(i[512]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SobolRNG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, seed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, height</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, samples_per_pixel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a SobolRNG for the given render settings. Allocates Sobol matrices on the specified backend (CPU/GPU).</p><p><strong>Arguments</strong></p><ul><li><p><code>backend</code>: KernelAbstractions backend (e.g., <code>CPU()</code>, <code>CUDABackend()</code>, <code>OpenCLBackend()</code>)</p></li><li><p><code>seed</code>: Scrambling seed for decorrelation</p></li><li><p><code>width</code>: Image width in pixels</p></li><li><p><code>height</code>: Image height in pixels</p></li><li><p><code>samples_per_pixel</code>: Number of samples per pixel</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[511]||(i[511]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L360-L372",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ds,[s("summary",null,[i[513]||(i[513]=s("a",{id:"Hikari.SpectralBSDFSample",href:"#Hikari.SpectralBSDFSample"},[s("span",{class:"jlbinding"},"Hikari.SpectralBSDFSample")],-1)),i[514]||(i[514]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[516]||(i[516]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SpectralBSDFSample</span></span></code></pre></div><p>Result of sampling a BSDF with spectral wavelengths. Used by PhysicalWavefront for spectral path tracing.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[515]||(i[515]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L12-L17",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Is,[s("summary",null,[i[517]||(i[517]=s("a",{id:"Hikari.SpotLight-Tuple{ColorTypes.RGB{Float32}, GeometryBasics.Point{3, Float32}, GeometryBasics.Point{3, Float32}, Float32, Float32}",href:"#Hikari.SpotLight-Tuple{ColorTypes.RGB{Float32}, GeometryBasics.Point{3, Float32}, GeometryBasics.Point{3, Float32}, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.SpotLight")],-1)),i[518]||(i[518]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[520]||(i[520]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpotLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, position, target, total_width, falloff_start; power</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a SpotLight from RGB color with automatic spectral conversion and photometric normalization, matching pbrt-v4&#39;s light creation pattern.</p><p><strong>Arguments</strong></p><ul><li><p><code>rgb</code>: RGB color (intensity encoded in color values)</p></li><li><p><code>position::Point3f</code>: World-space position of the spotlight</p></li><li><p><code>target::Point3f</code>: Point the spotlight is aimed at</p></li><li><p><code>total_width::Float32</code>: Total cone angle in degrees</p></li><li><p><code>falloff_start::Float32</code>: Angle where intensity falloff begins (degrees)</p></li><li><p><code>power</code>: Optional radiant power in Watts. If specified, overrides the RGB intensity.</p></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Spotlight with RGB color</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">light </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SpotLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[519]||(i[519]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/spot.jl#L58-L77",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ms,[s("summary",null,[i[521]||(i[521]=s("a",{id:"Hikari.SpotLight-Union{Tuple{S}, Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Point{3, Float32}, S, Float32, Float32}, Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Point{3, Float32}, S, Float32, Float32, Float32}} where S<:Hikari.Spectrum",href:"#Hikari.SpotLight-Union{Tuple{S}, Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Point{3, Float32}, S, Float32, Float32}, Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Point{3, Float32}, S, Float32, Float32, Float32}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.SpotLight")],-1)),i[522]||(i[522]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[524]||(i[524]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpotLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(position, target, intensity, cone_angle, falloff_angle; scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convenience constructor for SpotLight that takes position and target points.</p><p><strong>Arguments</strong></p><ul><li><p><code>position::Point3f</code>: World-space position of the spotlight</p></li><li><p><code>target::Point3f</code>: Point the spotlight is aimed at</p></li><li><p><code>i::Spectrum</code>: Light intensity/color</p></li><li><p><code>total_width::Float32</code>: Total cone angle in degrees</p></li><li><p><code>falloff_start::Float32</code>: Angle where intensity falloff begins (degrees)</p></li><li><p><code>scale::Float32</code>: Photometric scale factor (default 1.0)</p></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Spotlight at (0, 5, 0) pointing at origin with 30° cone</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">light </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SpotLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">25f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[523]||(i[523]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/spot.jl#L30-L48",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Gs,[s("summary",null,[i[525]||(i[525]=s("a",{id:"Hikari.SunLight",href:"#Hikari.SunLight"},[s("span",{class:"jlbinding"},"Hikari.SunLight")],-1)),i[526]||(i[526]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[528]||(i[528]=s("p",null,"SunLight - A directional light with additional parameters for volumetric cloud rendering.",-1)),i[529]||(i[529]=s("p",null,"Extends DirectionalLight with angular diameter and corona falloff parameters useful for rendering sun disks and atmospheric scattering in clouds.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[527]||(i[527]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/sun.jl#L1-L6",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ps,[s("summary",null,[i[530]||(i[530]=s("a",{id:"Hikari.SunLight-Tuple{ColorTypes.RGB{Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.SunLight-Tuple{ColorTypes.RGB{Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.SunLight")],-1)),i[531]||(i[531]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[533]||(i[533]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SunLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, direction; angular_diameter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.00933f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, corona_falloff</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a SunLight from RGB color with automatic spectral conversion and photometric normalization, matching pbrt-v4&#39;s light creation pattern.</p><p><strong>Arguments</strong></p><ul><li><p><code>rgb</code>: RGB color (intensity encoded in color values)</p></li><li><p><code>direction</code>: Direction the light travels (away from source)</p></li><li><p><code>angular_diameter</code>: Angular size of sun disk in radians (default ~0.53°, real sun)</p></li><li><p><code>corona_falloff</code>: How quickly corona fades around sun disk</p></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Sun light traveling in -Y direction (sunlight from above)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">light </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> SunLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB{Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[532]||(i[532]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/sun.jl#L47-L64",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Vs,[s("summary",null,[i[534]||(i[534]=s("a",{id:"Hikari.TextureFilterContext",href:"#Hikari.TextureFilterContext"},[s("span",{class:"jlbinding"},"Hikari.TextureFilterContext")],-1)),i[535]||(i[535]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[537]||(i[537]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TextureFilterContext</span></span></code></pre></div><p>Context for texture filtering, containing UV coordinates and screen-space derivatives. Following pbrt-v4&#39;s TextureEvalContext pattern.</p><p>Materials receive this context and pass it to eval_tex for proper texture filtering. The UV derivatives (dudx, dudy, dvdx, dvdy) are computed from:</p><ol><li><p>Surface partial derivatives (dpdu, dpdv) at intersection</p></li><li><p>Screen-space position derivatives (dpdx, dpdy) from camera</p></li></ol><p>These enable mipmap level selection and anisotropic filtering.</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[536]||(i[536]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/texture-ref.jl#L8-L20",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ls,[s("summary",null,[i[538]||(i[538]=s("a",{id:"Hikari.ThinDielectric",href:"#Hikari.ThinDielectric"},[s("span",{class:"jlbinding"},"Hikari.ThinDielectric")],-1)),i[539]||(i[539]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[541]||(i[541]=s("p",null,[a("Type alias: "),s("code",null,"ThinDielectric"),a(" is the same as "),s("code",null,"ThinDielectricMaterial")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[540]||(i[540]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/thin-dielectric.jl#L57",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ws,[s("summary",null,[i[542]||(i[542]=s("a",{id:"Hikari.ThinDielectricMaterial",href:"#Hikari.ThinDielectricMaterial"},[s("span",{class:"jlbinding"},"Hikari.ThinDielectricMaterial")],-1)),i[543]||(i[543]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[545]||(i[545]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ThinDielectricMaterial</span></span></code></pre></div><p>A thin dielectric material for surfaces like window glass.</p><p>Unlike regular dielectric materials which refract light according to Snell&#39;s law, thin dielectric materials transmit light straight through (wi = -wo) while accounting for multiple internal reflections within the thin layer.</p><p><strong>Fields</strong></p><ul><li><code>eta</code>: Index of refraction of the dielectric</li></ul><p><strong>Physics</strong></p><p>For a thin dielectric layer:</p><ul><li><p>Single-surface Fresnel: R₀ = FrDielectric(cos_θ, eta)</p></li><li><p>Multiple-bounce reflectance: R = R₀ + T₀²R₀/(1 - R₀²) where T₀ = 1 - R₀</p></li><li><p>Transmittance: T = 1 - R</p></li><li><p>Transmitted direction: wi = -wo (straight through, no bend)</p></li></ul><p><strong>Usage</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Thin glass window</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ThinDielectric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(eta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Thin plastic film</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">film </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ThinDielectric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(eta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,10)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[544]||(i[544]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/thin-dielectric.jl#L17-L44",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Rs,[s("summary",null,[i[546]||(i[546]=s("a",{id:"Hikari.TransformMapping3D",href:"#Hikari.TransformMapping3D"},[s("span",{class:"jlbinding"},"Hikari.TransformMapping3D")],-1)),i[547]||(i[547]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[549]||(i[549]=s("p",null,"3D mapping that takes world space coordinate of the point and applies a linear transformation to it. This will often be a transformation that takes the point back to the primitive's object space.",-1)),i[550]||(i[550]=s("p",null,"Because a linear mapping is used, the differential change in texture coordinates can be found by applying the same transformation to the partial derivatives of the position.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[548]||(i[548]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/mapping.jl#L40-L48",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ns,[s("summary",null,[i[551]||(i[551]=s("a",{id:"Hikari.TriangleFilter",href:"#Hikari.TriangleFilter"},[s("span",{class:"jlbinding"},"Hikari.TriangleFilter")],-1)),i[552]||(i[552]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[554]||(i[554]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TriangleFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><p>Triangle (tent) filter - linear falloff from center to edges. Can be importance sampled analytically with weight = 1.0.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[553]||(i[553]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L70-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Os,[s("summary",null,[i[555]||(i[555]=s("a",{id:"Hikari.TriangleMeta",href:"#Hikari.TriangleMeta"},[s("span",{class:"jlbinding"},"Hikari.TriangleMeta")],-1)),i[556]||(i[556]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[558]||(i[558]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TriangleMeta</span></span></code></pre></div><p>Per-triangle metadata baked into the TLAS.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[557]||(i[557]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/scene.jl#L6-L10",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Js,[s("summary",null,[i[559]||(i[559]=s("a",{id:"Hikari.TrowbridgeReitzDistribution",href:"#Hikari.TrowbridgeReitzDistribution"},[s("span",{class:"jlbinding"},"Hikari.TrowbridgeReitzDistribution")],-1)),i[560]||(i[560]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[562]||(i[562]=s("p",null,"Microfacet distribution function based on Gaussian distribution of microfacet slopes. Distribution has higher tails, it falls off to zero more slowly for directions far from the surface normal.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[561]||(i[561]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L6-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ws,[s("summary",null,[i[563]||(i[563]=s("a",{id:"Hikari.UVMapping2D",href:"#Hikari.UVMapping2D"},[s("span",{class:"jlbinding"},"Hikari.UVMapping2D")],-1)),i[564]||(i[564]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[566]||(i[566]=s("p",null,[a("Simplest mapping uses "),s("code",null,"(u, v)"),a(" coordinates from the "),s("code",null,"SurfaceInteraction"),a(" to compute texture coordinates and can be offset and scaled with user-supplied values in each dimension.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[565]||(i[565]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/mapping.jl#L4-L8",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Us,[s("summary",null,[i[567]||(i[567]=s("a",{id:"Hikari.UniformLightSampler",href:"#Hikari.UniformLightSampler"},[s("span",{class:"jlbinding"},"Hikari.UniformLightSampler")],-1)),i[568]||(i[568]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[570]||(i[570]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UniformLightSampler</span></span></code></pre></div><p>Simple uniform light selection. O(1) but ignores light importance. This is the baseline sampler equivalent to the current Hikari behavior.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[569]||(i[569]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L180-L185",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",qs,[s("summary",null,[i[571]||(i[571]=s("a",{id:"Hikari.VPEscapedRayWorkItem",href:"#Hikari.VPEscapedRayWorkItem"},[s("span",{class:"jlbinding"},"Hikari.VPEscapedRayWorkItem")],-1)),i[572]||(i[572]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[574]||(i[574]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VPEscapedRayWorkItem</span></span></code></pre></div><p>Ray that escaped the scene (for environment lighting).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[573]||(i[573]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/workitems.jl#L274-L278",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",zs,[s("summary",null,[i[575]||(i[575]=s("a",{id:"Hikari.VPHitSurfaceWorkItem",href:"#Hikari.VPHitSurfaceWorkItem"},[s("span",{class:"jlbinding"},"Hikari.VPHitSurfaceWorkItem")],-1)),i[576]||(i[576]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[578]||(i[578]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VPHitSurfaceWorkItem</span></span></code></pre></div><p>Intermediate work item when ray hits a surface. Used to separate intersection from material evaluation. Stores surface partial derivatives for texture filtering (pbrt-v4 style).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[577]||(i[577]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/workitems.jl#L319-L325",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ks,[s("summary",null,[i[579]||(i[579]=s("a",{id:"Hikari.VPMaterialEvalWorkItem",href:"#Hikari.VPMaterialEvalWorkItem"},[s("span",{class:"jlbinding"},"Hikari.VPMaterialEvalWorkItem")],-1)),i[580]||(i[580]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[582]||(i[582]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VPMaterialEvalWorkItem</span></span></code></pre></div><p>Surface interaction work item for VolPath. Similar to PWMaterialEvalWorkItem but includes medium transition info.</p><p>Following pbrt-v4&#39;s MaterialEvalWorkItem, stores surface partial derivatives for texture filtering. Screen-space derivatives (dudx, dudy, dvdx, dvdy) are computed on-the-fly during material evaluation using camera.Approximate_dp_dxy().</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[581]||(i[581]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/workitems.jl#L199-L208",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Zs,[s("summary",null,[i[583]||(i[583]=s("a",{id:"Hikari.VPMediumSampleWorkItem",href:"#Hikari.VPMediumSampleWorkItem"},[s("span",{class:"jlbinding"},"Hikari.VPMediumSampleWorkItem")],-1)),i[584]||(i[584]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[586]||(i[586]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VPMediumSampleWorkItem</span></span></code></pre></div><p>Work item for rays in medium that need delta tracking. Follows pbrt-v4&#39;s approach: intersection is found FIRST, then delta tracking runs with the known t_max distance.</p><p>If the ray reaches t_max without scattering/absorption, it processes the surface hit normally. This allows proper bounded medium traversal.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[585]||(i[585]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/workitems.jl#L81-L90",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xs,[s("summary",null,[i[587]||(i[587]=s("a",{id:"Hikari.VPMediumScatterWorkItem",href:"#Hikari.VPMediumScatterWorkItem"},[s("span",{class:"jlbinding"},"Hikari.VPMediumScatterWorkItem")],-1)),i[588]||(i[588]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[590]||(i[590]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VPMediumScatterWorkItem</span></span></code></pre></div><p>Work item for a real scattering event in a participating medium. Created when delta tracking samples a real scatter (not null scatter).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[589]||(i[589]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/workitems.jl#L176-L181",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ys,[s("summary",null,[i[591]||(i[591]=s("a",{id:"Hikari.VPRaySamples",href:"#Hikari.VPRaySamples"},[s("span",{class:"jlbinding"},"Hikari.VPRaySamples")],-1)),i[592]||(i[592]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[594]||(i[594]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VPRaySamples</span></span></code></pre></div><p>Pre-computed Sobol samples for a single bounce, matching pbrt-v4&#39;s RaySamples. These are generated once per bounce and stored in PixelSampleState.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[593]||(i[593]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/workitems.jl#L8-L13",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Qs,[s("summary",null,[i[595]||(i[595]=s("a",{id:"Hikari.VPRayWorkItem",href:"#Hikari.VPRayWorkItem"},[s("span",{class:"jlbinding"},"Hikari.VPRayWorkItem")],-1)),i[596]||(i[596]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[598]||(i[598]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VPRayWorkItem</span></span></code></pre></div><p>Ray work item for volumetric path tracing. Includes medium index to track which medium the ray is currently in.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[597]||(i[597]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/workitems.jl#L32-L37",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$s,[s("summary",null,[i[599]||(i[599]=s("a",{id:"Hikari.VPShadowRayWorkItem",href:"#Hikari.VPShadowRayWorkItem"},[s("span",{class:"jlbinding"},"Hikari.VPShadowRayWorkItem")],-1)),i[600]||(i[600]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[602]||(i[602]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VPShadowRayWorkItem</span></span></code></pre></div><p>Shadow ray for direct lighting (works for both surface and volume scattering).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[601]||(i[601]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/workitems.jl#L254-L258",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ie,[s("summary",null,[i[603]||(i[603]=s("a",{id:"Hikari.VolPath",href:"#Hikari.VolPath"},[s("span",{class:"jlbinding"},"Hikari.VolPath")],-1)),i[604]||(i[604]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[606]||(i[606]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VolPath </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Integrator</span></span></code></pre></div><p>Volumetric path tracer using hero wavelength sampling and wavefront architecture.</p><p>Extends path tracing with support for participating media (fog, smoke, clouds). Uses delta tracking with null scattering for efficient medium traversal.</p><p>The main loop follows pbrt-v4&#39;s structure:</p><ol><li>If ray is in medium: run delta tracking</li></ol><ul><li><p>Absorption → terminate</p></li><li><p>Real scatter → sample direct light + phase function → continue</p></li><li><p>Null scatter → continue tracking</p></li><li><p>Escape medium → proceed to intersection</p></li></ul><ol start="2"><li><p>Intersect with scene</p></li><li><p>Handle surface (emission + BSDF) or environment light</p></li></ol>',7)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[605]||(i[605]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath.jl#L12-L28",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",se,[s("summary",null,[i[607]||(i[607]=s("a",{id:"Hikari.VolPath-Tuple{Hikari.AbstractScene, Hikari.Film, Hikari.Camera}",href:"#Hikari.VolPath-Tuple{Hikari.AbstractScene, Hikari.Film, Hikari.Camera}"},[s("span",{class:"jlbinding"},"Hikari.VolPath")],-1)),i[608]||(i[608]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[610]||(i[610]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VolPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)(scene, film, camera)</span></span></code></pre></div><p>Render using volumetric spectral wavefront path tracing.</p><p>Media are automatically extracted from <code>MediumInterface</code> materials during scene construction and stored in <code>scene.media</code>.</p><p>The render loop follows pbrt-v4&#39;s VolPathIntegrator:</p><ol><li><p>Generate camera rays (possibly in a medium)</p></li><li><p>For each bounce: a. Delta tracking for rays in media → scatter or pass through b. Trace rays to find intersections c. Handle escaped rays (environment light) d. Handle surface hits (emission + direct lighting + BSDF sampling)</p></li><li><p>Accumulate spectral samples to RGB</p></li></ol>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[609]||(i[609]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath.jl#L647-L663",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ee,[s("summary",null,[i[611]||(i[611]=s("a",{id:"Hikari.VolPath-Tuple{}",href:"#Hikari.VolPath-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.VolPath")],-1)),i[612]||(i[612]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[614]||(i[614]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VolPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; max_depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, samples</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, russian_roulette_depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, regularize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        material_coherence</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:none</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, max_component_value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, filter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GaussianFilter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        accumulation_eltype</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Float32)</span></span></code></pre></div><p>Create a VolPath integrator for volumetric path tracing.</p><p><strong>Arguments</strong></p><ul><li><p><code>max_depth</code>: Maximum path depth</p></li><li><p><code>samples</code>: Number of samples per pixel</p></li><li><p><code>russian_roulette_depth</code>: Depth at which to start Russian roulette</p></li><li><p><code>regularize</code>: Apply BSDF regularization to reduce fireflies (default: true). When enabled, near-specular BSDFs are roughened after the first non-specular bounce, following pbrt-v4&#39;s approach.</p></li><li><p><code>material_coherence</code>: Material evaluation strategy for GPU coherence (default: :none):</p><ul><li><p><code>:none</code>: Standard evaluation (baseline)</p></li><li><p><code>:sorted</code>: Sort work items by material type before evaluation</p></li><li><p><code>:per_type</code>: Launch separate kernels per material type (pbrt-v4 style)</p></li></ul></li><li><p><code>max_component_value</code>: Maximum RGB component value before clamping (default: 10). When set to a finite value, RGB values are scaled down if any component exceeds this. This is pbrt-v4&#39;s firefly suppression mechanism. Try values like 10.0 or 100.0.</p></li><li><p><code>filter</code>: Pixel reconstruction filter (default: GaussianFilter with radius 1.5, sigma 0.5). Supports BoxFilter, TriangleFilter, GaussianFilter, MitchellFilter, LanczosSincFilter. All filters use importance sampling with weight≈1 (pbrt-v4 compatible).</p></li><li><p><code>accumulation_eltype</code>: Element type for RGB/weight accumulators (default: Float32). Use Float64 on backends that support double precision for higher accumulation precision.</p></li></ul><p>Note: Sensor simulation (ISO, exposure_time, white_balance) is handled in postprocessing via <code>FilmSensor</code>, not in the integrator. This matches pbrt-v4&#39;s architecture where the film stores raw linear HDR values and sensor conversion happens at output time.</p>`,5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[613]||(i[613]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath.jl#L44-L74",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",te,[s("summary",null,[i[615]||(i[615]=s("a",{id:"Hikari.VolPathState",href:"#Hikari.VolPathState"},[s("span",{class:"jlbinding"},"Hikari.VolPathState")],-1)),i[616]||(i[616]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[618]||(i[618]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VolPathState</span></span></code></pre></div><p>Contains all work queues and buffers for VolPath wavefront rendering.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[617]||(i[617]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath-state.jl#L24-L28",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ae,[s("summary",null,[i[619]||(i[619]=s("a",{id:"Hikari.WorkQueue",href:"#Hikari.WorkQueue"},[s("span",{class:"jlbinding"},"Hikari.WorkQueue")],-1)),i[620]||(i[620]=a()),t(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[622]||(i[622]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WorkQueue{T, V, S}</span></span></code></pre></div><p>A GPU-compatible work queue that stores items of type T. Uses atomic operations for thread-safe push operations.</p><p>The queue stores items in a pre-allocated buffer and uses an atomic counter to track the current size. Supports both AOS and SOA layouts.</p><p><strong>Fields</strong></p><ul><li><p><code>items::V</code>: Pre-allocated array of work items</p></li><li><p><code>size::S</code>: Single-element array for atomic counter</p></li><li><p><code>capacity::Int32</code>: Maximum number of items</p></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create a queue on GPU backend</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">queue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> WorkQueue{MyWorkItem}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># In a kernel, push items atomically</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">idx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> push!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(queue, item)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Check if push succeeded (within capacity)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> idx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(queue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">items)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # item was stored at queue.items[idx]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div>`,7)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[621]||(i[621]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/workqueue.jl#L53-L80",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",le,[s("summary",null,[i[623]||(i[623]=s("a",{id:"Hikari.WorkQueue-Union{Tuple{T}, Tuple{Any, Integer}} where T",href:"#Hikari.WorkQueue-Union{Tuple{T}, Tuple{Any, Integer}} where T"},[s("span",{class:"jlbinding"},"Hikari.WorkQueue")],-1)),i[624]||(i[624]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[626]||(i[626]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WorkQueue{T}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, capacity; soa</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a new work queue with the given capacity on the specified backend.</p><p><strong>Arguments</strong></p><ul><li><p><code>backend</code>: KernelAbstractions backend (e.g., <code>CPU()</code>, <code>CUDABackend()</code>, <code>ROCBackend()</code>)</p></li><li><p><code>capacity</code>: Maximum number of items the queue can hold</p></li><li><p><code>soa</code>: If true, use Structure-of-Arrays layout for better GPU memory coalescing</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[625]||(i[625]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/workqueue.jl#L87-L96",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ne,[s("summary",null,[i[627]||(i[627]=s("a",{id:"Adapt.adapt_structure-Tuple{Any, Hikari.GPUFilterSamplerData}",href:"#Adapt.adapt_structure-Tuple{Any, Hikari.GPUFilterSamplerData}"},[s("span",{class:"jlbinding"},"Adapt.adapt_structure")],-1)),i[628]||(i[628]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[630]||(i[630]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Adapt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">adapt_structure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(to, data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GPUFilterSamplerData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Adapt GPUFilterSamplerData for use inside GPU kernels. This converts the GPU arrays (e.g., ROCArray) to device-compatible representations (e.g., ROCDeviceArray) that can be used inside kernels.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[629]||(i[629]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L1043-L1049",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",re,[s("summary",null,[i[631]||(i[631]=s("a",{id:"Adapt.adapt_structure-Tuple{Any, Hikari.WorkQueue}",href:"#Adapt.adapt_structure-Tuple{Any, Hikari.WorkQueue}"},[s("span",{class:"jlbinding"},"Adapt.adapt_structure")],-1)),i[632]||(i[632]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[634]||(i[634]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Adapt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">adapt_structure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, queue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WorkQueue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Adapt WorkQueue for use inside GPU kernels. This converts the host-side arrays (e.g., CLArray, CuArray) to device-compatible representations (e.g., CLDeviceArray, CuDeviceArray) that can be used inside kernels.</p><p>This allows passing the entire WorkQueue to a kernel instead of passing items and size arrays separately.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[633]||(i[633]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/workqueue.jl#L147-L156",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",pe,[s("summary",null,[i[635]||(i[635]=s("a",{id:"Base.close-Tuple{Hikari.FastWavefront}",href:"#Base.close-Tuple{Hikari.FastWavefront}"},[s("span",{class:"jlbinding"},"Base.close")],-1)),i[636]||(i[636]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[638]||(i[638]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(integrator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FastWavefront</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Release GPU resources. Alias for cleanup!().</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[637]||(i[637]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/fast-wavefront.jl#L764-L768",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",oe,[s("summary",null,[i[639]||(i[639]=s("a",{id:"Base.map-Tuple{Hikari.UVMapping2D, Hikari.SurfaceInteraction}",href:"#Base.map-Tuple{Hikari.UVMapping2D, Hikari.SurfaceInteraction}"},[s("span",{class:"jlbinding"},"Base.map")],-1)),i[640]||(i[640]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[642]||(i[642]=n('<p>Given surface interaction <code>si</code> at the shading point, return <code>(s, t)</code> texture coordinates and estimated changes in <code>(s, t)</code> w.r.t. pixel <code>x</code> &amp; <code>y</code> coordinates.</p><p><strong>Paramters:</strong></p><ul><li><p><code>m::UVMapping2D</code>: UVMapping with offset &amp; scale parameters.</p></li><li><p><code>si::SurfaceInteraction</code>: SurfaceInteraction at the shading point.</p></li></ul><p><strong>Returns:</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`Tuple{Point2f, Vec2f, Vec2f}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Texture coordinates at the shading point, estimated changes</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `(s, t)`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t. pixel </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`x`</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `y`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> coordinates.</span></span></code></pre></div>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[641]||(i[641]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/mapping.jl#L16-L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",de,[s("summary",null,[i[643]||(i[643]=s("a",{id:"Base.union-Tuple{Hikari.DirectionCone, Hikari.DirectionCone}",href:"#Base.union-Tuple{Hikari.DirectionCone, Hikari.DirectionCone}"},[s("span",{class:"jlbinding"},"Base.union")],-1)),i[644]||(i[644]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[646]||(i[646]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">union</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DirectionCone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DirectionCone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DirectionCone</span></span></code></pre></div><p>Find the minimal cone containing both input cones. Following pbrt-v4 (vecmath.cpp:56-83).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[645]||(i[645]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-bounds.jl#L52-L57",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ke,[s("summary",null,[i[647]||(i[647]=s("a",{id:"Base.union-Tuple{Hikari.LightBounds, Hikari.LightBounds}",href:"#Base.union-Tuple{Hikari.LightBounds, Hikari.LightBounds}"},[s("span",{class:"jlbinding"},"Base.union")],-1)),i[648]||(i[648]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[650]||(i[650]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">union</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LightBounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LightBounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LightBounds</span></span></code></pre></div><p>Merge two LightBounds. Following pbrt-v4 (lights.h:137-153).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[649]||(i[649]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-bounds.jl#L137-L141",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",he,[s("summary",null,[i[651]||(i[651]=s("a",{id:"Hikari.Aluminum-Tuple{}",href:"#Hikari.Aluminum-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Aluminum")],-1)),i[652]||(i[652]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[654]||(i[654]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Aluminum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), remap_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create an aluminum conductor material with measured spectral IOR data.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Aluminum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Polished aluminum</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Aluminum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Brushed aluminum</span></span></code></pre></div>`,4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[653]||(i[653]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L500-L510",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ue,[s("summary",null,[i[655]||(i[655]=s("a",{id:"Hikari.Brass-Tuple{}",href:"#Hikari.Brass-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Brass")],-1)),i[656]||(i[656]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[658]||(i[658]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Brass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), remap_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a brass (CuZn) conductor material with measured spectral IOR data.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Brass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Polished brass</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Brass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.15</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Brushed brass</span></span></code></pre></div>`,4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[657]||(i[657]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L514-L524",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ge,[s("summary",null,[i[659]||(i[659]=s("a",{id:"Hikari.Coffee-Tuple{}",href:"#Hikari.Coffee-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Coffee")],-1)),i[660]||(i[660]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[662]||(i[662]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Coffee</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HomogeneousMedium</span></span></code></pre></div><p>Create an espresso coffee medium with realistic scattering properties.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Coffee</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Espresso</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Coffee</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Diluted coffee (americano-like)</span></span></code></pre></div>`,4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[661]||(i[661]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1994-L2004",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ce,[s("summary",null,[i[663]||(i[663]=s("a",{id:"Hikari.Copper-Tuple{}",href:"#Hikari.Copper-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Copper")],-1)),i[664]||(i[664]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[666]||(i[666]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Copper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), remap_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a copper conductor material with measured spectral IOR data.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Copper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Polished copper</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Copper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Weathered copper</span></span></code></pre></div>`,4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[665]||(i[665]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L486-L496",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",be,[s("summary",null,[i[667]||(i[667]=s("a",{id:"Hikari.D-Tuple{Hikari.TrowbridgeReitzDistribution, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.D-Tuple{Hikari.TrowbridgeReitzDistribution, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.D")],-1)),i[668]||(i[668]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[670]||(i[670]=s("p",null,[a("Distribution function, which gives the differential area of microfacets with the surface normal "),s("code",null,"w"),a(".")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[669]||(i[669]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/microfacet.jl#L109-L112",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ye,[s("summary",null,[i[671]||(i[671]=s("a",{id:"Hikari.Filter-Tuple{Symbol}",href:"#Hikari.Filter-Tuple{Symbol}"},[s("span",{class:"jlbinding"},"Hikari.Filter")],-1)),i[672]||(i[672]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[674]||(i[674]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a filter by type name.</p><p><strong>Arguments</strong></p><ul><li><p><code>type</code>: One of :box, :triangle, :gaussian, :mitchell, :lanczos</p></li><li><p><code>kwargs</code>: Filter-specific parameters</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)                          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Default box filter</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:triangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Triangle with custom radius</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:gaussian</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sigma</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Gaussian filter</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:mitchell</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, C</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Mitchell filter</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:lanczos</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tau</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)               </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Lanczos sinc filter</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[673]||(i[673]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L996-L1013",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",me,[s("summary",null,[i[675]||(i[675]=s("a",{id:"Hikari.Fog-Tuple{}",href:"#Hikari.Fog-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Fog")],-1)),i[676]||(i[676]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[678]||(i[678]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Fog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; density</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HomogeneousMedium</span></span></code></pre></div><p>Create a fog medium. Fog is very light, highly scattering, and nearly non-absorbing (appears white).</p><p><strong>Arguments</strong></p><ul><li><p><code>density</code>: Fog density (lower = more transparent)</p></li><li><p><code>g</code>: Henyey-Greenstein asymmetry (0 = isotropic, typical for fog)</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Fog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Light fog</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Fog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(density</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Dense fog</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[677]||(i[677]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1909-L1924",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fe,[s("summary",null,[i[679]||(i[679]=s("a",{id:"Hikari.Gold-Tuple{}",href:"#Hikari.Gold-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Gold")],-1)),i[680]||(i[680]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[682]||(i[682]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Gold</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), remap_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a gold conductor material with measured spectral IOR data.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Gold</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Polished gold</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Gold</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Brushed gold</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Gold</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Matte gold</span></span></code></pre></div>`,4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[681]||(i[681]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L457-L468",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ee,[s("summary",null,[i[683]||(i[683]=s("a",{id:"Hikari.Juice-Tuple{Symbol}",href:"#Hikari.Juice-Tuple{Symbol}"},[s("span",{class:"jlbinding"},"Hikari.Juice")],-1)),i[684]||(i[684]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[686]||(i[686]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Juice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HomogeneousMedium</span></span></code></pre></div><p>Create a juice medium from presets.</p><p><strong>Available names</strong></p><ul><li><code>:apple</code>, <code>:cranberry</code>, <code>:grape</code>, <code>:grapefruit</code></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Juice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:apple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Apple juice</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Juice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:grape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Diluted grape juice</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[685]||(i[685]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1932-L1945",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_e,[s("summary",null,[i[687]||(i[687]=s("a",{id:"Hikari.Milk-Tuple{}",href:"#Hikari.Milk-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Milk")],-1)),i[688]||(i[688]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[690]||(i[690]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Milk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HomogeneousMedium</span></span></code></pre></div><p>Create a whole milk medium with realistic scattering properties. The <code>scale</code> parameter allows adjusting the density (for diluted milk use scale &lt; 1).</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Milk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Standard whole milk</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Milk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Diluted milk</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Milk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Forward-scattering milk</span></span></code></pre></div>`,4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[689]||(i[689]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1860-L1872",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Te,[s("summary",null,[i[691]||(i[691]=s("a",{id:"Hikari.Plastic",href:"#Hikari.Plastic"},[s("span",{class:"jlbinding"},"Hikari.Plastic")],-1)),i[692]||(i[692]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[694]||(i[694]=s("p",null,[a("Type alias: "),s("code",null,"Plastic"),a(" is the same as "),s("code",null,"PlasticMaterial")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[693]||(i[693]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L441",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",je,[s("summary",null,[i[695]||(i[695]=s("a",{id:"Hikari.PlasticMaterial-Tuple{}",href:"#Hikari.PlasticMaterial-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.PlasticMaterial")],-1)),i[696]||(i[696]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[698]||(i[698]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PlasticMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), Ks</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, remap_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, eta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a plastic material with diffuse base and dielectric coating.</p><p>This is an alias for <code>CoatedDiffuseMaterial</code> matching pbrt-v4&#39;s behavior where &quot;plastic&quot; materials are implemented as coated diffuse with a dielectric coating.</p><p><strong>Arguments</strong></p><ul><li><p><code>Kd</code>: Diffuse color (reflectance of the base layer)</p></li><li><p><code>Ks</code>: Specular color (ignored - kept for API compatibility, Fresnel controls specular)</p></li><li><p><code>roughness</code>: Surface roughness of the coating (lower = sharper highlights)</p></li><li><p><code>remap_roughness</code>: Whether to remap roughness to microfacet alpha</p></li><li><p><code>eta</code>: Index of refraction of the coating (default 1.5 for typical plastic)</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PlasticMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))           </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Magenta plastic</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PlasticMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Shiny blue</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PlasticMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Kd</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">wood_texture, roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Textured</span></span></code></pre></div>`,7)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[697]||(i[697]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L319-L340",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fe,[s("summary",null,[i[699]||(i[699]=s("a",{id:"Hikari.RayMajorantIterator_homogeneous-Tuple{Float32, Float32, Hikari.SampledSpectrum{4}}",href:"#Hikari.RayMajorantIterator_homogeneous-Tuple{Float32, Float32, Hikari.SampledSpectrum{4}}"},[s("span",{class:"jlbinding"},"Hikari.RayMajorantIterator_homogeneous")],-1)),i[700]||(i[700]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[702]||(i[702]=s("p",null,"Create a homogeneous mode iterator directly (for HomogeneousMedium)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[701]||(i[701]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L562",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ce,[s("summary",null,[i[703]||(i[703]=s("a",{id:"Hikari.Sample-Tuple{Hikari.RGBIlluminantSpectrum, Hikari.SampledWavelengths{4}}",href:"#Hikari.Sample-Tuple{Hikari.RGBIlluminantSpectrum, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.Sample")],-1)),i[704]||(i[704]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[706]||(i[706]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBIlluminantSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Sample the illuminant spectrum at multiple wavelengths. Matches pbrt-v4&#39;s RGBIlluminantSpectrum::Sample(const SampledWavelengths &amp;lambda).</p><p>Returns: scale * rsp(λ) * D65(λ) for each wavelength.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[705]||(i[705]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L481-L488",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ve,[s("summary",null,[i[707]||(i[707]=s("a",{id:"Hikari.Sample-Tuple{Hikari.RGBToSpectrumTable, Hikari.RGBIlluminantSpectrum, Hikari.SampledWavelengths{4}}",href:"#Hikari.Sample-Tuple{Hikari.RGBToSpectrumTable, Hikari.RGBIlluminantSpectrum, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.Sample")],-1)),i[708]||(i[708]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[710]||(i[710]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBIlluminantSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Sample an RGBIlluminantSpectrum at multiple wavelengths. The table argument is ignored since the polynomial is already baked in.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[709]||(i[709]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L581-L586",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",He,[s("summary",null,[i[711]||(i[711]=s("a",{id:"Hikari.Sample-Tuple{Hikari.RGBToSpectrumTable, Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}",href:"#Hikari.Sample-Tuple{Hikari.RGBToSpectrumTable, Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.Sample")],-1)),i[712]||(i[712]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[714]||(i[714]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Sample an RGBSpectrum as an illuminant at multiple wavelengths. This provides a unified interface for light sampling - RGBSpectrum uses uplift_rgb_illuminant while RGBIlluminantSpectrum uses its baked-in polynomial.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[713]||(i[713]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L568-L574",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ae,[s("summary",null,[i[715]||(i[715]=s("a",{id:"Hikari.Silver-Tuple{}",href:"#Hikari.Silver-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Silver")],-1)),i[716]||(i[716]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[718]||(i[718]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Silver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, reflectance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), remap_roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a silver conductor material with measured spectral IOR data.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Silver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Polished silver</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Silver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.05</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Slightly brushed</span></span></code></pre></div>`,4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[717]||(i[717]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L472-L482",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Se,[s("summary",null,[i[719]||(i[719]=s("a",{id:"Hikari.Smoke-Tuple{}",href:"#Hikari.Smoke-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.Smoke")],-1)),i[720]||(i[720]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[722]||(i[722]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Smoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; density</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, albedo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HomogeneousMedium</span></span></code></pre></div><p>Create a smoke/fog medium. Smoke is characterized by high scattering and low absorption (high albedo = scattering / extinction).</p><p><strong>Arguments</strong></p><ul><li><p><code>density</code>: Overall density multiplier (higher = thicker smoke)</p></li><li><p><code>albedo</code>: Single-scattering albedo (0-1, higher = more scattering, whiter smoke)</p></li><li><p><code>g</code>: Henyey-Greenstein asymmetry parameter (-1 to 1, 0 = isotropic)</p></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Smoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()                   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Light gray smoke</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Smoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(density</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Dense smoke</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Smoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(albedo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Darker, more absorbing smoke</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Smoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)              </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Forward-scattering (typical for smoke)</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[721]||(i[721]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1880-L1898",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xe,[s("summary",null,[i[723]||(i[723]=s("a",{id:"Hikari.SubsurfaceMedium-Tuple{String}",href:"#Hikari.SubsurfaceMedium-Tuple{String}"},[s("span",{class:"jlbinding"},"Hikari.SubsurfaceMedium")],-1)),i[724]||(i[724]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[726]||(i[726]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubsurfaceMedium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HomogeneousMedium</span></span></code></pre></div><p>Create a medium from any of the available presets by name.</p><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubsurfaceMedium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Marble&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubsurfaceMedium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Skin1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SubsurfaceMedium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Ketchup&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>See <code>get_medium_preset</code> for available preset names.</p>`,5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[725]||(i[725]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L2012-L2025",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Be,[s("summary",null,[i[727]||(i[727]=s("a",{id:"Hikari.Wine-Tuple{Symbol}",href:"#Hikari.Wine-Tuple{Symbol}"},[s("span",{class:"jlbinding"},"Hikari.Wine")],-1)),i[728]||(i[728]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[730]||(i[730]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HomogeneousMedium</span></span></code></pre></div><p>Create a wine medium from presets.</p><p><strong>Available names</strong></p><ul><li><code>:chardonnay</code>, <code>:zinfandel</code>, <code>:merlot</code></li></ul><p><strong>Examples</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:merlot</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)             </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Red merlot wine</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:chardonnay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># White wine</span></span></code></pre></div>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[729]||(i[729]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1964-L1977",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",De,[s("summary",null,[i[731]||(i[731]=s("a",{id:"Hikari._accumulate_volume_scatter-Tuple{Hikari.RGBSpectrum, Any, Hikari.CloudVolume, Vararg{Any, 5}}",href:"#Hikari._accumulate_volume_scatter-Tuple{Hikari.RGBSpectrum, Any, Hikari.CloudVolume, Vararg{Any, 5}}"},[s("span",{class:"jlbinding"},"Hikari._accumulate_volume_scatter")],-1)),i[732]||(i[732]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[734]||(i[734]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_accumulate_volume_scatter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(acc, light, cloud, pos, ray_d, time, shadow_steps, scene)</span></span></code></pre></div><p>Accumulator function for reduce_unrolled over lights in volume scattering. Computes single light contribution and adds to accumulator.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[733]||(i[733]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L222-L227",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ie,[s("summary",null,[i[735]||(i[735]=s("a",{id:"Hikari._build_bvh!-Tuple{Vector{Hikari.LightBVHNode}, Vector{UInt32}, Vector{Tuple{Int32, Hikari.LightBounds}}, Int64, Int64, UInt32, Int64}",href:"#Hikari._build_bvh!-Tuple{Vector{Hikari.LightBVHNode}, Vector{UInt32}, Vector{Tuple{Int32, Hikari.LightBounds}}, Int64, Int64, UInt32, Int64}"},[s("span",{class:"jlbinding"},"Hikari._build_bvh!")],-1)),i[736]||(i[736]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[738]||(i[738]=s("p",null,"Recursive BVH construction with SAH splitting. Following pbrt-v4 buildBVH (lightsamplers.cpp:135-238).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[737]||(i[737]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/bvh-light-sampler.jl#L335-L337",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Me,[s("summary",null,[i[739]||(i[739]=s("a",{id:"Hikari._copy_multi_to_standard!-Union{Tuple{N}, Tuple{Any, Hikari.VolPathState, Hikari.MultiMaterialQueue{N}}} where N",href:"#Hikari._copy_multi_to_standard!-Union{Tuple{N}, Tuple{Any, Hikari.VolPathState, Hikari.MultiMaterialQueue{N}}} where N"},[s("span",{class:"jlbinding"},"Hikari._copy_multi_to_standard!")],-1)),i[740]||(i[740]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[742]||(i[742]=s("p",null,"DEBUG helper: Copy items from multi_queue to standard material_queue for testing.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[741]||(i[741]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/multi-material-eval.jl#L291-L293",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ge,[s("summary",null,[i[743]||(i[743]=s("a",{id:"Hikari._detect_camera_medium_kernel!-Tuple{Any}",href:"#Hikari._detect_camera_medium_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari._detect_camera_medium_kernel!")],-1)),i[744]||(i[744]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[746]||(i[746]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_detect_camera_medium_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(result, accel, media_interfaces, camera_pos)</span></span></code></pre></div><p>Single-workitem kernel that traces a ray from the camera position to determine which medium the camera is inside. Writes a SetKey to result[1].</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[745]||(i[745]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L684-L689",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Pe,[s("summary",null,[i[747]||(i[747]=s("a",{id:"Hikari._evaluate_cost-Tuple{Hikari.LightBounds, Raycore.Bounds3, Int64}",href:"#Hikari._evaluate_cost-Tuple{Hikari.LightBounds, Raycore.Bounds3, Int64}"},[s("span",{class:"jlbinding"},"Hikari._evaluate_cost")],-1)),i[748]||(i[748]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[750]||(i[750]=s("p",null,[a("SAH cost for splitting a LightBounds along dimension "),s("code",null,"dim"),a(". Following pbrt-v4 EvaluateCost (lightsamplers.h:383-396).")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[749]||(i[749]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/bvh-light-sampler.jl#L240-L242",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ve,[s("summary",null,[i[751]||(i[751]=s("a",{id:"Hikari._evaluate_typed_material!-Tuple{Any, Hikari.VPMaterialEvalWorkItem, Any, Any, Any, Int32, Bool, Any, Any, Any, Any, Int32}",href:"#Hikari._evaluate_typed_material!-Tuple{Any, Hikari.VPMaterialEvalWorkItem, Any, Any, Any, Int32, Bool, Any, Any, Any, Any, Int32}"},[s("span",{class:"jlbinding"},"Hikari._evaluate_typed_material!")],-1)),i[752]||(i[752]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[754]||(i[754]=s("p",null,"Inner evaluation for a typed material (no dispatch needed).",-1)),i[755]||(i[755]=s("p",null,"Uses pre-computed Sobol samples from pixel_samples (pbrt-v4 RaySamples style).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[753]||(i[753]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/multi-material-eval.jl#L192-L196",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Le,[s("summary",null,[i[756]||(i[756]=s("a",{id:"Hikari._get_rgb2spec_table-Tuple{}",href:"#Hikari._get_rgb2spec_table-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari._get_rgb2spec_table")],-1)),i[757]||(i[757]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[759]||(i[759]=s("p",null,"Get the global sRGB to spectrum table (loads on first access)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[758]||(i[758]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L228",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",we,[s("summary",null,[i[760]||(i[760]=s("a",{id:"Hikari._ratio_tracking_dda-Tuple{Hikari.RayMajorantIterator, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Any, Raycore.SetKey, Any, Hikari.SampledWavelengths{4}}",href:"#Hikari._ratio_tracking_dda-Tuple{Hikari.RayMajorantIterator, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Any, Raycore.SetKey, Any, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari._ratio_tracking_dda")],-1)),i[761]||(i[761]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[763]||(i[763]=s("p",null,"Ratio tracking using DDA majorant iterator segments. Iterates over per-voxel majorant bounds, doing ratio tracking within each segment.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[762]||(i[762]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L442-L445",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Re,[s("summary",null,[i[764]||(i[764]=s("a",{id:"Hikari._ray_majorant_next_dda-Union{Tuple{M}, Tuple{Hikari.RayMajorantIterator{M}, Any}} where M",href:"#Hikari._ray_majorant_next_dda-Union{Tuple{M}, Tuple{Hikari.RayMajorantIterator{M}, Any}} where M"},[s("span",{class:"jlbinding"},"Hikari._ray_majorant_next_dda")],-1)),i[765]||(i[765]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[767]||(i[767]=s("p",null,"DDA next implementation (separated for clarity)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[766]||(i[766]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L654",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ne,[s("summary",null,[i[768]||(i[768]=s("a",{id:"Hikari._sample_rgb_grid-Tuple{AbstractArray{Hikari.RGBSpectrum, 3}, GeometryBasics.Vec3{Int32}, GeometryBasics.Point{3, Float32}}",href:"#Hikari._sample_rgb_grid-Tuple{AbstractArray{Hikari.RGBSpectrum, 3}, GeometryBasics.Vec3{Int32}, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari._sample_rgb_grid")],-1)),i[769]||(i[769]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[771]||(i[771]=s("p",null,"Trilinear interpolation for RGB grid. p_norm is in [0,1]³ normalized coordinates within bounds.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[770]||(i[770]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1275-L1278",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Oe,[s("summary",null,[i[772]||(i[772]=s("a",{id:"Hikari._sample_texture_bilinear-Union{Tuple{T}, Tuple{AbstractMatrix{T}, GeometryBasics.Point{2, Float32}}} where T",href:"#Hikari._sample_texture_bilinear-Union{Tuple{T}, Tuple{AbstractMatrix{T}, GeometryBasics.Point{2, Float32}}} where T"},[s("span",{class:"jlbinding"},"Hikari._sample_texture_bilinear")],-1)),i[773]||(i[773]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[775]||(i[775]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_sample_texture_bilinear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, uv) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span></span></code></pre></div><p>Bilinear texture sampling for 2D textures. Provides smoother results than point sampling.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[774]||(i[774]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/texture-ref.jl#L145-L150",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Je,[s("summary",null,[i[776]||(i[776]=s("a",{id:"Hikari._sample_texture_data_filtered-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, GeometryBasics.Point{2, Float32}, Vararg{Float32, 4}}} where {T, N}",href:"#Hikari._sample_texture_data_filtered-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, GeometryBasics.Point{2, Float32}, Vararg{Float32, 4}}} where {T, N}"},[s("span",{class:"jlbinding"},"Hikari._sample_texture_data_filtered")],-1)),i[777]||(i[777]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[779]||(i[779]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_sample_texture_data_filtered</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, uv, dudx, dudy, dvdx, dvdy) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span></span></code></pre></div><p>Sample texture with filtering based on UV derivatives. Uses the derivatives to compute the filter footprint for mipmap selection.</p><p>TODO: Implement proper mipmap-based filtering. Currently uses bilinear sampling as a simple improvement over point sampling.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[778]||(i[778]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/texture-ref.jl#L117-L125",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",We,[s("summary",null,[i[780]||(i[780]=s("a",{id:"Hikari._sample_with_iterator_helper-Tuple{Any, Hikari.RGBToSpectrumTable, Raycore.Ray, Float32, Hikari.SampledWavelengths{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, UInt64, Any, Any, Hikari.VPMediumSampleWorkItem, Any, Raycore.SetKey, Int32, Int32, Hikari.MajorantGrid}",href:"#Hikari._sample_with_iterator_helper-Tuple{Any, Hikari.RGBToSpectrumTable, Raycore.Ray, Float32, Hikari.SampledWavelengths{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, UInt64, Any, Any, Hikari.VPMediumSampleWorkItem, Any, Raycore.SetKey, Int32, Int32, Hikari.MajorantGrid}"},[s("span",{class:"jlbinding"},"Hikari._sample_with_iterator_helper")],-1)),i[781]||(i[781]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[783]||(i[783]=s("p",null,"Helper to call sample_T_maj_loop! with created iterator (no capture)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[782]||(i[782]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/delta-tracking.jl#L109",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ue,[s("summary",null,[i[784]||(i[784]=s("a",{id:"Hikari._spotlight_transform-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Point{3, Float32}}",href:"#Hikari._spotlight_transform-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari._spotlight_transform")],-1)),i[785]||(i[785]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[787]||(i[787]=s("p",null,"Create a transformation that positions a spotlight and orients it to point at a target. The spotlight points in +Z direction in local space.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[786]||(i[786]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/spot.jl#L101-L104",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",qe,[s("summary",null,[i[788]||(i[788]=s("a",{id:"Hikari._sum_light_le-Tuple{Any, Any}",href:"#Hikari._sum_light_le-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"Hikari._sum_light_le")],-1)),i[789]||(i[789]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[791]||(i[791]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">_sum_light_le</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(light, ray)</span></span></code></pre></div><p>Helper for sum_unrolled to accumulate le() contributions from lights.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[790]||(i[790]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L252-L256",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ze,[s("summary",null,[i[792]||(i[792]=s("a",{id:"Hikari._tonemap_aces-Tuple{Float32, Float32, Float32}",href:"#Hikari._tonemap_aces-Tuple{Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari._tonemap_aces")],-1)),i[793]||(i[793]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[795]||(i[795]=s("p",null,"ACES filmic approximation (Narkowicz). Industry-standard filmic curve used in games and film.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[794]||(i[794]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/postprocess.jl#L96-L99",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ke,[s("summary",null,[i[796]||(i[796]=s("a",{id:"Hikari._tonemap_filmic-Tuple{Float32, Float32, Float32}",href:"#Hikari._tonemap_filmic-Tuple{Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari._tonemap_filmic")],-1)),i[797]||(i[797]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[799]||(i[799]=s("p",null,"Filmic tonemapping (Hejl-Dawson). Alternative filmic curve with good highlight rolloff.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[798]||(i[798]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/postprocess.jl#L145-L148",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ze,[s("summary",null,[i[800]||(i[800]=s("a",{id:"Hikari._tonemap_reinhard-Tuple{Float32, Float32, Float32}",href:"#Hikari._tonemap_reinhard-Tuple{Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari._tonemap_reinhard")],-1)),i[801]||(i[801]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[803]||(i[803]=s("p",null,"Simple Reinhard tonemapping: L / (1 + L)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[802]||(i[802]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/postprocess.jl#L77-L79",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xe,[s("summary",null,[i[804]||(i[804]=s("a",{id:"Hikari._tonemap_reinhard_extended-NTuple{4, Float32}",href:"#Hikari._tonemap_reinhard_extended-NTuple{4, Float32}"},[s("span",{class:"jlbinding"},"Hikari._tonemap_reinhard_extended")],-1)),i[805]||(i[805]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[807]||(i[807]=s("p",null,"Extended Reinhard with white point control.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[806]||(i[806]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/postprocess.jl#L86-L88",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ye,[s("summary",null,[i[808]||(i[808]=s("a",{id:"Hikari._tonemap_uncharted2-Tuple{Float32, Float32, Float32}",href:"#Hikari._tonemap_uncharted2-Tuple{Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari._tonemap_uncharted2")],-1)),i[809]||(i[809]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[811]||(i[811]=s("p",null,"Uncharted 2 filmic tonemapping. Good for high-contrast scenes, preserves detail in shadows.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[810]||(i[810]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/postprocess.jl#L126-L129",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Qe,[s("summary",null,[i[812]||(i[812]=s("a",{id:"Hikari._transmittance_dda_helper-NTuple{10, Any}",href:"#Hikari._transmittance_dda_helper-NTuple{10, Any}"},[s("span",{class:"jlbinding"},"Hikari._transmittance_dda_helper")],-1)),i[813]||(i[813]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[815]||(i[815]=s("p",null,"Helper dispatched via with_index to get concrete medium type for DDA iterator.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[814]||(i[814]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L434",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$e,[s("summary",null,[i[816]||(i[816]=s("a",{id:"Hikari._uncharted2_partial-Tuple{Float32}",href:"#Hikari._uncharted2_partial-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari._uncharted2_partial")],-1)),i[817]||(i[817]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[819]||(i[819]=s("p",null,"Uncharted 2 filmic curve helper.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[818]||(i[818]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/postprocess.jl#L113-L115",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",it,[s("summary",null,[i[820]||(i[820]=s("a",{id:"Hikari.abs_cos_theta-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.abs_cos_theta-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.abs_cos_theta")],-1)),i[821]||(i[821]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[823]||(i[823]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">abs_cos_theta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get |cos(θ)| of a direction in local coordinates (matches pbrt-v4&#39;s AbsCosTheta).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[822]||(i[822]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3598-L3602",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",st,[s("summary",null,[i[824]||(i[824]=s("a",{id:"Hikari.add_to_pixel!-Tuple{AbstractVector{Float32}, Int32, Hikari.SampledSpectrum{4}, Hikari.SampledWavelengths{4}}",href:"#Hikari.add_to_pixel!-Tuple{AbstractVector{Float32}, Int32, Hikari.SampledSpectrum{4}, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.add_to_pixel!")],-1)),i[825]||(i[825]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[827]||(i[827]=s("p",null,"Add spectral contribution to film pixel",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[826]||(i[826]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/delta-tracking.jl#L64",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",et,[s("summary",null,[i[828]||(i[828]=s("a",{id:"Hikari.allocate_array-Union{Tuple{T}, Tuple{Any, Type{T}, Integer}} where T",href:"#Hikari.allocate_array-Union{Tuple{T}, Tuple{Any, Type{T}, Integer}} where T"},[s("span",{class:"jlbinding"},"Hikari.allocate_array")],-1)),i[829]||(i[829]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[831]||(i[831]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">allocate_array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, T, n; soa</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Allocate array with AOS (soa=false) or SOA (soa=true) layout. Both support identical indexing: arr[i] returns T, arr[i] = val stores T.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[830]||(i[830]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/workqueue.jl#L24-L29",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",tt,[s("summary",null,[i[832]||(i[832]=s("a",{id:"Hikari.angle_between-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.angle_between-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.angle_between")],-1)),i[833]||(i[833]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[835]||(i[835]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">angle_between</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v1, v2) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Numerically stable angle between two vectors. Following pbrt-v4 (vecmath.h:972-977).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[834]||(i[834]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-bounds.jl#L38-L43",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",at,[s("summary",null,[i[836]||(i[836]=s("a",{id:"Hikari.apply_white_balance-NTuple{12, Float32}",href:"#Hikari.apply_white_balance-NTuple{12, Float32}"},[s("span",{class:"jlbinding"},"Hikari.apply_white_balance")],-1)),i[837]||(i[837]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[839]||(i[839]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">apply_white_balance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, g, b, wb_matrix) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Apply white balance transformation using precomputed Bradford matrix. Input/output are in linear RGB (assumed sRGB primaries).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[838]||(i[838]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/postprocess.jl#L55-L60",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",lt,[s("summary",null,[i[840]||(i[840]=s("a",{id:"Hikari.approximate_dp_dxy-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Any, Int32}",href:"#Hikari.approximate_dp_dxy-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Any, Int32}"},[s("span",{class:"jlbinding"},"Hikari.approximate_dp_dxy")],-1)),i[841]||(i[841]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[843]||(i[843]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">approximate_dp_dxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n, camera, samples_per_pixel) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (dpdx, dpdy)</span></span></code></pre></div><p>Approximate screen-space position derivatives at intersection point. Following pbrt-v4&#39;s Camera::Approximate_dp_dxy method.</p><p>This estimates how much the surface position changes per pixel, which is used for texture filtering (mipmap level selection). The approximation assumes the surface is locally planar near the intersection point.</p><p>For a perspective camera, this is approximately: dp/dscreen ≈ distance * tan(fov/2) / (resolution/2)</p><p>Arguments:</p><ul><li><p><code>pi</code>: Intersection point in world space</p></li><li><p><code>n</code>: Surface normal at intersection</p></li><li><p><code>camera</code>: Camera with dx_camera, dy_camera precomputed</p></li><li><p><code>samples_per_pixel</code>: Number of samples per pixel (for scaling)</p></li></ul><p>Returns (dpdx, dpdy) - approximate change in position per screen pixel.</p>',7)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[842]||(i[842]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/surface-eval.jl#L11-L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",nt,[s("summary",null,[i[844]||(i[844]=s("a",{id:"Hikari.arealight_Le-Tuple{Hikari.DiffuseAreaLight{Hikari.RGBSpectrum}, Any, Hikari.RGBToSpectrumTable, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, Hikari.SampledWavelengths{4}}",href:"#Hikari.arealight_Le-Tuple{Hikari.DiffuseAreaLight{Hikari.RGBSpectrum}, Any, Hikari.RGBToSpectrumTable, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.arealight_Le")],-1)),i[845]||(i[845]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[847]||(i[847]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arealight_Le</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiffuseAreaLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lights_ctx, table, wo, n, uv, lambda) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Evaluate spectral emission at a surface point on this area light. Following pbrt-v4 DiffuseAreaLight::L().</p><ul><li><p><code>lights_ctx</code>: StaticMultiTypeSet for TextureRef dereference (lights container)</p></li><li><p><code>table</code>: RGBToSpectrumTable for spectral uplift</p></li><li><p><code>wo</code>: outgoing direction (toward camera)</p></li><li><p><code>n</code>: surface normal at hit point</p></li><li><p><code>uv</code>: texture coordinates at hit point</p></li><li><p><code>lambda</code>: sampled wavelengths</p></li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[846]||(i[846]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/diffuse-area.jl#L41-L53",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",rt,[s("summary",null,[i[848]||(i[848]=s("a",{id:"Hikari.atrous_denoise_kernel!-Tuple{Any}",href:"#Hikari.atrous_denoise_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.atrous_denoise_kernel!")],-1)),i[849]||(i[849]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[851]||(i[851]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">atrous_denoise_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output, input, normals, depth, variance,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                       width, height, step_size, config)</span></span></code></pre></div><p>Single pass of the à-trous wavelet filter. Applies a 5x5 filter with edge-stopping weights.</p>`,2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[850]||(i[850]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/denoise.jl#L129-L135",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",pt,[s("summary",null,[i[852]||(i[852]=s("a",{id:"Hikari.balance_heuristic-Tuple{Float32, Float32}",href:"#Hikari.balance_heuristic-Tuple{Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.balance_heuristic")],-1)),i[853]||(i[853]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[855]||(i[855]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">balance_heuristic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pdf_f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pdf_g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Balance heuristic for MIS: w_f = pdf_f / (pdf_f + pdf_g)</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[854]||(i[854]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L249-L253",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ot,[s("summary",null,[i[856]||(i[856]=s("a",{id:"Hikari.binary_permute_scramble-Tuple{UInt32, UInt32}",href:"#Hikari.binary_permute_scramble-Tuple{UInt32, UInt32}"},[s("span",{class:"jlbinding"},"Hikari.binary_permute_scramble")],-1)),i[857]||(i[857]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[859]||(i[859]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">binary_permute_scramble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, perm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt32</span></span></code></pre></div><p>Simple XOR-based scrambling (less quality than Owen, but faster). Reference: pbrt-v4/src/pbrt/util/lowdiscrepancy.h BinaryPermuteScrambler</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[858]||(i[858]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L82-L87",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",dt,[s("summary",null,[i[860]||(i[860]=s("a",{id:"Hikari.blackbody!-Tuple{Vector{Float32}, Vector{Float32}, Float32}",href:"#Hikari.blackbody!-Tuple{Vector{Float32}, Vector{Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.blackbody!")],-1)),i[861]||(i[861]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[863]||(i[863]=n("<p>Compute emitted radiance by blackbody at the given temperature for the wavelengths.</p><p><strong>Args</strong></p><ul><li><p><code>Le::Vector{Float32}</code>: Preallocated output vector for computed radiance.</p></li><li><p><code>λ::Vector{Float32}</code>: Wavelengths for which to compute radiance. Their values should be in <code>nm</code>.</p></li><li><p><code>T::Float32</code>: Temperature in Kelvin at which to compute radiance.</p></li></ul>",3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[862]||(i[862]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/emission.jl#L1-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",kt,[s("summary",null,[i[864]||(i[864]=s("a",{id:"Hikari.blackbody-Tuple{Vector{Float32}, Float32}",href:"#Hikari.blackbody-Tuple{Vector{Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.blackbody")],-1)),i[865]||(i[865]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[867]||(i[867]=s("p",null,[a("Allocating version of "),s("code",null,"blackbody!"),a(" function.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[866]||(i[866]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/emission.jl#L22-L24",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ht,[s("summary",null,[i[868]||(i[868]=s("a",{id:"Hikari.blackbody_normalized!-Tuple{Vector{Float32}, Vector{Float32}, Float32}",href:"#Hikari.blackbody_normalized!-Tuple{Vector{Float32}, Vector{Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.blackbody_normalized!")],-1)),i[869]||(i[869]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[871]||(i[871]=n("<p>Compute normalized SPD for a blackbody, with maximum value of the SPD at any wavelength is 1.</p><p><strong>Args</strong></p><ul><li><p><code>Le::Vector{Float32}</code>: Preallocated output vector for computed radiance.</p></li><li><p><code>λ::Vector{Float32}</code>: Wavelengths for which to compute radiance. Their values should be in <code>nm</code>.</p></li><li><p><code>T::Float32</code>: Temperature in Kelvin at which to compute radiance.</p></li></ul>",3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[870]||(i[870]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/emission.jl#L31-L41",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ut,[s("summary",null,[i[872]||(i[872]=s("a",{id:"Hikari.bound_subtended_directions-Tuple{Raycore.Bounds3, GeometryBasics.Point{3, Float32}}",href:"#Hikari.bound_subtended_directions-Tuple{Raycore.Bounds3, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.bound_subtended_directions")],-1)),i[873]||(i[873]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[875]||(i[875]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bound_subtended_directions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bounds3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DirectionCone</span></span></code></pre></div><p>Compute the bounding cone of directions from point <code>p</code> to bounding box <code>b</code>. If <code>p</code> is inside the box, returns entire sphere. Following pbrt-v4 (vecmath.h:1815-1828).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[874]||(i[874]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-bounds.jl#L89-L95",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",gt,[s("summary",null,[i[876]||(i[876]=s("a",{id:"Hikari.build_majorant_grid!-Tuple{Hikari.MajorantGrid, AbstractArray{Float32, 3}}",href:"#Hikari.build_majorant_grid!-Tuple{Hikari.MajorantGrid, AbstractArray{Float32, 3}}"},[s("span",{class:"jlbinding"},"Hikari.build_majorant_grid!")],-1)),i[877]||(i[877]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[879]||(i[879]=s("p",null,"In-place majorant grid rebuild for GridMedium density updates.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[878]||(i[878]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1498",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ct,[s("summary",null,[i[880]||(i[880]=s("a",{id:"Hikari.build_majorant_grid-Tuple{AbstractArray{Float32, 3}, GeometryBasics.Vec{3, Int64}}",href:"#Hikari.build_majorant_grid-Tuple{AbstractArray{Float32, 3}, GeometryBasics.Vec{3, Int64}}"},[s("span",{class:"jlbinding"},"Hikari.build_majorant_grid")],-1)),i[881]||(i[881]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[883]||(i[883]=s("p",null,"Build a coarse majorant grid from the density field",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[882]||(i[882]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1458",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",bt,[s("summary",null,[i[884]||(i[884]=s("a",{id:"Hikari.build_nanovdb_from_dense-Tuple{Array{Float32, 3}, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.build_nanovdb_from_dense-Tuple{Array{Float32, 3}, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.build_nanovdb_from_dense")],-1)),i[885]||(i[885]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[887]||(i[887]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">build_nanovdb_from_dense</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Array{Float32,3}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, extent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; background</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert a dense 3D Float32 array to a NanoVDB-compatible binary buffer. Only stores leaf blocks (8³) that contain non-background voxels, giving significant memory savings for sparse data (e.g. cloud fields with ~1% fill).</p><p>Returns <code>(buffer::Vector{UInt8}, metadata::NamedTuple)</code> suitable for constructing a <code>NanoVDBMedium</code>.</p><p>The NanoVDB tree hierarchy is: Root → Upper (32³) → Lower (16³) → Leaf (8³). Buffer layout: [Root | Upper nodes | Lower nodes | Leaf nodes] All child offsets are stored relative to the parent node.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[886]||(i[886]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L588-L601",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",yt,[s("summary",null,[i[888]||(i[888]=s("a",{id:"Hikari.build_nanovdb_majorant_grid",href:"#Hikari.build_nanovdb_majorant_grid"},[s("span",{class:"jlbinding"},"Hikari.build_nanovdb_majorant_grid")],-1)),i[889]||(i[889]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[891]||(i[891]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">build_nanovdb_majorant_grid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(medium_partial, res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MajorantGrid</span></span></code></pre></div><p>Build a majorant grid for NanoVDBMedium by sampling max density in each cell. Matches pbrt-v4&#39;s majorant grid construction.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[890]||(i[890]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L1168-L1173",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",mt,[s("summary",null,[i[892]||(i[892]=s("a",{id:"Hikari.build_rgb_majorant_grid!-Tuple{Hikari.MajorantGrid, Union{Nothing, AbstractArray{Hikari.RGBSpectrum, 3}}, Union{Nothing, AbstractArray{Hikari.RGBSpectrum, 3}}, Float32, Tuple{Int64, Int64, Int64}}",href:"#Hikari.build_rgb_majorant_grid!-Tuple{Hikari.MajorantGrid, Union{Nothing, AbstractArray{Hikari.RGBSpectrum, 3}}, Union{Nothing, AbstractArray{Hikari.RGBSpectrum, 3}}, Float32, Tuple{Int64, Int64, Int64}}"},[s("span",{class:"jlbinding"},"Hikari.build_rgb_majorant_grid!")],-1)),i[893]||(i[893]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[895]||(i[895]=s("p",null,"In-place majorant grid rebuild for RGBGridMedium density updates.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[894]||(i[894]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1185",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ft,[s("summary",null,[i[896]||(i[896]=s("a",{id:"Hikari.build_rgb_majorant_grid-Tuple{Union{Nothing, AbstractArray{Hikari.RGBSpectrum, 3}}, Union{Nothing, AbstractArray{Hikari.RGBSpectrum, 3}}, Float32, Tuple{Int64, Int64, Int64}, GeometryBasics.Vec{3, Int64}}",href:"#Hikari.build_rgb_majorant_grid-Tuple{Union{Nothing, AbstractArray{Hikari.RGBSpectrum, 3}}, Union{Nothing, AbstractArray{Hikari.RGBSpectrum, 3}}, Float32, Tuple{Int64, Int64, Int64}, GeometryBasics.Vec{3, Int64}}"},[s("span",{class:"jlbinding"},"Hikari.build_rgb_majorant_grid")],-1)),i[897]||(i[897]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[899]||(i[899]=s("p",null,"Build majorant grid for RGBGridMedium following pbrt-v4.",-1)),i[900]||(i[900]=s("p",null,"For each majorant voxel, computes: sigma_scale * (max(σ_a.MaxValue) + max(σ_s.MaxValue))",-1)),i[901]||(i[901]=s("p",null,"where MaxValue returns the maximum RGB component of each spectrum.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[898]||(i[898]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1115-L1122",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Et,[s("summary",null,[i[902]||(i[902]=s("a",{id:"Hikari.bvh_pmf-Tuple{AbstractVector{Hikari.LightBVHNode}, AbstractVector{UInt32}, Int32, Int32, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Int32}",href:"#Hikari.bvh_pmf-Tuple{AbstractVector{Hikari.LightBVHNode}, AbstractVector{UInt32}, Int32, Int32, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Int32}"},[s("span",{class:"jlbinding"},"Hikari.bvh_pmf")],-1)),i[903]||(i[903]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[905]||(i[905]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bvh_pmf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodes, light_to_bit_trail, num_infinite, num_bvh, p, n, light_flat_idx) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute the PMF for a specific light at shading point (p, n). Uses the bit trail to replay the BVH traversal path efficiently.</p><p>Following pbrt-v4&#39;s BVHLightSampler::PMF (lightsamplers.h:323-358).</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[904]||(i[904]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/bvh-light-sampler.jl#L176-L183",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_t,[s("summary",null,[i[906]||(i[906]=s("a",{id:"Hikari.bvh_sample_light-Tuple{AbstractVector{Hikari.LightBVHNode}, AbstractVector{Int32}, Int32, Int32, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32}",href:"#Hikari.bvh_sample_light-Tuple{AbstractVector{Hikari.LightBVHNode}, AbstractVector{Int32}, Int32, Int32, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.bvh_sample_light")],-1)),i[907]||(i[907]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[909]||(i[909]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bvh_sample_light</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodes, infinite_indices, num_infinite, num_bvh, p, n, u) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Int32, Float32)</span></span></code></pre></div><p>Sample a light from the BVH using importance-weighted traversal. Returns (flat_light_index, pmf). Returns (0, 0) on failure.</p><p>Following pbrt-v4&#39;s BVHLightSampler::Sample (lightsamplers.h:266-320).</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[908]||(i[908]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/bvh-light-sampler.jl#L97-L104",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Tt,[s("summary",null,[i[910]||(i[910]=s("a",{id:"Hikari.bvh_to_gpu-Tuple{Any, Hikari.BVHLightSampler}",href:"#Hikari.bvh_to_gpu-Tuple{Any, Hikari.BVHLightSampler}"},[s("span",{class:"jlbinding"},"Hikari.bvh_to_gpu")],-1)),i[911]||(i[911]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[913]||(i[913]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">to_gpu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, sampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BVHLightSampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NamedTuple</span></span></code></pre></div><p>Upload BVH light sampler data to GPU. Returns a NamedTuple with GPU arrays.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[912]||(i[912]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/bvh-light-sampler.jl#L472-L476",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",jt,[s("summary",null,[i[914]||(i[914]=s("a",{id:"Hikari.choose_material-Tuple{Hikari.MixMaterial, Raycore.StaticMultiTypeSet, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.choose_material-Tuple{Hikari.MixMaterial, Raycore.StaticMultiTypeSet, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.choose_material")],-1)),i[915]||(i[915]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[917]||(i[917]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">choose_material</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mix</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MixMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, uv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SetKey</span></span></code></pre></div><p>Choose which sub-material to use at the given hit point. Returns the SetKey of the chosen material.</p><p>Following pbrt-v4&#39;s ChooseMaterial:</p><ol><li><p>Evaluate the amount texture at (uv)</p></li><li><p>If amount ≤ 0, return material1</p></li><li><p>If amount ≥ 1, return material2</p></li><li><p>Otherwise, use deterministic hash to stochastically select</p></li></ol><p>This function is called at intersection time, before material evaluation.</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[916]||(i[916]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/mix-material.jl#L164-L177",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ft,[s("summary",null,[i[918]||(i[918]=s("a",{id:"Hikari.choose_material_dispatch-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.choose_material_dispatch-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.choose_material_dispatch")],-1)),i[919]||(i[919]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[921]||(i[921]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">choose_material_dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p, wo, uv) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SetKey</span></span></code></pre></div><p>Type-stable dispatch for choosing material from MixMaterial. If the material is not MixMaterial, returns the input index unchanged. <code>materials</code> is used both for material lookup and texture evaluation.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[920]||(i[920]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/mix-material.jl#L219-L225",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ct,[s("summary",null,[i[922]||(i[922]=s("a",{id:"Hikari.cleanup!-Tuple{Hikari.FastWavefrontBuffers}",href:"#Hikari.cleanup!-Tuple{Hikari.FastWavefrontBuffers}"},[s("span",{class:"jlbinding"},"Hikari.cleanup!")],-1)),i[923]||(i[923]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[925]||(i[925]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cleanup!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(buffers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FastWavefrontBuffers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Release GPU memory held by FastWavefront buffers.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[924]||(i[924]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/fast-wavefront.jl#L726-L730",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",vt,[s("summary",null,[i[926]||(i[926]=s("a",{id:"Hikari.cleanup!-Tuple{Hikari.FastWavefront}",href:"#Hikari.cleanup!-Tuple{Hikari.FastWavefront}"},[s("span",{class:"jlbinding"},"Hikari.cleanup!")],-1)),i[927]||(i[927]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[929]||(i[929]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cleanup!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(integrator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FastWavefront</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Release GPU memory held by the integrator&#39;s cached buffers.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[928]||(i[928]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/fast-wavefront.jl#L751-L755",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ht,[s("summary",null,[i[930]||(i[930]=s("a",{id:"Hikari.cleanup!-Tuple{Hikari.SobolRNG}",href:"#Hikari.cleanup!-Tuple{Hikari.SobolRNG}"},[s("span",{class:"jlbinding"},"Hikari.cleanup!")],-1)),i[931]||(i[931]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[933]||(i[933]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cleanup!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SobolRNG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Release GPU memory held by the SobolRNG.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[932]||(i[932]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L395-L399",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",At,[s("summary",null,[i[934]||(i[934]=s("a",{id:"Hikari.cleanup!-Tuple{Hikari.VolPathState}",href:"#Hikari.cleanup!-Tuple{Hikari.VolPathState}"},[s("span",{class:"jlbinding"},"Hikari.cleanup!")],-1)),i[935]||(i[935]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[937]||(i[937]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cleanup!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VolPathState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Release GPU memory held by the VolPath state.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[936]||(i[936]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath-state.jl#L233-L237",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",St,[s("summary",null,[i[938]||(i[938]=s("a",{id:"Hikari.clear!-Tuple{Hikari.VolPath}",href:"#Hikari.clear!-Tuple{Hikari.VolPath}"},[s("span",{class:"jlbinding"},"Hikari.clear!")],-1)),i[939]||(i[939]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[941]||(i[941]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">clear!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(integrator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VolPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Clear the integrator&#39;s internal state (RGB and weight accumulators) for restarting progressive rendering.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[940]||(i[940]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath.jl#L103-L107",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xt,[s("summary",null,[i[942]||(i[942]=s("a",{id:"Hikari.compute_bsdf-Tuple{Hikari.CloudVolume, Any, Hikari.SurfaceInteraction, Bool, Any}",href:"#Hikari.compute_bsdf-Tuple{Hikari.CloudVolume, Any, Hikari.SurfaceInteraction, Bool, Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_bsdf")],-1)),i[943]||(i[943]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[945]||(i[945]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_bsdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cloud</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CloudVolume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, si, allow_multiple_lobes, transport) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BSDF</span></span></code></pre></div><p>Returns a dummy BSDF for volume materials. Volumes don&#39;t use BSDF-based shading; they use ray marching in shade() instead. This method exists so that compute_bsdf_for_material can handle CloudVolume without special-casing.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[944]||(i[944]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L414-L420",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Bt,[s("summary",null,[i[946]||(i[946]=s("a",{id:"Hikari.compute_bsdf-Tuple{Hikari.ConductorMaterial, Any, Hikari.SurfaceInteraction, Bool, Any}",href:"#Hikari.compute_bsdf-Tuple{Hikari.ConductorMaterial, Any, Hikari.SurfaceInteraction, Bool, Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_bsdf")],-1)),i[947]||(i[947]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[949]||(i[949]=s("p",null,"Compute BSDF for ConductorMaterial - conductor with Fresnel reflectance.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[948]||(i[948]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/material.jl#L93-L95",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Dt,[s("summary",null,[i[950]||(i[950]=s("a",{id:"Hikari.compute_bsdf-Tuple{Hikari.Emissive, Any, Hikari.SurfaceInteraction, Bool, Any}",href:"#Hikari.compute_bsdf-Tuple{Hikari.Emissive, Any, Hikari.SurfaceInteraction, Bool, Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_bsdf")],-1)),i[951]||(i[951]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[953]||(i[953]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_bsdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, si</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SurfaceInteraction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, transport)</span></span></code></pre></div><p>Emissive has no BSDF (pure emitter, doesn&#39;t scatter light). Returns an empty BSDF.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[952]||(i[952]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/emissive.jl#L114-L119",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",It,[s("summary",null,[i[954]||(i[954]=s("a",{id:"Hikari.compute_bsdf-Tuple{Hikari.GlassMaterial, Any, Hikari.SurfaceInteraction, Bool, Any}",href:"#Hikari.compute_bsdf-Tuple{Hikari.GlassMaterial, Any, Hikari.SurfaceInteraction, Bool, Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_bsdf")],-1)),i[955]||(i[955]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[957]||(i[957]=s("p",null,"Compute BSDF for GlassMaterial.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[956]||(i[956]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/material.jl#L37-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Mt,[s("summary",null,[i[958]||(i[958]=s("a",{id:"Hikari.compute_bsdf-Tuple{Hikari.MatteMaterial, Any, Hikari.SurfaceInteraction, Bool, Any}",href:"#Hikari.compute_bsdf-Tuple{Hikari.MatteMaterial, Any, Hikari.SurfaceInteraction, Bool, Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_bsdf")],-1)),i[959]||(i[959]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[961]||(i[961]=s("p",null,"Compute BSDF for MatteMaterial.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[960]||(i[960]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/material.jl#L18-L20",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Gt,[s("summary",null,[i[962]||(i[962]=s("a",{id:"Hikari.compute_bsdf-Tuple{Hikari.MirrorMaterial, Any, Hikari.SurfaceInteraction, Bool, Any}",href:"#Hikari.compute_bsdf-Tuple{Hikari.MirrorMaterial, Any, Hikari.SurfaceInteraction, Bool, Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_bsdf")],-1)),i[963]||(i[963]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[965]||(i[965]=s("p",null,"Compute BSDF for MirrorMaterial.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[964]||(i[964]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/material.jl#L29-L31",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Pt,[s("summary",null,[i[966]||(i[966]=s("a",{id:"Hikari.compute_differentials-Tuple{Hikari.SurfaceInteraction, Raycore.RayDifferentials}",href:"#Hikari.compute_differentials-Tuple{Hikari.SurfaceInteraction, Raycore.RayDifferentials}"},[s("span",{class:"jlbinding"},"Hikari.compute_differentials")],-1)),i[967]||(i[967]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[969]||(i[969]=s("p",null,"Compute partial derivatives needed for computing sampling rates for things like texture antialiasing.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[968]||(i[968]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/surface_interaction.jl#L132-L135",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Vt,[s("summary",null,[i[970]||(i[970]=s("a",{id:"Hikari.compute_direct_lighting_spectral-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledWavelengths{4}, Hikari.PWLightSample, Hikari.SampledSpectrum{4}, Float32}",href:"#Hikari.compute_direct_lighting_spectral-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledWavelengths{4}, Hikari.PWLightSample, Hikari.SampledSpectrum{4}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.compute_direct_lighting_spectral")],-1)),i[971]||(i[971]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[973]||(i[973]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_direct_lighting_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, n, wo, beta, r_u, lambda, light_sample, bsdf_f, bsdf_pdf)</span></span></code></pre></div><p>Compute direct lighting contribution from a light sample with MIS.</p><p>Following pbrt-v4 (surfscatter.cpp lines 288-316):</p><ul><li><p>Ld = beta * f * Li * cos_theta (NO MIS weight or PDF division here)</p></li><li><p>r_u = r_u * bsdfPDF (0 for delta lights)</p></li><li><p>r_l = r_u * lightPDF</p></li><li><p>MIS weighting happens at shadow ray resolution: Ld * T_ray / (r_u * tr_r_u + r_l * tr_r_l).Average()</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[972]||(i[972]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L524-L534",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Lt,[s("summary",null,[i[974]||(i[974]=s("a",{id:"Hikari.compute_env_light_pdf-Tuple{Raycore.StaticMultiTypeSet, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.compute_env_light_pdf-Tuple{Raycore.StaticMultiTypeSet, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.compute_env_light_pdf")],-1)),i[975]||(i[975]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[977]||(i[977]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_env_light_pdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ray_d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute PDF for sampling direction from environment-type lights using StaticMultiTypeSet.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[976]||(i[976]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L460-L464",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",wt,[s("summary",null,[i[978]||(i[978]=s("a",{id:"Hikari.compute_geometric_normal-Tuple{Any}",href:"#Hikari.compute_geometric_normal-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_geometric_normal")],-1)),i[979]||(i[979]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[981]||(i[981]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_geometric_normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Compute geometric normal from a primitive (triangle).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[980]||(i[980]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L96-L100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Rt,[s("summary",null,[i[982]||(i[982]=s("a",{id:"Hikari.compute_path_sample_1d-NTuple{5, Int32}",href:"#Hikari.compute_path_sample_1d-NTuple{5, Int32}"},[s("span",{class:"jlbinding"},"Hikari.compute_path_sample_1d")],-1)),i[983]||(i[983]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[985]||(i[985]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_path_sample_1d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, local_dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute a 1D sample for path tracing at a given depth. Each depth gets a separate set of dimensions to avoid correlation.</p><p>NOTE: This is the old hash-based version. Use compute_path_sample_1d_sobol for better convergence.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[984]||(i[984]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L208-L215",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Nt,[s("summary",null,[i[986]||(i[986]=s("a",{id:"Hikari.compute_path_sample_1d-Tuple{Hikari.SobolRNG, Vararg{Int32, 5}}",href:"#Hikari.compute_path_sample_1d-Tuple{Hikari.SobolRNG, Vararg{Int32, 5}}"},[s("span",{class:"jlbinding"},"Hikari.compute_path_sample_1d")],-1)),i[987]||(i[987]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[989]||(i[989]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_path_sample_1d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SobolRNG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, local_dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute a 1D sample for path tracing at a given depth using SobolRNG.</p><p><strong>Dimension allocation:</strong></p><ul><li><p>Base dimension = 6 (camera uses 0-5)</p></li><li><p>Each depth uses 8 dimensions for BSDF, light, RR, etc.</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[988]||(i[988]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L452-L460",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ot,[s("summary",null,[i[990]||(i[990]=s("a",{id:"Hikari.compute_path_sample_1d_sobol-Tuple{Int32, Int32, Int32, Int32, Int32, Int32, Int32, UInt32, Any}",href:"#Hikari.compute_path_sample_1d_sobol-Tuple{Int32, Int32, Int32, Int32, Int32, Int32, Int32, UInt32, Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_path_sample_1d_sobol")],-1)),i[991]||(i[991]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[993]||(i[993]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_path_sample_1d_sobol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px, py, sample_idx, depth, local_dim, log2_spp, n_base4_digits, seed, sobol_matrices) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute a 1D sample for path tracing using ZSobol sampler.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[992]||(i[992]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L266-L270",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Jt,[s("summary",null,[i[994]||(i[994]=s("a",{id:"Hikari.compute_path_sample_2d-NTuple{5, Int32}",href:"#Hikari.compute_path_sample_2d-NTuple{5, Int32}"},[s("span",{class:"jlbinding"},"Hikari.compute_path_sample_2d")],-1)),i[995]||(i[995]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[997]||(i[997]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_path_sample_2d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, local_dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Tuple{Float32, Float32}</span></span></code></pre></div><p>Compute a 2D sample for path tracing at a given depth.</p><p>NOTE: This is the old hash-based version. Use compute_path_sample_2d_sobol for better convergence.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[996]||(i[996]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L223-L229",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Wt,[s("summary",null,[i[998]||(i[998]=s("a",{id:"Hikari.compute_path_sample_2d-Tuple{Hikari.SobolRNG, Vararg{Int32, 5}}",href:"#Hikari.compute_path_sample_2d-Tuple{Hikari.SobolRNG, Vararg{Int32, 5}}"},[s("span",{class:"jlbinding"},"Hikari.compute_path_sample_2d")],-1)),i[999]||(i[999]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1001]||(i[1001]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_path_sample_2d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SobolRNG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, local_dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Tuple{Float32, Float32}</span></span></code></pre></div><p>Compute a 2D sample for path tracing at a given depth using SobolRNG.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1e3]||(i[1e3]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L466-L470",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ut,[s("summary",null,[i[1002]||(i[1002]=s("a",{id:"Hikari.compute_path_sample_2d_sobol-Tuple{Int32, Int32, Int32, Int32, Int32, Int32, Int32, UInt32, Any}",href:"#Hikari.compute_path_sample_2d_sobol-Tuple{Int32, Int32, Int32, Int32, Int32, Int32, Int32, UInt32, Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_path_sample_2d_sobol")],-1)),i[1003]||(i[1003]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1005]||(i[1005]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_path_sample_2d_sobol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px, py, sample_idx, depth, local_dim, log2_spp, n_base4_digits, seed, sobol_matrices) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Tuple{Float32, Float32}</span></span></code></pre></div><p>Compute a 2D sample for path tracing using ZSobol sampler.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1004]||(i[1004]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L281-L285",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",qt,[s("summary",null,[i[1006]||(i[1006]=s("a",{id:"Hikari.compute_pdf-Tuple{Hikari.UberBxDF, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.compute_pdf-Tuple{Hikari.UberBxDF, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.compute_pdf")],-1)),i[1007]||(i[1007]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1009]||(i[1009]=s("p",null,[a("Compute PDF value for the given directions. In comparison, "),s("code",null,"sample_f"),a(" computes PDF value for the incident directions "),s("em",null,"it"),a(" chooses given the outgoing direction, while this returns a value of PDF for the given pair of directions.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1008]||(i[1008]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/uber-material.jl#L123-L128",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",zt,[s("summary",null,[i[1010]||(i[1010]=s("a",{id:"Hikari.compute_pixel_sample-Tuple{Hikari.SobolRNG, Int32, Int32, Int32}",href:"#Hikari.compute_pixel_sample-Tuple{Hikari.SobolRNG, Int32, Int32, Int32}"},[s("span",{class:"jlbinding"},"Hikari.compute_pixel_sample")],-1)),i[1011]||(i[1011]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1013]||(i[1013]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_pixel_sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SobolRNG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute all camera sample values for a pixel using SobolRNG. Returns a PixelSample struct with jitter, wavelength, lens, and time samples.</p><p><strong>Dimension allocation (matching PBRT-v4 exactly):</strong></p><p><strong>See pbrt-v4/src/pbrt/wavefront/camera.cpp:51-60 and samplers.h:797-814</strong></p><p><strong>pbrt-v4&#39;s Get1D/Get2D increment dimension BEFORE computing hash:</strong></p><p><strong>- StartPixelSample(pPixel, sampleIndex, 0): dimension = 0</strong></p><p><strong>- Get1D() for wavelength: dimension++ → 1, hash uses 1</strong></p><p><strong>- GetPixel2D() which is Get2D(): dimension += 2 → 3, hash uses 3 (for jitter)</strong></p><p><strong>- Get1D() for time: dimension++ → 4, hash uses 4</strong></p><p><strong>- Get2D() for lens: dimension += 2 → 6, hash uses 6</strong></p><p><strong>So dimensions used are: 1 (wavelength), 3 (jitter), 4 (time), 6 (lens)</strong></p>',11)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1012]||(i[1012]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L427-L442",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Kt,[s("summary",null,[i[1014]||(i[1014]=s("a",{id:"Hikari.compute_pixel_sample-Tuple{Int32, Int32, Int32}",href:"#Hikari.compute_pixel_sample-Tuple{Int32, Int32, Int32}"},[s("span",{class:"jlbinding"},"Hikari.compute_pixel_sample")],-1)),i[1015]||(i[1015]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1017]||(i[1017]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_pixel_sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PixelSample</span></span></code></pre></div><p>Compute all sample values for a pixel sample deterministically. Uses R2 sequence for pixel jitter (better 2D stratification) and hash-based sampling for other dimensions.</p><p>NOTE: This is the old hash-based version. Use compute_pixel_sample_sobol for better convergence.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1016]||(i[1016]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L180-L188",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Zt,[s("summary",null,[i[1018]||(i[1018]=s("a",{id:"Hikari.compute_pixel_sample_sobol-Tuple{Int32, Int32, Int32, Int32, Int32, UInt32, Any}",href:"#Hikari.compute_pixel_sample_sobol-Tuple{Int32, Int32, Int32, Int32, Int32, UInt32, Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_pixel_sample_sobol")],-1)),i[1019]||(i[1019]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1021]||(i[1021]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_pixel_sample_sobol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px, py, sample_idx, log2_spp, n_base4_digits, seed, sobol_matrices) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PixelSample</span></span></code></pre></div><p>Compute all sample values for a pixel sample using ZSobol sampler. This matches PBRT-v4&#39;s ZSobolSampler for better convergence.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1020]||(i[1020]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L242-L247",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xt,[s("summary",null,[i[1022]||(i[1022]=s("a",{id:"Hikari.compute_scattering!",href:"#Hikari.compute_scattering!"},[s("span",{class:"jlbinding"},"Hikari.compute_scattering!")],-1)),i[1023]||(i[1023]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[1025]||(i[1025]=s("p",null,[a("If an intersection was found, it is necessary to determine, how the surface's material scatters light. "),s("code",null,"compute_scattering!"),a(" method evaluates texture functions to determine surface properties and then initializing a representation of the BSDF at the point.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1024]||(i[1024]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/surface_interaction.jl#L177-L183",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Yt,[s("summary",null,[i[1026]||(i[1026]=s("a",{id:"Hikari.compute_shading_normal-Tuple{Any, Any, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.compute_shading_normal-Tuple{Any, Any, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.compute_shading_normal")],-1)),i[1027]||(i[1027]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1029]||(i[1029]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_shading_normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive, barycentric, geometric_normal) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Compute interpolated shading normal from vertex normals using barycentric coordinates. Falls back to geometric normal if vertex normals are not available (NaN).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1028]||(i[1028]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L196-L201",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Qt,[s("summary",null,[i[1030]||(i[1030]=s("a",{id:"Hikari.compute_tangent_frame-Tuple{Any}",href:"#Hikari.compute_tangent_frame-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_tangent_frame")],-1)),i[1031]||(i[1031]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1033]||(i[1033]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_tangent_frame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (dpdu</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dpdv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute tangent vectors for a primitive.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1032]||(i[1032]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L154-L158",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$t,[s("summary",null,[i[1034]||(i[1034]=s("a",{id:"Hikari.compute_texture_filter_context-Tuple{Hikari.VPMaterialEvalWorkItem, Any, Int32}",href:"#Hikari.compute_texture_filter_context-Tuple{Hikari.VPMaterialEvalWorkItem, Any, Int32}"},[s("span",{class:"jlbinding"},"Hikari.compute_texture_filter_context")],-1)),i[1035]||(i[1035]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1037]||(i[1037]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_texture_filter_context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(work, camera, samples_per_pixel) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TextureFilterContext</span></span></code></pre></div><p>Compute texture filtering context from material evaluation work item. Uses approximate screen-space derivatives for proper mipmap selection.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1036]||(i[1036]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/surface-eval.jl#L125-L130",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ia,[s("summary",null,[i[1038]||(i[1038]=s("a",{id:"Hikari.compute_transmittance",href:"#Hikari.compute_transmittance"},[s("span",{class:"jlbinding"},"Hikari.compute_transmittance")],-1)),i[1039]||(i[1039]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[1041]||(i[1041]=s("p",null,"Compute transmittance from a point towards a direction through the volume",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1040]||(i[1040]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L185",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",sa,[s("summary",null,[i[1042]||(i[1042]=s("a",{id:"Hikari.compute_transmittance_ratio_tracking-Tuple{Any, Any, Raycore.SetKey, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Hikari.SampledWavelengths{4}}",href:"#Hikari.compute_transmittance_ratio_tracking-Tuple{Any, Any, Raycore.SetKey, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.compute_transmittance_ratio_tracking")],-1)),i[1043]||(i[1043]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1045]||(i[1045]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_transmittance_ratio_tracking</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, media, medium_idx, origin, dir, t_max, lambda)</span></span></code></pre></div><p>Compute transmittance through heterogeneous medium using ratio tracking. Following pbrt-v4&#39;s TraceTransmittance / SampleT_maj implementation.</p><p>Uses DDA-based per-voxel majorant bounds (via RayMajorantIterator) for tight bounds in sparse heterogeneous media, matching the primary path&#39;s delta tracking.</p><p>Returns (T_ray, r_u, r_l) where:</p><ul><li><p>T_ray: spectral transmittance estimate</p></li><li><p>r_u, r_l: MIS weight accumulators for combining with path weights</p></li></ul>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1044]||(i[1044]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L408-L420",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ea,[s("summary",null,[i[1046]||(i[1046]=s("a",{id:"Hikari.compute_transmittance_simple-Tuple{Any, Any, Raycore.SetKey, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Hikari.SampledWavelengths{4}}",href:"#Hikari.compute_transmittance_simple-Tuple{Any, Any, Raycore.SetKey, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.compute_transmittance_simple")],-1)),i[1047]||(i[1047]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1049]||(i[1049]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_transmittance_simple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, media, medium_idx, origin, dir, t_max, lambda)</span></span></code></pre></div><p>Simple wrapper that returns only the transmittance (for compatibility).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1048]||(i[1048]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L544-L548",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ta,[s("summary",null,[i[1050]||(i[1050]=s("a",{id:"Hikari.compute_uv-Tuple{Any, GeometryBasics.Point{3, Float32}}",href:"#Hikari.compute_uv-Tuple{Any, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.compute_uv")],-1)),i[1051]||(i[1051]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1053]||(i[1053]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_uv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Point2f</span></span></code></pre></div><p>Compute UV coordinates for a point on a primitive. Uses barycentric interpolation for triangles.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1052]||(i[1052]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L112-L117",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",aa,[s("summary",null,[i[1054]||(i[1054]=s("a",{id:"Hikari.compute_uv_barycentric-Tuple{Any, Any}",href:"#Hikari.compute_uv_barycentric-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_uv_barycentric")],-1)),i[1055]||(i[1055]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1057]||(i[1057]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_uv_barycentric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive, barycentric) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Point2f</span></span></code></pre></div><p>Compute UV coordinates using barycentric coordinates from ray intersection. More accurate than recomputing barycentric from position.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1056]||(i[1056]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L175-L180",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",la,[s("summary",null,[i[1058]||(i[1058]=s("a",{id:"Hikari.compute_uv_derivatives-NTuple{4, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.compute_uv_derivatives-NTuple{4, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.compute_uv_derivatives")],-1)),i[1059]||(i[1059]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1061]||(i[1061]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_uv_derivatives</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dpdu, dpdv, dpdx, dpdy) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (dudx, dudy, dvdx, dvdy)</span></span></code></pre></div><p>Compute UV derivatives from position derivatives using least-squares solve. Following pbrt-v4&#39;s SurfaceInteraction::ComputeDifferentials.</p><p>Given:</p><ul><li><p>dpdu, dpdv: How position changes with UV (∂p/∂u, ∂p/∂v)</p></li><li><p>dpdx, dpdy: How position changes with screen pixel (∂p/∂x, ∂p/∂y)</p></li></ul><p>Solve for:</p><ul><li><p>dudx, dudy: How u changes with screen pixel (∂u/∂x, ∂u/∂y)</p></li><li><p>dvdx, dvdy: How v changes with screen pixel (∂v/∂x, ∂v/∂y)</p></li></ul><p>Uses the normal equations: (A^T A) [du/dx; dv/dx]^T = A^T [dpdx] where A = [dpdu | dpdv] is a 3x2 matrix.</p>',7)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1060]||(i[1060]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/surface-eval.jl#L65-L81",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",na,[s("summary",null,[i[1062]||(i[1062]=s("a",{id:"Hikari.compute_variance_kernel!-Tuple{Any}",href:"#Hikari.compute_variance_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.compute_variance_kernel!")],-1)),i[1063]||(i[1063]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1065]||(i[1065]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_variance_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(variance, input, width, height)</span></span></code></pre></div><p>Compute per-pixel variance from RGB framebuffer. Uses spatial 3x3 neighborhood for variance estimation.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1064]||(i[1064]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/denoise.jl#L230-L235",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ra,[s("summary",null,[i[1066]||(i[1066]=s("a",{id:"Hikari.compute_white_balance_matrix-Tuple{Float32}",href:"#Hikari.compute_white_balance_matrix-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.compute_white_balance_matrix")],-1)),i[1067]||(i[1067]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1069]||(i[1069]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_white_balance_matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(src_temp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SMatrix{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,Float32}</span></span></code></pre></div><p>Compute the Bradford chromatic adaptation matrix to transform from source illuminant (at color temperature src_temp in Kelvin) to D65.</p><p>This is used for white balancing: colors captured under a light source at <code>src_temp</code> Kelvin are transformed to appear as if they were captured under D65.</p><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Adapt from 5000K (warm daylight) to D65</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">wb_matrix </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> compute_white_balance_matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5000f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div>`,5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1068]||(i[1068]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L507-L521",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",pa,[s("summary",null,[i[1070]||(i[1070]=s("a",{id:"Hikari.compute_zsobol_params-Tuple{Int64, Int64, Int64}",href:"#Hikari.compute_zsobol_params-Tuple{Int64, Int64, Int64}"},[s("span",{class:"jlbinding"},"Hikari.compute_zsobol_params")],-1)),i[1071]||(i[1071]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1073]||(i[1073]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_zsobol_params</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(samples_per_pixel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, height</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Int32, Int32)</span></span></code></pre></div><p>Compute the ZSobol sampler parameters from render settings. Returns (log2_spp, n_base4_digits).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1072]||(i[1072]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L314-L319",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",oa,[s("summary",null,[i[1074]||(i[1074]=s("a",{id:"Hikari.convert_lights_for_fast_wavefront-Tuple{Any, Float32}",href:"#Hikari.convert_lights_for_fast_wavefront-Tuple{Any, Float32}"},[s("span",{class:"jlbinding"},"Hikari.convert_lights_for_fast_wavefront")],-1)),i[1075]||(i[1075]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1077]||(i[1077]=s("p",null,"Convert lights for fast wavefront rendering. Returns a tuple of lights.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1076]||(i[1076]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/fast-wavefront.jl#L785-L788",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",da,[s("summary",null,[i[1078]||(i[1078]=s("a",{id:"Hikari.coordinate_system-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.coordinate_system-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.coordinate_system")],-1)),i[1079]||(i[1079]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1081]||(i[1081]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">coordinate_system</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (tangent, bitangent)</span></span></code></pre></div><p>Build orthonormal basis from a normal vector.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1080]||(i[1080]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3509-L3513",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ka,[s("summary",null,[i[1082]||(i[1082]=s("a",{id:"Hikari.cos2_theta-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.cos2_theta-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.cos2_theta")],-1)),i[1083]||(i[1083]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1085]||(i[1085]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cos2_theta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get cos²(θ) of a direction in local coordinates.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1084]||(i[1084]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3591-L3595",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ha,[s("summary",null,[i[1086]||(i[1086]=s("a",{id:"Hikari.cos_phi-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.cos_phi-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.cos_phi")],-1)),i[1087]||(i[1087]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1089]||(i[1089]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cos_phi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get cos(φ) of a direction in local coordinates (matches pbrt-v4&#39;s CosPhi).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1088]||(i[1088]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3629-L3633",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ua,[s("summary",null,[i[1090]||(i[1090]=s("a",{id:"Hikari.cos_theta-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.cos_theta-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.cos_theta")],-1)),i[1091]||(i[1091]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1093]||(i[1093]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cos_theta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get cos(θ) of a direction in local coordinates (matches pbrt-v4&#39;s CosTheta). In local space, z is the surface normal.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1092]||(i[1092]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3583-L3588",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ga,[s("summary",null,[i[1094]||(i[1094]=s("a",{id:"Hikari.cos_θ-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.cos_θ-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.cos_θ")],-1)),i[1095]||(i[1095]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1097]||(i[1097]=s("p",null,"The shading coordinate system gives a frame for expressing directions in spherical coordinates (θ, ϕ). The angle θ is measured from the given direction to the z-axis and ϕ is the angle formed with the x-axis after projection of the direction onto xy-plane.",-1)),i[1098]||(i[1098]=s("p",null,[a("Since normal is "),s("code",null,"(0, 0, 1) → cos_θ = n · w = (0, 0, 1) ⋅ w = w.z"),a(".")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1096]||(i[1096]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/surface_interaction.jl#L264-L272",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ca,[s("summary",null,[i[1099]||(i[1099]=s("a",{id:"Hikari.create_dda_iterator-Union{Tuple{M}, Tuple{M, Raycore.Bounds3, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32, Hikari.SampledSpectrum{4}}} where M<:Hikari.MajorantGrid",href:"#Hikari.create_dda_iterator-Union{Tuple{M}, Tuple{M, Raycore.Bounds3, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32, Hikari.SampledSpectrum{4}}} where M<:Hikari.MajorantGrid"},[s("span",{class:"jlbinding"},"Hikari.create_dda_iterator")],-1)),i[1100]||(i[1100]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1102]||(i[1102]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">create_dda_iterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(grid, bounds, ray_o, ray_d, t_min, t_max, σ_t) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DDAMajorantIterator</span></span></code></pre></div><p>Initialize a DDA iterator for traversing the majorant grid along a ray. The ray should already be transformed to medium space. t_min and t_max are the ray segment bounds (in medium space).</p><p>Following PBRT-v4&#39;s DDAMajorantIterator constructor.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1101]||(i[1101]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L266-L274",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ba,[s("summary",null,[i[1103]||(i[1103]=s("a",{id:"Hikari.create_light_sampler-Tuple{Raycore.MultiTypeSet}",href:"#Hikari.create_light_sampler-Tuple{Raycore.MultiTypeSet}"},[s("span",{class:"jlbinding"},"Hikari.create_light_sampler")],-1)),i[1104]||(i[1104]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1106]||(i[1106]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">create_light_sampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; method</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Symbol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:power</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, scene_radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LightSampler</span></span></code></pre></div><p>Create a light sampler for the given lights.</p><p><strong>Arguments</strong></p><ul><li><p><code>lights::MultiTypeSet</code>: Collection of light sources</p></li><li><p><code>method::Symbol</code>: Sampling method (<code>:uniform</code> or <code>:power</code>)</p></li><li><p><code>scene_radius::Float32</code>: Scene bounding sphere radius (for power-weighted sampling of infinite lights)</p></li></ul><p><strong>Methods</strong></p><ul><li><p><code>:uniform</code>: Uniform random selection (baseline)</p></li><li><p><code>:power</code>: Power-weighted selection (recommended for varying light intensities)</p></li></ul>',6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1105]||(i[1105]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L546-L559",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ya,[s("summary",null,[i[1107]||(i[1107]=s("a",{id:"Hikari.current_ray_queue-Tuple{Hikari.VolPathState}",href:"#Hikari.current_ray_queue-Tuple{Hikari.VolPathState}"},[s("span",{class:"jlbinding"},"Hikari.current_ray_queue")],-1)),i[1108]||(i[1108]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1110]||(i[1110]=s("p",null,"Get the current ray queue based on the queue selector.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1109]||(i[1109]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath-state.jl#L187",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ma,[s("summary",null,[i[1111]||(i[1111]=s("a",{id:"Hikari.dda_next-Union{Tuple{M}, Tuple{Hikari.DDAMajorantIterator{M}, Any}} where M",href:"#Hikari.dda_next-Union{Tuple{M}, Tuple{Hikari.DDAMajorantIterator{M}, Any}} where M"},[s("span",{class:"jlbinding"},"Hikari.dda_next")],-1)),i[1112]||(i[1112]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1114]||(i[1114]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dda_next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DDAMajorantIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, media) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (RayMajorantSegment, DDAMajorantIterator, Bool)</span></span></code></pre></div><p>Advance the DDA iterator and return the next majorant segment. Returns (seg, new_iter, true) if valid, (invalid_seg, exhausted_iter, false) if exhausted.</p><p>The Bool indicates validity: true = has segment, false = exhausted.</p><p>Since structs are immutable in Julia, this returns a new iterator with updated state. Following PBRT-v4&#39;s DDAMajorantIterator::Next().</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1113]||(i[1113]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L393-L403",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fa,[s("summary",null,[i[1115]||(i[1115]=s("a",{id:"Hikari.denoise!-Tuple{Hikari.Film}",href:"#Hikari.denoise!-Tuple{Hikari.Film}"},[s("span",{class:"jlbinding"},"Hikari.denoise!")],-1)),i[1116]||(i[1116]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1118]||(i[1118]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">denoise!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Film</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DenoiseConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Apply edge-avoiding à-trous wavelet denoising to film&#39;s framebuffer. Uses auxiliary buffers (normal, depth) from film for edge-stopping. Result is stored in film.postprocess.</p><p><strong>Arguments</strong></p><ul><li><p><code>film</code>: Film with framebuffer and auxiliary buffers populated</p></li><li><p><code>config</code>: DenoiseConfig with filter parameters</p></li></ul><p><strong>Notes</strong></p><ul><li><p>Requires film.normal and film.depth to be populated (e.g., via fill_aux_buffers!)</p></li><li><p>Modifies film.postprocess in place</p></li><li><p>For PhysicalWavefront, aux buffers are populated during first bounce</p></li></ul>',6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1117]||(i[1117]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/denoise.jl#L285-L300",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ea,[s("summary",null,[i[1119]||(i[1119]=s("a",{id:"Hikari.denoise_inplace!-Tuple{Hikari.Film}",href:"#Hikari.denoise_inplace!-Tuple{Hikari.Film}"},[s("span",{class:"jlbinding"},"Hikari.denoise_inplace!")],-1)),i[1120]||(i[1120]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1122]||(i[1122]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">denoise_inplace!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Film</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DenoiseConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Like denoise!, but modifies framebuffer directly instead of using postprocess.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1121]||(i[1121]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/denoise.jl#L374-L378",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_a,[s("summary",null,[i[1123]||(i[1123]=s("a",{id:"Hikari.denoise_luminance-Tuple{Float32, Float32, Float32}",href:"#Hikari.denoise_luminance-Tuple{Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.denoise_luminance")],-1)),i[1124]||(i[1124]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1126]||(i[1126]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">denoise_luminance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, g, b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute luminance from RGB using Rec. 709 coefficients.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1125]||(i[1125]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/denoise.jl#L61-L65",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ta,[s("summary",null,[i[1127]||(i[1127]=s("a",{id:"Hikari.detect_camera_medium-Tuple{Any, Any, Any, GeometryBasics.Point{3, Float32}}",href:"#Hikari.detect_camera_medium-Tuple{Any, Any, Any, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.detect_camera_medium")],-1)),i[1128]||(i[1128]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1130]||(i[1130]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">detect_camera_medium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, accel, media_interfaces, camera_pos) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SetKey</span></span></code></pre></div><p>Detect which medium the camera is inside by tracing a single ray from the camera position. Returns a SetKey identifying the medium, or SetKey() for vacuum.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1129]||(i[1129]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L736-L741",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ja,[s("summary",null,[i[1131]||(i[1131]=s("a",{id:"Hikari.direction_to_uv_equal_area-Tuple{GeometryBasics.Vec{3, Float32}, StaticArraysCore.SMatrix{3, 3, Float32, 9}}",href:"#Hikari.direction_to_uv_equal_area-Tuple{GeometryBasics.Vec{3, Float32}, StaticArraysCore.SMatrix{3, 3, Float32, 9}}"},[s("span",{class:"jlbinding"},"Hikari.direction_to_uv_equal_area")],-1)),i[1132]||(i[1132]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1134]||(i[1134]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">direction_to_uv_equal_area</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Mat3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Point2f</span></span></code></pre></div><p>Convert direction to UV using equal-area (octahedral) mapping. This is what pbrt-v4 uses for ImageInfiniteLight.</p><p>The rotation matrix transforms from render space to light/map space.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1133]||(i[1133]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L194-L201",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fa,[s("summary",null,[i[1135]||(i[1135]=s("a",{id:"Hikari.direction_to_uv_equirect-Tuple{GeometryBasics.Vec{3, Float32}, StaticArraysCore.SMatrix{3, 3, Float32, 9}}",href:"#Hikari.direction_to_uv_equirect-Tuple{GeometryBasics.Vec{3, Float32}, StaticArraysCore.SMatrix{3, 3, Float32, 9}}"},[s("span",{class:"jlbinding"},"Hikari.direction_to_uv_equirect")],-1)),i[1136]||(i[1136]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1138]||(i[1138]=s("p",null,"Convert a direction vector to equirectangular UV coordinates. Uses standard lat-long mapping where:",-1)),i[1139]||(i[1139]=s("ul",null,[s("li",null,[s("p",null,"U (horizontal) maps to longitude: 0 at +X, increases counter-clockwise")]),s("li",null,[s("p",null,"V (vertical) maps to latitude: 0 at top (+Y), 1 at bottom (-Y)")])],-1)),i[1140]||(i[1140]=s("p",null,"The rotation matrix transforms from render space to light/map space. We apply the INVERSE (transpose for orthogonal matrices) to get the direction in map space.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1137]||(i[1137]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L233-L241",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ca,[s("summary",null,[i[1141]||(i[1141]=s("a",{id:"Hikari.distribution_fresnel_microfacet-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}} where S<:Hikari.Spectrum",href:"#Hikari.distribution_fresnel_microfacet-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.distribution_fresnel_microfacet")],-1)),i[1142]||(i[1142]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1144]||(i[1144]=s("p",null,"Distribution function for FresnelMicrofacet - sum of reflection and transmission.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1143]||(i[1143]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/microfacet.jl#L353-L355",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",va,[s("summary",null,[i[1145]||(i[1145]=s("a",{id:"Hikari.distribution_lambertian_reflection-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}} where S<:Hikari.Spectrum",href:"#Hikari.distribution_lambertian_reflection-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.distribution_lambertian_reflection")],-1)),i[1146]||(i[1146]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1148]||(i[1148]=s("p",null,"Reflection distribution is constant and divides reflectance spectrum equally over the hemisphere.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1147]||(i[1147]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/lambertian.jl#L13-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ha,[s("summary",null,[i[1149]||(i[1149]=s("a",{id:"Hikari.distribution_specular_reflection-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}} where S<:Hikari.Spectrum",href:"#Hikari.distribution_specular_reflection-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.distribution_specular_reflection")],-1)),i[1150]||(i[1150]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1152]||(i[1152]=s("p",null,"Return value of the distribution function for the given pair of directions. For specular reflection, no scattering is returned, since for arbitrary directions δ-funcion returns no scattering.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1151]||(i[1151]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/specular.jl#L35-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Aa,[s("summary",null,[i[1153]||(i[1153]=s("a",{id:"Hikari.distribution_specular_transmission-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}} where S<:Hikari.Spectrum",href:"#Hikari.distribution_specular_transmission-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.distribution_specular_transmission")],-1)),i[1154]||(i[1154]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1156]||(i[1156]=s("p",null,"Return value of the distribution function for the given pair of directions. For specular transmission, no scattering is returned, since for arbitrary directions δ-funcion returns no scattering.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1155]||(i[1155]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/specular.jl#L58-L62",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Sa,[s("summary",null,[i[1157]||(i[1157]=s("a",{id:"Hikari.encode_morton2-Tuple{UInt32, UInt32}",href:"#Hikari.encode_morton2-Tuple{UInt32, UInt32}"},[s("span",{class:"jlbinding"},"Hikari.encode_morton2")],-1)),i[1158]||(i[1158]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1160]||(i[1160]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">encode_morton2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt64</span></span></code></pre></div><p>Encode two 32-bit coordinates into a single 64-bit Morton code. Reference: pbrt-v4/src/pbrt/util/vecmath.h EncodeMorton2</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1159]||(i[1159]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L52-L57",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xa,[s("summary",null,[i[1161]||(i[1161]=s("a",{id:"Hikari.equal_area_sphere_to_square-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.equal_area_sphere_to_square-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.equal_area_sphere_to_square")],-1)),i[1162]||(i[1162]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1164]||(i[1164]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">equal_area_sphere_to_square</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Point2f</span></span></code></pre></div><p>Convert a direction vector to equal-area square UV coordinates. This is pbrt-v4&#39;s octahedral/equal-area mapping used for environment maps.</p><p>Reference: Clarberg, &quot;Fast Equal-Area Mapping of the (Hemi)Sphere using SIMD&quot;</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1163]||(i[1163]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L70-L77",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ba,[s("summary",null,[i[1165]||(i[1165]=s("a",{id:"Hikari.equal_area_square_to_sphere-Tuple{GeometryBasics.Point{2, Float32}}",href:"#Hikari.equal_area_square_to_sphere-Tuple{GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.equal_area_square_to_sphere")],-1)),i[1166]||(i[1166]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1168]||(i[1168]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">equal_area_square_to_sphere</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Convert equal-area square UV coordinates to a direction vector. Inverse of equal_area_sphere_to_square.</p><p>Reference: pbrt-v4&#39;s EqualAreaSquareToSphere</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1167]||(i[1167]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L125-L132",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Da,[s("summary",null,[i[1169]||(i[1169]=s("a",{id:"Hikari.estimate_light_power-Tuple{Hikari.Light, Float32}",href:"#Hikari.estimate_light_power-Tuple{Hikari.Light, Float32}"},[s("span",{class:"jlbinding"},"Hikari.estimate_light_power")],-1)),i[1170]||(i[1170]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1172]||(i[1172]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">estimate_light_power</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(light, scene_radius</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Estimate the total power (flux) of a light for importance sampling. Following pbrt-v4&#39;s Light::Phi() which returns total emitted power.</p><p>For point/spot lights: Phi = 4π * I (or 2π * I * cone_factor for spot) For directional lights: Phi = π * sceneRadius² * I For environment lights: Phi = 4π² * sceneRadius² * average_radiance</p><p>The scene_radius is required for infinite lights to compute meaningful power.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1171]||(i[1171]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L369-L380",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ia,[s("summary",null,[i[1173]||(i[1173]=s("a",{id:"Hikari.eval_dielectric_interface-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32, Float32}",href:"#Hikari.eval_dielectric_interface-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.eval_dielectric_interface")],-1)),i[1174]||(i[1174]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1176]||(i[1176]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eval_dielectric_interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, wi, alpha_x, alpha_y, eta) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f, pdf)</span></span></code></pre></div><p>Evaluate the dielectric interface BSDF for given directions. Returns (f_value, pdf) for the given wo/wi pair.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1175]||(i[1175]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1420-L1425",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ma,[s("summary",null,[i[1177]||(i[1177]=s("a",{id:"Hikari.eval_diffuse_interface-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.SampledSpectrum{4}}",href:"#Hikari.eval_diffuse_interface-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.SampledSpectrum{4}}"},[s("span",{class:"jlbinding"},"Hikari.eval_diffuse_interface")],-1)),i[1178]||(i[1178]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1180]||(i[1180]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">eval_diffuse_interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, wi, reflectance) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f, pdf)</span></span></code></pre></div><p>Evaluate diffuse BSDF for given directions.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1179]||(i[1179]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1173-L1177",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ga,[s("summary",null,[i[1181]||(i[1181]=s("a",{id:"Hikari.eval_sigmoid_polynomial-NTuple{4, Float32}",href:"#Hikari.eval_sigmoid_polynomial-NTuple{4, Float32}"},[s("span",{class:"jlbinding"},"Hikari.eval_sigmoid_polynomial")],-1)),i[1182]||(i[1182]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1184]||(i[1184]=s("p",null,"Evaluate sigmoid polynomial at wavelength (GPU-compatible)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1183]||(i[1183]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L265",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Pa,[s("summary",null,[i[1185]||(i[1185]=s("a",{id:"Hikari.evaluate_bsdf_spectral-Tuple{Hikari.CoatedConductorMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_bsdf_spectral-Tuple{Hikari.CoatedConductorMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_bsdf_spectral")],-1)),i[1186]||(i[1186]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1188]||(i[1188]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, wi, n, uv, lambda) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f, pdf)</span></span></code></pre></div><p>Evaluate CoatedConductor BSDF for given directions.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1187]||(i[1187]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3238-L3242",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Va,[s("summary",null,[i[1189]||(i[1189]=s("a",{id:"Hikari.evaluate_bsdf_spectral-Tuple{Hikari.CoatedDiffuseMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_bsdf_spectral-Tuple{Hikari.CoatedDiffuseMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_bsdf_spectral")],-1)),i[1190]||(i[1190]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1192]||(i[1192]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedDiffuseMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, wi, n, uv, lambda) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f, pdf)</span></span></code></pre></div><p>Evaluate CoatedDiffuse BSDF using pbrt-v4&#39;s LayeredBxDF::f random walk algorithm.</p><p>This is a 100% port of pbrt-v4&#39;s LayeredBxDF::f. The algorithm uses nSamples random walks to estimate the BSDF value using Monte Carlo integration with MIS.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1191]||(i[1191]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1556-L1563",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",La,[s("summary",null,[i[1193]||(i[1193]=s("a",{id:"Hikari.evaluate_bsdf_spectral-Tuple{Hikari.ConductorMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_bsdf_spectral-Tuple{Hikari.ConductorMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_bsdf_spectral")],-1)),i[1194]||(i[1194]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1196]||(i[1196]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f, pdf)</span></span></code></pre></div><p>Evaluate metal BSDF for given directions. Matches pbrt-v4&#39;s ConductorBxDF::f and ConductorBxDF::PDF exactly.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1195]||(i[1195]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L415-L420",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",wa,[s("summary",null,[i[1197]||(i[1197]=s("a",{id:"Hikari.evaluate_bsdf_spectral-Tuple{Hikari.DiffuseTransmissionMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_bsdf_spectral-Tuple{Hikari.DiffuseTransmissionMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_bsdf_spectral")],-1)),i[1198]||(i[1198]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1200]||(i[1200]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiffuseTransmissionMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, wi, n, uv, lambda) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f, pdf)</span></span></code></pre></div><p>Evaluate diffuse transmission BSDF matching pbrt-v4&#39;s DiffuseTransmissionBxDF::f and PDF.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1199]||(i[1199]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L2167-L2171",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ra,[s("summary",null,[i[1201]||(i[1201]=s("a",{id:"Hikari.evaluate_bsdf_spectral-Tuple{Hikari.MatteMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_bsdf_spectral-Tuple{Hikari.MatteMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_bsdf_spectral")],-1)),i[1202]||(i[1202]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1204]||(i[1204]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat, textures, wo, wi, n, uv, lambda) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpectralRadiance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pdf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Evaluate BSDF for a given pair of directions. Used for MIS in direct lighting. Returns the BSDF value and PDF.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1203]||(i[1203]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L365-L370",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Na,[s("summary",null,[i[1205]||(i[1205]=s("a",{id:"Hikari.evaluate_bsdf_spectral-Tuple{Hikari.MediumInterface, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_bsdf_spectral-Tuple{Hikari.MediumInterface, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_bsdf_spectral")],-1)),i[1206]||(i[1206]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1208]||(i[1208]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">evaluate_bsdf_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MediumInterface </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> forwards to wrapped material.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1207]||(i[1207]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3468-L3470",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Oa,[s("summary",null,[i[1209]||(i[1209]=s("a",{id:"Hikari.evaluate_bsdf_spectral-Tuple{Hikari.ThinDielectricMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_bsdf_spectral-Tuple{Hikari.ThinDielectricMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_bsdf_spectral")],-1)),i[1210]||(i[1210]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1212]||(i[1212]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ThinDielectricMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, wi, n, uv, lambda) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f, pdf)</span></span></code></pre></div><p>Evaluate thin dielectric BSDF - returns zero for non-delta directions. ThinDielectric is purely specular, so f() and PDF() both return 0.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1211]||(i[1211]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L2039-L2044",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ja,[s("summary",null,[i[1213]||(i[1213]=s("a",{id:"Hikari.evaluate_environment_spectral-Tuple{Hikari.AmbientLight, Any, Hikari.RGBToSpectrumTable, GeometryBasics.Vec{3, Float32}, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_environment_spectral-Tuple{Hikari.AmbientLight, Any, Hikari.RGBToSpectrumTable, GeometryBasics.Vec{3, Float32}, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_environment_spectral")],-1)),i[1214]||(i[1214]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1216]||(i[1216]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_environment_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AmbientLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lights, table, ray_d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Evaluate ambient light for an escaped ray - provides constant radiance regardless of direction.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1215]||(i[1215]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L422-L426",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Wa,[s("summary",null,[i[1217]||(i[1217]=s("a",{id:"Hikari.evaluate_environment_spectral-Tuple{Hikari.EnvironmentLight, Any, Hikari.RGBToSpectrumTable, GeometryBasics.Vec{3, Float32}, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_environment_spectral-Tuple{Hikari.EnvironmentLight, Any, Hikari.RGBToSpectrumTable, GeometryBasics.Vec{3, Float32}, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_environment_spectral")],-1)),i[1218]||(i[1218]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1220]||(i[1220]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_environment_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EnvironmentLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lights, table, ray_d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Evaluate environment light for an escaped ray direction. The <code>lights</code> parameter is used to deref TextureRef fields in EnvironmentMap.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1219]||(i[1219]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L402-L407",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ua,[s("summary",null,[i[1221]||(i[1221]=s("a",{id:"Hikari.evaluate_escaped_ray_spectral-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, GeometryBasics.Vec{3, Float32}, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_escaped_ray_spectral-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, GeometryBasics.Vec{3, Float32}, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_escaped_ray_spectral")],-1)),i[1222]||(i[1222]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1224]||(i[1224]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_escaped_ray_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, lights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ray_d, lambda)</span></span></code></pre></div><p>Evaluate all environment-type lights for an escaped ray using StaticMultiTypeSet.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1223]||(i[1223]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L438-L442",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",qa,[s("summary",null,[i[1225]||(i[1225]=s("a",{id:"Hikari.evaluate_material_complete",href:"#Hikari.evaluate_material_complete"},[s("span",{class:"jlbinding"},"Hikari.evaluate_material_complete")],-1)),i[1226]||(i[1226]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[1228]||(i[1228]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_material_complete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat, table, ctx, wo, ns, n, tfc, lambda, u, rng, regularize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Complete material evaluation for wavefront pipeline. Returns PWMaterialEvalResult with BSDF sample and emission.</p><p>When <code>regularize=true</code>, near-specular BSDFs will be roughened to reduce fireflies.</p><p>Arguments:</p><ul><li><code>tfc::TextureFilterContext</code>: Contains UV coordinates and screen-space derivatives for texture filtering.</li></ul>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1227]||(i[1227]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L170-L180",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",za,[s("summary",null,[i[1229]||(i[1229]=s("a",{id:"Hikari.evaluate_material_inner!-Tuple{Any, Hikari.VPMaterialEvalWorkItem, Any, Any, Int32, Bool, Any, Any, Any, Any, Int32}",href:"#Hikari.evaluate_material_inner!-Tuple{Any, Hikari.VPMaterialEvalWorkItem, Any, Any, Int32, Bool, Any, Any, Any, Any, Int32}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_material_inner!")],-1)),i[1230]||(i[1230]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1232]||(i[1232]=s("p",null,"Inner function for material evaluation - can use return statements.",-1)),i[1233]||(i[1233]=s("p",null,"Now uses pre-computed Sobol samples from pixel_samples (pbrt-v4 RaySamples style).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1231]||(i[1231]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/surface-eval.jl#L392-L396",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ka,[s("summary",null,[i[1234]||(i[1234]=s("a",{id:"Hikari.evaluate_spectral_material-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.evaluate_spectral_material-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.evaluate_spectral_material")],-1)),i[1235]||(i[1235]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1237]||(i[1237]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">evaluate_spectral_material</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx, wo, wi, ns, tfc, lambda)</span></span></code></pre></div><p>Type-stable dispatch for spectral BSDF evaluation. Returns (f::SpectralRadiance, pdf::Float32).</p><p>Arguments:</p><ul><li><code>tfc::TextureFilterContext</code>: Contains UV coordinates and screen-space derivatives for texture filtering.</li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1236]||(i[1236]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L37-L45",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Za,[s("summary",null,[i[1238]||(i[1238]=s("a",{id:"Hikari.extinction_at-Tuple{Hikari.CloudVolume, GeometryBasics.Point{3, Float32}}",href:"#Hikari.extinction_at-Tuple{Hikari.CloudVolume, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.extinction_at")],-1)),i[1239]||(i[1239]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1241]||(i[1241]=s("p",null,"Get extinction coefficient at a world position",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1240]||(i[1240]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L119",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xa,[s("summary",null,[i[1242]||(i[1242]=s("a",{id:"Hikari.extract_nanovdb_metadata-Tuple{Vector{UInt8}}",href:"#Hikari.extract_nanovdb_metadata-Tuple{Vector{UInt8}}"},[s("span",{class:"jlbinding"},"Hikari.extract_nanovdb_metadata")],-1)),i[1243]||(i[1243]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1245]||(i[1245]=s("p",null,"Extract metadata from decompressed NanoVDB buffer",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1244]||(i[1244]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L1108",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ya,[s("summary",null,[i[1246]||(i[1246]=s("a",{id:"Hikari.extract_sky_color-Tuple{Any}",href:"#Hikari.extract_sky_color-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.extract_sky_color")],-1)),i[1247]||(i[1247]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1249]||(i[1249]=s("p",null,"Extract sky color from scene lights. Returns RGB for background rays.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1248]||(i[1248]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/fast-wavefront.jl#L778-L780",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Qa,[s("summary",null,[i[1250]||(i[1250]=s("a",{id:"Hikari.face_forward-Tuple{Any, Any}",href:"#Hikari.face_forward-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.face_forward")],-1)),i[1251]||(i[1251]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1253]||(i[1253]=s("p",null,[a("Flip normal "),s("code",null,"n"),a(" so that it lies in the same hemisphere as "),s("code",null,"v"),a(".")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1252]||(i[1252]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/surface_interaction.jl#L303-L305",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$a,[s("summary",null,[i[1254]||(i[1254]=s("a",{id:"Hikari.face_forward-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.face_forward-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.face_forward")],-1)),i[1255]||(i[1255]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1257]||(i[1257]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">face_forward</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v, n) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Flip v to be in the same hemisphere as n (matches pbrt-v4&#39;s FaceForward).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1256]||(i[1256]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3868-L3872",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",il,[s("summary",null,[i[1258]||(i[1258]=s("a",{id:"Hikari.fast_owen_scramble-Tuple{UInt32, UInt32}",href:"#Hikari.fast_owen_scramble-Tuple{UInt32, UInt32}"},[s("span",{class:"jlbinding"},"Hikari.fast_owen_scramble")],-1)),i[1259]||(i[1259]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1261]||(i[1261]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fast_owen_scramble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, seed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt32</span></span></code></pre></div><p>Fast approximation of Owen scrambling for Sobol sequences. Reference: pbrt-v4/src/pbrt/util/lowdiscrepancy.h FastOwenScrambler (lines 220-237)</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1260]||(i[1260]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L66-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",sl,[s("summary",null,[i[1262]||(i[1262]=s("a",{id:"Hikari.fbm3d-Tuple{Any, Any, Any}",href:"#Hikari.fbm3d-Tuple{Any, Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.fbm3d")],-1)),i[1263]||(i[1263]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1265]||(i[1265]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fbm3d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y, z; octaves</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, persistence</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float64</span></span></code></pre></div><p>Fractional Brownian motion (fBm) using Perlin noise. Combines multiple octaves of noise at different frequencies for natural-looking detail.</p><p><strong>Arguments</strong></p><ul><li><p><code>x, y, z</code>: 3D coordinates</p></li><li><p><code>octaves</code>: Number of noise layers to combine (default: 4)</p></li><li><p><code>persistence</code>: Amplitude multiplier per octave (default: 0.5)</p></li></ul><p>Returns values approximately in [-1, 1].</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1264]||(i[1264]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/random.jl#L50-L62",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",el,[s("summary",null,[i[1266]||(i[1266]=s("a",{id:"Hikari.fill_aux_buffers!-Tuple{Hikari.Film, Any, Any}",href:"#Hikari.fill_aux_buffers!-Tuple{Hikari.Film, Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.fill_aux_buffers!")],-1)),i[1267]||(i[1267]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1269]||(i[1269]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fill_aux_buffers!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film, scene, camera)</span></span></code></pre></div><p>Fill auxiliary buffers (albedo, normal, depth) by tracing primary rays. Uses KernelAbstractions for GPU compatibility.</p><p>This traces one ray per pixel (center of pixel) and stores first-hit data. Should be called before or after main rendering - the auxiliary buffers are used for denoising in postprocess!.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1268]||(i[1268]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/film.jl#L400-L409",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",tl,[s("summary",null,[i[1270]||(i[1270]=s("a",{id:"Hikari.filter_evaluate-Tuple{Hikari.GPUFilterParams, GeometryBasics.Point{2, Float32}}",href:"#Hikari.filter_evaluate-Tuple{Hikari.GPUFilterParams, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.filter_evaluate")],-1)),i[1271]||(i[1271]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1273]||(i[1273]=s("p",null,"Evaluate filter at point p.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1272]||(i[1272]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L955-L957",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",al,[s("summary",null,[i[1274]||(i[1274]=s("a",{id:"Hikari.filter_sample-Tuple{Hikari.BoxFilter, GeometryBasics.Point{2, Float32}}",href:"#Hikari.filter_sample-Tuple{Hikari.BoxFilter, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.filter_sample")],-1)),i[1275]||(i[1275]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1277]||(i[1277]=s("p",null,"Sample the box filter - uniform distribution with weight = 1.0",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1276]||(i[1276]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L55-L57",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ll,[s("summary",null,[i[1278]||(i[1278]=s("a",{id:"Hikari.filter_sample-Tuple{Hikari.GPUFilterParams, GeometryBasics.Point{2, Float32}}",href:"#Hikari.filter_sample-Tuple{Hikari.GPUFilterParams, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.filter_sample")],-1)),i[1279]||(i[1279]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1281]||(i[1281]=s("p",null,"Sample filter - uses analytical sampling where possible, tabulated importance sampling for Gaussian/Mitchell/Lanczos.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1280]||(i[1280]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L872-L875",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",nl,[s("summary",null,[i[1282]||(i[1282]=s("a",{id:"Hikari.filter_sample-Tuple{Hikari.GPUFilterParams, Hikari.GPUFilterSamplerData, GeometryBasics.Point{2, Float32}}",href:"#Hikari.filter_sample-Tuple{Hikari.GPUFilterParams, Hikari.GPUFilterSamplerData, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.filter_sample")],-1)),i[1283]||(i[1283]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1285]||(i[1285]=s("p",null,"Sample filter with tabulated data for importance sampling. Overload for when sampler_data is GPUFilterSamplerData (Gaussian/Mitchell/Lanczos).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1284]||(i[1284]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L922-L925",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",rl,[s("summary",null,[i[1286]||(i[1286]=s("a",{id:"Hikari.filter_sample-Tuple{Hikari.GPUFilterParams, Nothing, GeometryBasics.Point{2, Float32}}",href:"#Hikari.filter_sample-Tuple{Hikari.GPUFilterParams, Nothing, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.filter_sample")],-1)),i[1287]||(i[1287]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1289]||(i[1289]=s("p",null,"Sample filter with tabulated data for importance sampling. Overload for when sampler_data is nothing (Box/Triangle filters).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1288]||(i[1288]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L909-L912",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",pl,[s("summary",null,[i[1290]||(i[1290]=s("a",{id:"Hikari.filter_sample-Tuple{Hikari.TriangleFilter, GeometryBasics.Point{2, Float32}}",href:"#Hikari.filter_sample-Tuple{Hikari.TriangleFilter, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.filter_sample")],-1)),i[1291]||(i[1291]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1293]||(i[1293]=s("p",null,"Sample the triangle filter - analytical importance sampling with weight = 1.0",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1292]||(i[1292]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L117-L119",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ol,[s("summary",null,[i[1294]||(i[1294]=s("a",{id:"Hikari.filter_sample_tabulated-Tuple{Hikari.GPUFilterSamplerData, GeometryBasics.Point{2, Float32}}",href:"#Hikari.filter_sample_tabulated-Tuple{Hikari.GPUFilterSamplerData, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.filter_sample_tabulated")],-1)),i[1295]||(i[1295]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1297]||(i[1297]=s("p",null,"Sample filter using tabulated importance sampling (pbrt-v4 compatible). This is used for Gaussian, Mitchell, and Lanczos filters. Returns FilterSample with position and weight = f[sampled_point] / pdf.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1296]||(i[1296]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L829-L833",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",dl,[s("summary",null,[i[1298]||(i[1298]=s("a",{id:"Hikari.finalize_soa-Tuple{NamedTuple}",href:"#Hikari.finalize_soa-Tuple{NamedTuple}"},[s("span",{class:"jlbinding"},"Hikari.finalize_soa")],-1)),i[1299]||(i[1299]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1301]||(i[1301]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">finalize_soa</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(soa</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NamedTuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Finalize all arrays in a SoA (Structure of Arrays) NamedTuple.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1300]||(i[1300]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/fast-wavefront.jl#L714-L718",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",kl,[s("summary",null,[i[1302]||(i[1302]=s("a",{id:"Hikari.find_interval-Tuple{AbstractVector{Float32}, Float32, Int32}",href:"#Hikari.find_interval-Tuple{AbstractVector{Float32}, Float32, Int32}"},[s("span",{class:"jlbinding"},"Hikari.find_interval")],-1)),i[1303]||(i[1303]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1305]||(i[1305]=s("p",null,"Binary search in CDF to find interval containing u. Returns index o such that cdf[o] <= u < cdf[o+1] (1-based indexing). CDF has size n+1 with cdf[1]=0 and cdf[n+1]=1. GPU-compatible fully unrolled branchless implementation.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1304]||(i[1304]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L727-L732",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",hl,[s("summary",null,[i[1306]||(i[1306]=s("a",{id:"Hikari.find_interval_binary-Tuple{Any, Float32}",href:"#Hikari.find_interval_binary-Tuple{Any, Float32}"},[s("span",{class:"jlbinding"},"Hikari.find_interval_binary")],-1)),i[1307]||(i[1307]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1309]||(i[1309]=s("p",null,"GPU-compatible binary search to find last index where cdf[i] ≤ u. Returns index in [1, n] where n = length(cdf).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1308]||(i[1308]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sampling.jl#L110-L113",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ul,[s("summary",null,[i[1310]||(i[1310]=s("a",{id:"Hikari.find_interval_binary_col-Tuple{AbstractMatrix{Float32}, Int32, Float32}",href:"#Hikari.find_interval_binary_col-Tuple{AbstractMatrix{Float32}, Int32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.find_interval_binary_col")],-1)),i[1311]||(i[1311]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1313]||(i[1313]=s("p",null,"Binary search in a column of a 2D array (for conditional CDF).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1312]||(i[1312]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sampling.jl#L313-L315",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",gl,[s("summary",null,[i[1314]||(i[1314]=s("a",{id:"Hikari.find_interval_binary_flat-Tuple{AbstractVector{Float32}, Float32}",href:"#Hikari.find_interval_binary_flat-Tuple{AbstractVector{Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.find_interval_binary_flat")],-1)),i[1315]||(i[1315]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1317]||(i[1317]=s("p",null,"GPU-compatible fully unrolled branchless binary search in a flat vector (for marginal CDF).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1316]||(i[1316]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sampling.jl#L330-L332",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",cl,[s("summary",null,[i[1318]||(i[1318]=s("a",{id:"Hikari.flat_to_light_index-Union{Tuple{Textures}, Tuple{Data}, Tuple{Raycore.StaticMultiTypeSet{Data, Textures}, Int32}} where {Data<:Tuple, Textures}",href:"#Hikari.flat_to_light_index-Union{Tuple{Textures}, Tuple{Data}, Tuple{Raycore.StaticMultiTypeSet{Data, Textures}, Int32}} where {Data<:Tuple, Textures}"},[s("span",{class:"jlbinding"},"Hikari.flat_to_light_index")],-1)),i[1319]||(i[1319]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1321]||(i[1321]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flat_to_light_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, flat_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SetKey</span></span></code></pre></div><p>Convert a flat 1-based index to a SetKey (SetKey) for StaticMultiTypeSet. The flat index counts across all typed arrays in order.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1320]||(i[1320]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L283-L288",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",bl,[s("summary",null,[i[1322]||(i[1322]=s("a",{id:"Hikari.float32_to_bytes-Tuple{Float32}",href:"#Hikari.float32_to_bytes-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.float32_to_bytes")],-1)),i[1323]||(i[1323]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1325]||(i[1325]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float32_to_bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NTuple{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,UInt8}</span></span></code></pre></div><p>GPU-compatible conversion of Float32 to bytes using Core.bitcast.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1324]||(i[1324]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L650-L654",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",yl,[s("summary",null,[i[1326]||(i[1326]=s("a",{id:"Hikari.fr_complex-Tuple{Float32, Float32, Float32}",href:"#Hikari.fr_complex-Tuple{Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.fr_complex")],-1)),i[1327]||(i[1327]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1329]||(i[1329]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fr_complex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cos_theta_i, eta, k) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute Fresnel reflectance for a conductor using complex IOR (matches pbrt-v4&#39;s FrComplex).</p><p>Arguments:</p><ul><li><p><code>cos_theta_i</code>: Cosine of incident angle (clamped to [0, 1])</p></li><li><p><code>eta</code>: Real part of complex IOR (n)</p></li><li><p><code>k</code>: Imaginary part of complex IOR (extinction coefficient)</p></li></ul><p>This uses the exact same formula as pbrt-v4 with complex arithmetic.</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1328]||(i[1328]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3651-L3662",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ml,[s("summary",null,[i[1330]||(i[1330]=s("a",{id:"Hikari.fr_complex_spectral-Tuple{Float32, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}}",href:"#Hikari.fr_complex_spectral-Tuple{Float32, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}}"},[s("span",{class:"jlbinding"},"Hikari.fr_complex_spectral")],-1)),i[1331]||(i[1331]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1333]||(i[1333]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fr_complex_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cos_theta_i, eta, k) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Compute spectral Fresnel reflectance for a conductor (matches pbrt-v4&#39;s FrComplex for SampledSpectrum). Evaluates fr_complex for each wavelength channel.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1332]||(i[1332]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3741-L3746",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fl,[s("summary",null,[i[1334]||(i[1334]=s("a",{id:"Hikari.free!-Tuple{Hikari.Film}",href:"#Hikari.free!-Tuple{Hikari.Film}"},[s("span",{class:"jlbinding"},"Hikari.free!")],-1)),i[1335]||(i[1335]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1337]||(i[1337]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">free!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Film</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Release GPU memory held by the film by triggering finalizers on all arrays.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1336]||(i[1336]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/film.jl#L491-L495",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",El,[s("summary",null,[i[1338]||(i[1338]=s("a",{id:"Hikari.fresnel_conductor-Union{Tuple{S}, Tuple{Float32, S, S, S}} where S<:Hikari.Spectrum",href:"#Hikari.fresnel_conductor-Union{Tuple{S}, Tuple{Float32, S, S, S}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.fresnel_conductor")],-1)),i[1339]||(i[1339]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1341]||(i[1341]=s("p",null,"General Fresnel reflection formula with complex index of refraction η^ = η + ik, where some incident light is potentially absorbed by the material and turned into heat. k - is referred to as the absorption coefficient.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1340]||(i[1340]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/bxdf.jl#L107-L111",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_l,[s("summary",null,[i[1342]||(i[1342]=s("a",{id:"Hikari.fresnel_dielectric-Tuple{Float32, Float32, Float32}",href:"#Hikari.fresnel_dielectric-Tuple{Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.fresnel_dielectric")],-1)),i[1343]||(i[1343]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1345]||(i[1345]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fresnel_dielectric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cos_θi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ηi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ηt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute Fresnel reflection for dielectric materials (two-IOR version). This is a convenience wrapper that computes eta = ηt / ηi.</p><p>Arguments:</p><ul><li><p><code>cos_θi</code>: Cosine of incident angle w.r.t. normal</p></li><li><p><code>ηi</code>: Index of refraction for the incident media</p></li><li><p><code>ηt</code>: Index of refraction for the transmitted media</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1344]||(i[1344]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/bxdf.jl#L92-L102",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Tl,[s("summary",null,[i[1346]||(i[1346]=s("a",{id:"Hikari.fresnel_dielectric-Tuple{Float32, Float32}",href:"#Hikari.fresnel_dielectric-Tuple{Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.fresnel_dielectric")],-1)),i[1347]||(i[1347]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1349]||(i[1349]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">fresnel_dielectric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cos_θi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, eta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute Fresnel reflection for dielectric materials (single-eta version). This matches pbrt-v4&#39;s FrDielectric() exactly.</p><p>Arguments:</p><ul><li><p><code>cos_θi</code>: Cosine of incident angle (can be negative if coming from inside)</p></li><li><p><code>eta</code>: Ratio n_t / n_i (transmitted IOR / incident IOR)</p></li></ul><p>For a ray hitting glass from air: eta = 1.5 (glass IOR) For a ray hitting air from inside glass: eta = 1/1.5</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1348]||(i[1348]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/bxdf.jl#L54-L66",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",jl,[s("summary",null,[i[1350]||(i[1350]=s("a",{id:"Hikari.generate_cloud_density-Tuple{Int64}",href:"#Hikari.generate_cloud_density-Tuple{Int64}"},[s("span",{class:"jlbinding"},"Hikari.generate_cloud_density")],-1)),i[1351]||(i[1351]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1353]||(i[1353]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">generate_cloud_density</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resolution; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Array{Float32, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Generate a 3D density grid for volumetric cloud rendering.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>scale=4.0</code>: Base frequency scale for noise</p></li><li><p><code>sphere_falloff=true</code>: Apply spherical boundary mask</p></li><li><p><code>threshold=0.3</code>: Density threshold (negative values include more volume)</p></li><li><p><code>worley_weight=0.6</code>: Weight of Worley noise (0-1, higher = puffier clouds)</p></li><li><p><code>edge_sharpness=1.5</code>: Controls edge falloff (lower = softer, puffier edges)</p></li><li><p><code>density_scale=3.0</code>: Scale factor for final density (match real cloud data ~2-3 max)</p></li></ul><p><strong>Cloud Appearance Tips</strong></p><ul><li><p>For puffy cumulus-like clouds: scale=2.5, worley_weight=0.6, threshold=0.15, density_scale=3.5</p></li><li><p>For wispy cirrus-like clouds: scale=5.0, worley_weight=0.3, threshold=0.3, density_scale=2.0</p></li><li><p>For dense fog-like volumes: scale=3.0, worley_weight=0.2, threshold=0.0, density_scale=4.0</p></li></ul>',6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1352]||(i[1352]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/random.jl#L131-L148",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fl,[s("summary",null,[i[1354]||(i[1354]=s("a",{id:"Hikari.generate_ray-Union{Tuple{C}, Tuple{C, Hikari.CameraSample}} where C<:Hikari.Camera",href:"#Hikari.generate_ray-Union{Tuple{C}, Tuple{C, Hikari.CameraSample}} where C<:Hikari.Camera"},[s("span",{class:"jlbinding"},"Hikari.generate_ray")],-1)),i[1355]||(i[1355]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1357]||(i[1357]=s("p",null,"Compute the ray corresponding to a given sample. It is IMPORTANT that the direction vector of ray is normalized. Other parts of the system assume it to be so.",-1)),i[1358]||(i[1358]=s("p",null,"Returns generated ray & floating point that affects how much the radiance, arriving at the film plane along generated ray, contributes to the final image. Simple camera models can return 1, but cameras with simulated physical lenses set this value to indicate how much light carries through the lenses, based on their optical properties.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1356]||(i[1356]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/camera/camera.jl#L36-L46",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Cl,[s("summary",null,[i[1359]||(i[1359]=s("a",{id:"Hikari.generate_ray_differential-Union{Tuple{C}, Tuple{C, Hikari.CameraSample}} where C<:Hikari.Camera",href:"#Hikari.generate_ray_differential-Union{Tuple{C}, Tuple{C, Hikari.CameraSample}} where C<:Hikari.Camera"},[s("span",{class:"jlbinding"},"Hikari.generate_ray_differential")],-1)),i[1360]||(i[1360]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1362]||(i[1362]=s("p",null,[a("Same as "),s("code",null,"generate_ray"),a(", but also computes rays for pixels shifted one pixel in x & y directions on the film plane. Useful for anti-aliasing textures.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1361]||(i[1361]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/camera/camera.jl#L52-L56",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",vl,[s("summary",null,[i[1363]||(i[1363]=s("a",{id:"Hikari.get_albedo-Tuple{Hikari.Emissive, GeometryBasics.Point{2, Float32}}",href:"#Hikari.get_albedo-Tuple{Hikari.Emissive, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.get_albedo")],-1)),i[1364]||(i[1364]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1366]||(i[1366]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_albedo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, uv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBSpectrum</span></span></code></pre></div><p>Get the &quot;albedo&quot; of an emissive material for denoising. For emissive materials, we return the normalized emission color.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1365]||(i[1365]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/emissive.jl#L157-L162",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Hl,[s("summary",null,[i[1367]||(i[1367]=s("a",{id:"Hikari.get_albedo_spectral-Tuple{Hikari.CoatedConductorMaterial, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_albedo_spectral-Tuple{Hikari.CoatedConductorMaterial, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_albedo_spectral")],-1)),i[1368]||(i[1368]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1370]||(i[1370]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get_albedo_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CoatedConductorMaterial.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1369]||(i[1369]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3432-L3434",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Al,[s("summary",null,[i[1371]||(i[1371]=s("a",{id:"Hikari.get_albedo_spectral-Tuple{Hikari.CoatedDiffuseMaterial, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_albedo_spectral-Tuple{Hikari.CoatedDiffuseMaterial, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_albedo_spectral")],-1)),i[1372]||(i[1372]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1374]||(i[1374]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get_albedo_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CoatedDiffuseMaterial.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1373]||(i[1373]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1949-L1951",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Sl,[s("summary",null,[i[1375]||(i[1375]=s("a",{id:"Hikari.get_albedo_spectral-Tuple{Hikari.DiffuseTransmissionMaterial, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_albedo_spectral-Tuple{Hikari.DiffuseTransmissionMaterial, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_albedo_spectral")],-1)),i[1376]||(i[1376]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1378]||(i[1378]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get_albedo_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DiffuseTransmissionMaterial.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1377]||(i[1377]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L2230-L2232",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xl,[s("summary",null,[i[1379]||(i[1379]=s("a",{id:"Hikari.get_albedo_spectral-Tuple{Hikari.MatteMaterial, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_albedo_spectral-Tuple{Hikari.MatteMaterial, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_albedo_spectral")],-1)),i[1380]||(i[1380]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1382]||(i[1382]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_albedo_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mat, textures, uv, lambda) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Extract material albedo as spectral value for denoising auxiliary buffers.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1381]||(i[1381]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L529-L533",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Bl,[s("summary",null,[i[1383]||(i[1383]=s("a",{id:"Hikari.get_albedo_spectral-Tuple{Hikari.MediumInterface, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_albedo_spectral-Tuple{Hikari.MediumInterface, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_albedo_spectral")],-1)),i[1384]||(i[1384]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1386]||(i[1386]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get_albedo_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MediumInterface </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> forwards to wrapped material.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1385]||(i[1385]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3496-L3498",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Dl,[s("summary",null,[i[1387]||(i[1387]=s("a",{id:"Hikari.get_albedo_spectral-Tuple{Hikari.ThinDielectricMaterial, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_albedo_spectral-Tuple{Hikari.ThinDielectricMaterial, Hikari.RGBToSpectrumTable, Any, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_albedo_spectral")],-1)),i[1388]||(i[1388]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1390]||(i[1390]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get_albedo_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThinDielectricMaterial </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> returns white (transparent)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1389]||(i[1389]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L2063-L2065",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Il,[s("summary",null,[i[1391]||(i[1391]=s("a",{id:"Hikari.get_albedo_spectral_dispatch-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Raycore.SetKey, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_albedo_spectral_dispatch-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Raycore.SetKey, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_albedo_spectral_dispatch")],-1)),i[1392]||(i[1392]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1394]||(i[1394]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_albedo_spectral_dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx, tfc, lambda)</span></span></code></pre></div><p>Type-stable dispatch for getting material albedo for denoising. Returns SpectralRadiance.</p><p>Arguments:</p><ul><li><code>tfc::TextureFilterContext</code>: Contains UV coordinates and screen-space derivatives for texture filtering.</li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1393]||(i[1393]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L125-L133",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ml,[s("summary",null,[i[1395]||(i[1395]=s("a",{id:"Hikari.get_emission-Tuple{Hikari.Emissive, GeometryBasics.Point{2, Float32}}",href:"#Hikari.get_emission-Tuple{Hikari.Emissive, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.get_emission")],-1)),i[1396]||(i[1396]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1398]||(i[1398]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_emission</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, uv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBSpectrum</span></span></code></pre></div><p>Get the emitted radiance at UV coordinates (without directional check).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1397]||(i[1397]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/emissive.jl#L84-L88",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Gl,[s("summary",null,[i[1399]||(i[1399]=s("a",{id:"Hikari.get_emission-Tuple{Hikari.Emissive, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.get_emission-Tuple{Hikari.Emissive, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.get_emission")],-1)),i[1400]||(i[1400]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1402]||(i[1402]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_emission</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, si</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SurfaceInteraction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBSpectrum</span></span></code></pre></div><p>Get the emitted radiance at a surface point. Returns zero if the surface is one-sided and we&#39;re on the back.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1401]||(i[1401]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/emissive.jl#L67-L72",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Pl,[s("summary",null,[i[1403]||(i[1403]=s("a",{id:"Hikari.get_emission_spectral-Tuple{Hikari.CoatedConductorMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_emission_spectral-Tuple{Hikari.CoatedConductorMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_emission_spectral")],-1)),i[1404]||(i[1404]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1406]||(i[1406]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get_emission_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CoatedConductorMaterial </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> returns zero (non</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">emissive)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1405]||(i[1405]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3422-L3424",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Vl,[s("summary",null,[i[1407]||(i[1407]=s("a",{id:"Hikari.get_emission_spectral-Tuple{Hikari.CoatedDiffuseMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_emission_spectral-Tuple{Hikari.CoatedDiffuseMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_emission_spectral")],-1)),i[1408]||(i[1408]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1410]||(i[1410]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get_emission_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CoatedDiffuseMaterial </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> returns zero (non</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">emissive)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1409]||(i[1409]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1939-L1941",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ll,[s("summary",null,[i[1411]||(i[1411]=s("a",{id:"Hikari.get_emission_spectral-Tuple{Hikari.DiffuseTransmissionMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_emission_spectral-Tuple{Hikari.DiffuseTransmissionMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_emission_spectral")],-1)),i[1412]||(i[1412]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1414]||(i[1414]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get_emission_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DiffuseTransmissionMaterial </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> returns zero (non</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">emissive)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1413]||(i[1413]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L2220-L2222",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",wl,[s("summary",null,[i[1415]||(i[1415]=s("a",{id:"Hikari.get_emission_spectral-Tuple{Hikari.MediumInterface, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_emission_spectral-Tuple{Hikari.MediumInterface, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_emission_spectral")],-1)),i[1416]||(i[1416]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1418]||(i[1418]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get_emission_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MediumInterface </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> forwards to wrapped material.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Emission is now handled by DiffuseAreaLight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> the lights set, not on materials.)</span></span></code></pre></div>`,1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1417]||(i[1417]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3478-L3481",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Rl,[s("summary",null,[i[1419]||(i[1419]=s("a",{id:"Hikari.get_emission_spectral-Tuple{Hikari.ThinDielectricMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_emission_spectral-Tuple{Hikari.ThinDielectricMaterial, Hikari.RGBToSpectrumTable, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_emission_spectral")],-1)),i[1420]||(i[1420]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1422]||(i[1422]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">get_emission_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThinDielectricMaterial </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> returns zero (non</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">emissive)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1421]||(i[1421]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L2053-L2055",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Nl,[s("summary",null,[i[1423]||(i[1423]=s("a",{id:"Hikari.get_emission_spectral_dispatch-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_emission_spectral_dispatch-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_emission_spectral_dispatch")],-1)),i[1424]||(i[1424]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1426]||(i[1426]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_emission_spectral_dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx, wo, n, tfc, lambda)</span></span></code></pre></div><p>Type-stable dispatch for getting spectral emission from materials. Returns SpectralRadiance (zero for non-emissive materials).</p><p>Arguments:</p><ul><li><code>tfc::TextureFilterContext</code>: Contains UV coordinates and screen-space derivatives for texture filtering.</li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1425]||(i[1425]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L59-L67",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ol,[s("summary",null,[i[1427]||(i[1427]=s("a",{id:"Hikari.get_emission_spectral_uv_dispatch-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Raycore.SetKey, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}",href:"#Hikari.get_emission_spectral_uv_dispatch-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Raycore.SetKey, Hikari.TextureFilterContext, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.get_emission_spectral_uv_dispatch")],-1)),i[1428]||(i[1428]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1430]||(i[1430]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_emission_spectral_uv_dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx, tfc, lambda)</span></span></code></pre></div><p>Type-stable dispatch for getting spectral emission without directional check. Returns SpectralRadiance (zero for non-emissive materials).</p><p>Arguments:</p><ul><li><code>tfc::TextureFilterContext</code>: Contains UV coordinates and screen-space derivatives for texture filtering.</li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1429]||(i[1429]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L76-L84",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Jl,[s("summary",null,[i[1431]||(i[1431]=s("a",{id:"Hikari.get_medium_index-Tuple{Hikari.MediumInterfaceIdx, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.get_medium_index-Tuple{Hikari.MediumInterfaceIdx, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.get_medium_index")],-1)),i[1432]||(i[1432]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1434]||(i[1434]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_medium_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MediumInterfaceIdx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SetKey</span></span></code></pre></div><p>Determine which medium a ray enters based on direction and surface normal.</p><ul><li><p>If dot(wi, n) &gt; 0: ray going in direction of normal -&gt; outside medium</p></li><li><p>If dot(wi, n) &lt; 0: ray going against normal -&gt; inside medium</p></li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1433]||(i[1433]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/medium-interface.jl#L92-L98",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Wl,[s("summary",null,[i[1435]||(i[1435]=s("a",{id:"Hikari.get_medium_index_for_direction-Tuple{Hikari.MediumInterface, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.get_medium_index_for_direction-Tuple{Hikari.MediumInterface, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.get_medium_index_for_direction")],-1)),i[1436]||(i[1436]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1438]||(i[1438]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_medium_index_for_direction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MediumInterface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SetKey</span></span></code></pre></div><p>Get the medium index a ray enters when crossing a MediumInterface surface.</p><ul><li><p>If dot(wi, n) &gt; 0: ray going in direction of normal -&gt; outside medium</p></li><li><p>If dot(wi, n) &lt; 0: ray going against normal -&gt; inside medium</p></li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1437]||(i[1437]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L332-L338",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ul,[s("summary",null,[i[1439]||(i[1439]=s("a",{id:"Hikari.get_medium_index_for_direction_dispatch-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.get_medium_index_for_direction_dispatch-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.get_medium_index_for_direction_dispatch")],-1)),i[1440]||(i[1440]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1442]||(i[1442]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_medium_index_for_direction_dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Type-stable dispatch for getting the new medium index after crossing a surface. Returns the SetKey from MediumInterface, or SetKey() (vacuum) for regular materials.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1441]||(i[1441]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L346-L351",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ql,[s("summary",null,[i[1443]||(i[1443]=s("a",{id:"Hikari.get_medium_preset-Tuple{String}",href:"#Hikari.get_medium_preset-Tuple{String}"},[s("span",{class:"jlbinding"},"Hikari.get_medium_preset")],-1)),i[1444]||(i[1444]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1446]||(i[1446]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_medium_preset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NamedTuple{(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:σ_s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:σ_a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Get the scattering properties for a named medium preset. Returns a NamedTuple with σ_s (scattering) and σ_a (absorption) coefficients in mm⁻¹.</p><p>Available presets include:</p><ul><li><p>Milk: &quot;Wholemilk&quot;, &quot;Skimmilk&quot;, &quot;LowfatMilk&quot;, &quot;ReducedMilk&quot;, &quot;RegularMilk&quot;, &quot;Cream&quot;</p></li><li><p>Chocolate milk: &quot;LowfatChocolateMilk&quot;, &quot;RegularChocolateMilk&quot;</p></li><li><p>Soy milk: &quot;LowfatSoyMilk&quot;, &quot;RegularSoyMilk&quot;</p></li><li><p>Coffee: &quot;Espresso&quot;, &quot;MintMochaCoffee&quot;</p></li><li><p>Wine/Beer: &quot;Chardonnay&quot;, &quot;WhiteZinfandel&quot;, &quot;Merlot&quot;, &quot;BudweiserBeer&quot;, &quot;CoorsLightBeer&quot;</p></li><li><p>Juices: &quot;AppleJuice&quot;, &quot;CranberryJuice&quot;, &quot;GrapeJuice&quot;, &quot;RubyGrapefruitJuice&quot;</p></li><li><p>Sodas: &quot;Sprite&quot;, &quot;Coke&quot;, &quot;Pepsi&quot;</p></li><li><p>Foods: &quot;Apple&quot;, &quot;Potato&quot;, &quot;Chicken1&quot;, &quot;Chicken2&quot;, &quot;Ketchup&quot;</p></li><li><p>Skin: &quot;Skin1&quot;, &quot;Skin2&quot;</p></li><li><p>Materials: &quot;Marble&quot;, &quot;Spectralon&quot;, &quot;Shampoo&quot;, &quot;HeadShouldersShampoo&quot;, &quot;Clorox&quot;</p></li><li><p>Powders: &quot;CappuccinoPowder&quot;, &quot;SaltPowder&quot;, &quot;SugarPowder&quot;</p></li><li><p>Water: &quot;PacificOceanSurfaceWater&quot;</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1445]||(i[1445]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1831-L1850",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",zl,[s("summary",null,[i[1447]||(i[1447]=s("a",{id:"Hikari.get_physical_extension-Tuple{Hikari.Film}",href:"#Hikari.get_physical_extension-Tuple{Hikari.Film}"},[s("span",{class:"jlbinding"},"Hikari.get_physical_extension")],-1)),i[1448]||(i[1448]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1450]||(i[1450]=s("p",null,"Extent of the film in the scene. This is needed for realistic cameras.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1449]||(i[1449]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/film.jl#L199-L202",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Kl,[s("summary",null,[i[1451]||(i[1451]=s("a",{id:"Hikari.get_pixel_index-Tuple{Any, GeometryBasics.Point2}",href:"#Hikari.get_pixel_index-Tuple{Any, GeometryBasics.Point2}"},[s("span",{class:"jlbinding"},"Hikari.get_pixel_index")],-1)),i[1452]||(i[1452]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1454]||(i[1454]=s("p",null,"Point p is in (x, y) format. Returns CartesianIndex in (row, col) = (y, x) format for Julia array indexing.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1453]||(i[1453]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/film.jl#L211-L214",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Zl,[s("summary",null,[i[1455]||(i[1455]=s("a",{id:"Hikari.get_queue-Union{Tuple{N}, Tuple{Hikari.MultiMaterialQueue{N}, Integer}} where N",href:"#Hikari.get_queue-Union{Tuple{N}, Tuple{Hikari.MultiMaterialQueue{N}, Integer}} where N"},[s("span",{class:"jlbinding"},"Hikari.get_queue")],-1)),i[1456]||(i[1456]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1458]||(i[1458]=s("p",null,"Get queue for specific material type (1-indexed)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1457]||(i[1457]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/multi-material-eval.jl#L37",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xl,[s("summary",null,[i[1459]||(i[1459]=s("a",{id:"Hikari.get_sample_bounds-Tuple{Raycore.Bounds2, GeometryBasics.Point}",href:"#Hikari.get_sample_bounds-Tuple{Raycore.Bounds2, GeometryBasics.Point}"},[s("span",{class:"jlbinding"},"Hikari.get_sample_bounds")],-1)),i[1460]||(i[1460]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1462]||(i[1462]=s("p",null,[a("Range of integer pixels that the "),s("code",null,"Sampler"),a(" is responsible for generating samples for.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1461]||(i[1461]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/film.jl#L186-L189",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Yl,[s("summary",null,[i[1463]||(i[1463]=s("a",{id:"Hikari.get_srgb_table-Tuple{}",href:"#Hikari.get_srgb_table-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.get_srgb_table")],-1)),i[1464]||(i[1464]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1466]||(i[1466]=s("p",null,"Load the sRGB spectrum table (generates if not cached)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1465]||(i[1465]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L423",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ql,[s("summary",null,[i[1467]||(i[1467]=s("a",{id:"Hikari.get_surface_alpha_dispatch-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Point{2, Float32}}",href:"#Hikari.get_surface_alpha_dispatch-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.get_surface_alpha_dispatch")],-1)),i[1468]||(i[1468]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1470]||(i[1470]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_surface_alpha_dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, uv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Type-stable dispatch for evaluating surface alpha at a UV point. Returns alpha ∈ [0, 1] where 0 = fully transparent, 1 = fully opaque. Used by trace_shadow_transmittance for stochastic alpha pass-through.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1469]||(i[1469]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L293-L299",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$l,[s("summary",null,[i[1471]||(i[1471]=s("a",{id:"Hikari.get_template_grid-Tuple{Hikari.HomogeneousMedium}",href:"#Hikari.get_template_grid-Tuple{Hikari.HomogeneousMedium}"},[s("span",{class:"jlbinding"},"Hikari.get_template_grid")],-1)),i[1472]||(i[1472]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1474]||(i[1474]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_template_grid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(medium) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MajorantGrid</span></span></code></pre></div><p>Extract a template grid from a medium for type consistency in mixed media scenes. HomogeneousMedium returns EmptyMajorantGrid(), GridMedium returns its majorant_grid.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1473]||(i[1473]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L853-L858",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",sn,[s("summary",null,[i[1475]||(i[1475]=s("a",{id:"Hikari.get_template_grid_from_tuple-Tuple{M} where M<:Tuple",href:"#Hikari.get_template_grid_from_tuple-Tuple{M} where M<:Tuple"},[s("span",{class:"jlbinding"},"Hikari.get_template_grid_from_tuple")],-1)),i[1476]||(i[1476]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1478]||(i[1478]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_template_grid_from_tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(media</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MajorantGrid</span></span></code></pre></div><p>Extract a template grid from the first GridMedium or RGBGridMedium in the tuple, or EmptyMajorantGrid() if none. This is used to ensure all majorant iterators have consistent types for GPU compilation.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1477]||(i[1477]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L940-L945",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",en,[s("summary",null,[i[1479]||(i[1479]=s("a",{id:"Hikari.glossy_reflect-Tuple{Any, Any, Any, Raycore.RayDifferentials, Hikari.SurfaceInteraction, Hikari.AbstractScene, Int32}",href:"#Hikari.glossy_reflect-Tuple{Any, Any, Any, Raycore.RayDifferentials, Hikari.SurfaceInteraction, Hikari.AbstractScene, Int32}"},[s("span",{class:"jlbinding"},"Hikari.glossy_reflect")],-1)),i[1480]||(i[1480]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1482]||(i[1482]=s("p",null,"Glossy reflection for microfacet materials (metals, glossy plastics). Uses sample_f for proper importance sampling of microfacet distribution. The microfacet distribution already handles roughness via its α parameters, so no additional perturbation is needed.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1481]||(i[1481]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/sampler.jl#L275-L280",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",tn,[s("summary",null,[i[1483]||(i[1483]=s("a",{id:"Hikari.has_medium_interface-Tuple{Hikari.Material}",href:"#Hikari.has_medium_interface-Tuple{Hikari.Material}"},[s("span",{class:"jlbinding"},"Hikari.has_medium_interface")],-1)),i[1484]||(i[1484]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1486]||(i[1486]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">has_medium_interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bool</span></span></code></pre></div><p>Check if a material is a MediumInterface (defines medium boundary).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1485]||(i[1485]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L313-L317",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",an,[s("summary",null,[i[1487]||(i[1487]=s("a",{id:"Hikari.has_medium_interface_dispatch-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey}",href:"#Hikari.has_medium_interface_dispatch-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey}"},[s("span",{class:"jlbinding"},"Hikari.has_medium_interface_dispatch")],-1)),i[1488]||(i[1488]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1490]||(i[1490]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">has_medium_interface_dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bool</span></span></code></pre></div><p>Type-stable dispatch for checking if a material defines a medium boundary.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1489]||(i[1489]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L321-L325",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ln,[s("summary",null,[i[1491]||(i[1491]=s("a",{id:"Hikari.henyey_greenstein-Tuple{Float32, Float32}",href:"#Hikari.henyey_greenstein-Tuple{Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.henyey_greenstein")],-1)),i[1492]||(i[1492]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1494]||(i[1494]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">henyey_greenstein</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cos_theta, g) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Henyey-Greenstein phase function.</p><ul><li><p>g &gt; 0: Forward scattering (clouds typically g ≈ 0.85)</p></li><li><p>g = 0: Isotropic scattering</p></li><li><p>g &lt; 0: Backward scattering</p></li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1493]||(i[1493]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L167-L174",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",nn,[s("summary",null,[i[1495]||(i[1495]=s("a",{id:"Hikari.hg_p-Tuple{Float32, Float32}",href:"#Hikari.hg_p-Tuple{Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.hg_p")],-1)),i[1496]||(i[1496]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1498]||(i[1498]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hg_p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, cos_θ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Evaluate Henyey-Greenstein phase function. p(cos θ) = (1 - g²) / [4π(1 + g² - 2g cos θ)^(3/2)]</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1497]||(i[1497]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L22-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",rn,[s("summary",null,[i[1499]||(i[1499]=s("a",{id:"Hikari.hg_phase_pdf-Tuple{Float32, Float32}",href:"#Hikari.hg_phase_pdf-Tuple{Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.hg_phase_pdf")],-1)),i[1500]||(i[1500]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1502]||(i[1502]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">hg_phase_pdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, cos_θ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Evaluate Henyey-Greenstein phase function PDF.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1501]||(i[1501]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L874-L878",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",pn,[s("summary",null,[i[1503]||(i[1503]=s("a",{id:"Hikari.homogeneous_next-Tuple{Hikari.HomogeneousMajorantIterator}",href:"#Hikari.homogeneous_next-Tuple{Hikari.HomogeneousMajorantIterator}"},[s("span",{class:"jlbinding"},"Hikari.homogeneous_next")],-1)),i[1504]||(i[1504]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1506]||(i[1506]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">homogeneous_next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HomogeneousMajorantIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (RayMajorantSegment, HomogeneousMajorantIterator, Bool)</span></span></code></pre></div><p>Return the single majorant segment for homogeneous media. Returns (seg, new_iter, true) if valid, (invalid_seg, exhausted_iter, false) if exhausted.</p><p>The Bool indicates validity: true = has segment, false = exhausted.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1505]||(i[1505]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L145-L152",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",on,[s("summary",null,[i[1507]||(i[1507]=s("a",{id:"Hikari.importance-Tuple{Hikari.LightBounds, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.importance-Tuple{Hikari.LightBounds, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.importance")],-1)),i[1508]||(i[1508]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1510]||(i[1510]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">importance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LightBounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute the importance of a light (region) for shading point <code>p</code> with normal <code>n</code>. Pass <code>n = Vec3f(0)</code> for medium scattering (no normal term).</p><p>Following pbrt-v4&#39;s CompactLightBounds::Importance (lightsamplers.h:144-201).</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1509]||(i[1509]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-bounds.jl#L173-L180",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",dn,[s("summary",null,[i[1511]||(i[1511]=s("a",{id:"Hikari.int32_to_bytes-Tuple{Int32}",href:"#Hikari.int32_to_bytes-Tuple{Int32}"},[s("span",{class:"jlbinding"},"Hikari.int32_to_bytes")],-1)),i[1512]||(i[1512]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1514]||(i[1514]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int32_to_bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NTuple{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,UInt8}</span></span></code></pre></div><p>GPU-compatible conversion of Int32 to bytes.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1513]||(i[1513]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L11-L15",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",kn,[s("summary",null,[i[1515]||(i[1515]=s("a",{id:"Hikari.intersect_box-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, GeometryBasics.Point{3, Float32}, GeometryBasics.Point{3, Float32}}",href:"#Hikari.intersect_box-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, GeometryBasics.Point{3, Float32}, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.intersect_box")],-1)),i[1516]||(i[1516]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1518]||(i[1518]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">intersect_box</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ray_o, ray_d, box_min, box_max) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (hit, t_near, t_far)</span></span></code></pre></div><p>Compute ray intersection with an axis-aligned bounding box.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1517]||(i[1517]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L128-L132",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",hn,[s("summary",null,[i[1519]||(i[1519]=s("a",{id:"Hikari.is_emissive-Tuple{Hikari.Emissive}",href:"#Hikari.is_emissive-Tuple{Hikari.Emissive}"},[s("span",{class:"jlbinding"},"Hikari.is_emissive")],-1)),i[1520]||(i[1520]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1522]||(i[1522]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Material</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bool</span></span></code></pre></div><p>Check if a material emits light.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1521]||(i[1521]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/emissive.jl#L96-L100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",un,[s("summary",null,[i[1523]||(i[1523]=s("a",{id:"Hikari.is_emissive-Tuple{Hikari.HomogeneousMedium}",href:"#Hikari.is_emissive-Tuple{Hikari.HomogeneousMedium}"},[s("span",{class:"jlbinding"},"Hikari.is_emissive")],-1)),i[1524]||(i[1524]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1526]||(i[1526]=s("p",null,"Check if medium has emission",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1525]||(i[1525]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L778",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",gn,[s("summary",null,[i[1527]||(i[1527]=s("a",{id:"Hikari.is_emissive-Tuple{Hikari.MediumInterface}",href:"#Hikari.is_emissive-Tuple{Hikari.MediumInterface}"},[s("span",{class:"jlbinding"},"Hikari.is_emissive")],-1)),i[1528]||(i[1528]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1530]||(i[1530]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">is_emissive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MediumInterface </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> forwards to wrapped material.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1529]||(i[1529]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3489-L3491",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",cn,[s("summary",null,[i[1531]||(i[1531]=s("a",{id:"Hikari.is_emissive-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey}",href:"#Hikari.is_emissive-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey}"},[s("span",{class:"jlbinding"},"Hikari.is_emissive")],-1)),i[1532]||(i[1532]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1534]||(i[1534]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Type-stable dispatch for checking if a material/medium is emissive. Returns Bool. Works for both materials and media via element-level dispatch.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1533]||(i[1533]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L97-L102",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",bn,[s("summary",null,[i[1535]||(i[1535]=s("a",{id:"Hikari.is_medium_transition-Tuple{Hikari.MediumInterfaceIdx}",href:"#Hikari.is_medium_transition-Tuple{Hikari.MediumInterfaceIdx}"},[s("span",{class:"jlbinding"},"Hikari.is_medium_transition")],-1)),i[1536]||(i[1536]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1538]||(i[1538]=s("p",null,"Check if this interface represents a medium transition",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1537]||(i[1537]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/medium-interface.jl#L82",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",yn,[s("summary",null,[i[1539]||(i[1539]=s("a",{id:"Hikari.is_medium_transition-Tuple{Hikari.MediumInterface}",href:"#Hikari.is_medium_transition-Tuple{Hikari.MediumInterface}"},[s("span",{class:"jlbinding"},"Hikari.is_medium_transition")],-1)),i[1540]||(i[1540]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1542]||(i[1542]=s("p",null,"Check if this interface represents a medium transition",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1541]||(i[1541]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/medium-interface.jl#L56",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",mn,[s("summary",null,[i[1543]||(i[1543]=s("a",{id:"Hikari.is_mix_material-Tuple{Hikari.Material}",href:"#Hikari.is_mix_material-Tuple{Hikari.Material}"},[s("span",{class:"jlbinding"},"Hikari.is_mix_material")],-1)),i[1544]||(i[1544]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1546]||(i[1546]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_mix_material</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bool</span></span></code></pre></div><p>Check if a material is a MixMaterial.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1545]||(i[1545]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/mix-material.jl#L200-L204",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fn,[s("summary",null,[i[1547]||(i[1547]=s("a",{id:"Hikari.is_mix_material_dispatch-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey}",href:"#Hikari.is_mix_material_dispatch-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey}"},[s("span",{class:"jlbinding"},"Hikari.is_mix_material_dispatch")],-1)),i[1548]||(i[1548]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1550]||(i[1550]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_mix_material_dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(materials, idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bool</span></span></code></pre></div><p>Type-stable dispatch to check if a material is MixMaterial.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1549]||(i[1549]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/mix-material.jl#L208-L212",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",En,[s("summary",null,[i[1551]||(i[1551]=s("a",{id:"Hikari.is_pure_emissive-Tuple{Hikari.Emissive}",href:"#Hikari.is_pure_emissive-Tuple{Hikari.Emissive}"},[s("span",{class:"jlbinding"},"Hikari.is_pure_emissive")],-1)),i[1552]||(i[1552]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1554]||(i[1554]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_pure_emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Material</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bool</span></span></code></pre></div><p>Check if a material is purely emissive (no BSDF, only emits light).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1553]||(i[1553]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/emissive.jl#L103-L107",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_n,[s("summary",null,[i[1555]||(i[1555]=s("a",{id:"Hikari.is_pure_emissive-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey}",href:"#Hikari.is_pure_emissive-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey}"},[s("span",{class:"jlbinding"},"Hikari.is_pure_emissive")],-1)),i[1556]||(i[1556]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1558]||(i[1558]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">is_pure_emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Type-stable dispatch for checking if a material is purely emissive (no BSDF). Returns Bool.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1557]||(i[1557]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L109-L114",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Tn,[s("summary",null,[i[1559]||(i[1559]=s("a",{id:"Hikari.layer_transmittance-Tuple{Float32, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.layer_transmittance-Tuple{Float32, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.layer_transmittance")],-1)),i[1560]||(i[1560]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1562]||(i[1562]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Tr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(thickness, w) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Transmittance through a layer of given thickness along direction w. Used in LayeredBxDF random walk.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1561]||(i[1561]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L831-L836",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",jn,[s("summary",null,[i[1563]||(i[1563]=s("a",{id:"Hikari.lcg_init-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32}",href:"#Hikari.lcg_init-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.lcg_init")],-1)),i[1564]||(i[1564]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1566]||(i[1566]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lcg_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ray_o, ray_d, t_max) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt64</span></span></code></pre></div><p>Initialize LCG state from ray geometry for deterministic medium sampling. Following pbrt-v4&#39;s RNG initialization: Hash(ray.o, tMax), Hash(ray.d)</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1565]||(i[1565]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/delta-tracking.jl#L22-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fn,[s("summary",null,[i[1567]||(i[1567]=s("a",{id:"Hikari.lcg_next-Tuple{UInt64}",href:"#Hikari.lcg_next-Tuple{UInt64}"},[s("span",{class:"jlbinding"},"Hikari.lcg_next")],-1)),i[1568]||(i[1568]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1570]||(i[1570]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lcg_next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (UInt64, Float32)</span></span></code></pre></div><p>Generate next random Float32 in [0,1) and return new state. GPU-compatible LCG.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1569]||(i[1569]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/delta-tracking.jl#L47-L52",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Cn,[s("summary",null,[i[1571]||(i[1571]=s("a",{id:"Hikari.le-Tuple{Hikari.EnvironmentLight, Union{Raycore.Ray, Raycore.RayDifferentials}}",href:"#Hikari.le-Tuple{Hikari.EnvironmentLight, Union{Raycore.Ray, Raycore.RayDifferentials}}"},[s("span",{class:"jlbinding"},"Hikari.le")],-1)),i[1572]||(i[1572]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1574]||(i[1574]=s("p",null,"Compute emitted radiance for a ray that escapes the scene (hits no geometry). This is called when a camera/path ray doesn't hit anything.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1573]||(i[1573]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/environment.jl#L130-L133",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",vn,[s("summary",null,[i[1575]||(i[1575]=s("a",{id:"Hikari.le-Tuple{Hikari.Light, Union{Raycore.Ray, Raycore.RayDifferentials}}",href:"#Hikari.le-Tuple{Hikari.Light, Union{Raycore.Ray, Raycore.RayDifferentials}}"},[s("span",{class:"jlbinding"},"Hikari.le")],-1)),i[1576]||(i[1576]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1578]||(i[1578]=s("p",null,"Emmited light if ray hit an area light source. By default light sources have no area.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1577]||(i[1577]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light.jl#L41-L44",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Hn,[s("summary",null,[i[1579]||(i[1579]=s("a",{id:"Hikari.left_shift2-Tuple{UInt64}",href:"#Hikari.left_shift2-Tuple{UInt64}"},[s("span",{class:"jlbinding"},"Hikari.left_shift2")],-1)),i[1580]||(i[1580]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1582]||(i[1582]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">left_shift2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt64</span></span></code></pre></div><p>Spread bits of x for Morton encoding (interleave with zeros).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1581]||(i[1581]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L37-L41",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",An,[s("summary",null,[i[1583]||(i[1583]=s("a",{id:"Hikari.lerp_smits_basis-Tuple{NTuple{10, Float32}, Float32}",href:"#Hikari.lerp_smits_basis-Tuple{NTuple{10, Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.lerp_smits_basis")],-1)),i[1584]||(i[1584]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1586]||(i[1586]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lerp_smits_basis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(basis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NTuple{10, Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, λ</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Linearly interpolate a Smits basis spectrum at wavelength λ.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1585]||(i[1585]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L127-L131",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Sn,[s("summary",null,[i[1587]||(i[1587]=s("a",{id:"Hikari.light_bounds-Tuple{Hikari.Light}",href:"#Hikari.light_bounds-Tuple{Hikari.Light}"},[s("span",{class:"jlbinding"},"Hikari.light_bounds")],-1)),i[1588]||(i[1588]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1590]||(i[1590]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">light_bounds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(light) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Union{LightBounds, Nothing}</span></span></code></pre></div><p>Compute LightBounds for a light. Returns <code>nothing</code> for infinite lights.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1589]||(i[1589]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-bounds.jl#L226-L230",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xn,[s("summary",null,[i[1591]||(i[1591]=s("a",{id:"Hikari.linear_srgb_to_xyz-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.linear_srgb_to_xyz-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.linear_srgb_to_xyz")],-1)),i[1592]||(i[1592]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1594]||(i[1594]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">linear_srgb_to_xyz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Convert linear sRGB to CIE XYZ color space.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1593]||(i[1593]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L602-L606",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Bn,[s("summary",null,[i[1595]||(i[1595]=s("a",{id:"Hikari.linear_to_srgb_gamma-Tuple{Float32}",href:"#Hikari.linear_to_srgb_gamma-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.linear_to_srgb_gamma")],-1)),i[1596]||(i[1596]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1598]||(i[1598]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">linear_to_srgb_gamma</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Apply sRGB gamma curve to a linear RGB value.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1597]||(i[1597]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L616-L620",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Dn,[s("summary",null,[i[1599]||(i[1599]=s("a",{id:"Hikari.load_environment_map-Tuple{String}",href:"#Hikari.load_environment_map-Tuple{String}"},[s("span",{class:"jlbinding"},"Hikari.load_environment_map")],-1)),i[1600]||(i[1600]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1602]||(i[1602]=s("p",null,"Load an environment map from an HDR/EXR file. Converts the image to RGBSpectrum format.",-1)),i[1603]||(i[1603]=s("p",null,"rotation: Mat3f rotation matrix, or nothing for identity",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1601]||(i[1601]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L373-L378",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",In,[s("summary",null,[i[1604]||(i[1604]=s("a",{id:"Hikari.load_srgb_table_binary-Tuple{String}",href:"#Hikari.load_srgb_table_binary-Tuple{String}"},[s("span",{class:"jlbinding"},"Hikari.load_srgb_table_binary")],-1)),i[1605]||(i[1605]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1607]||(i[1607]=s("p",null,"Load the sRGB spectrum table from raw binary format",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1606]||(i[1606]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L402",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Mn,[s("summary",null,[i[1608]||(i[1608]=s("a",{id:"Hikari.local_to_world-NTuple{4, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.local_to_world-NTuple{4, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.local_to_world")],-1)),i[1609]||(i[1609]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1611]||(i[1611]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">local_to_world</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(local_dir, n, tangent, bitangent) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Transform direction from local (shading) space to world space.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1610]||(i[1610]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3526-L3530",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Gn,[s("summary",null,[i[1612]||(i[1612]=s("a",{id:"Hikari.lookup_uv-Union{Tuple{D}, Tuple{T}, Tuple{S}, Tuple{Hikari.EnvironmentMap{S, T, D}, GeometryBasics.Point{2, Float32}, Any}} where {S<:Hikari.Spectrum, T, D}",href:"#Hikari.lookup_uv-Union{Tuple{D}, Tuple{T}, Tuple{S}, Tuple{Hikari.EnvironmentMap{S, T, D}, GeometryBasics.Point{2, Float32}, Any}} where {S<:Hikari.Spectrum, T, D}"},[s("span",{class:"jlbinding"},"Hikari.lookup_uv")],-1)),i[1613]||(i[1613]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1615]||(i[1615]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lookup_uv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EnvironmentMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, uv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Spectrum</span></span></code></pre></div><p>Look up environment map directly by UV coordinates. This is the equivalent of pbrt-v4&#39;s ImageLe(uv, lambda) for ImageInfiniteLight. Used when UV is already known (e.g., from importance sampling the distribution).</p><p>The <code>textures</code> parameter is used to deref TextureRef fields when EnvironmentMap is stored in a MultiTypeSet.</p><p>IMPORTANT: Uses nearest-neighbor lookup to match the discrete PDF from importance sampling. Bilinear interpolation would cause bias because the PDF is computed for discrete pixels, not interpolated values. This matches pbrt-v4&#39;s LookupNearestChannel in ImageLe.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1614]||(i[1614]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L345-L357",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Pn,[s("summary",null,[i[1616]||(i[1616]=s("a",{id:"Hikari.luminance-Tuple{ColorTypes.RGB}",href:"#Hikari.luminance-Tuple{ColorTypes.RGB}"},[s("span",{class:"jlbinding"},"Hikari.luminance")],-1)),i[1617]||(i[1617]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1619]||(i[1619]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">luminance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute luminance from RGB using standard coefficients (Rec. 709).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1618]||(i[1618]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L439-L443",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Vn,[s("summary",null,[i[1620]||(i[1620]=s("a",{id:"Hikari.max_extinction-Tuple{Hikari.CloudVolume}",href:"#Hikari.max_extinction-Tuple{Hikari.CloudVolume}"},[s("span",{class:"jlbinding"},"Hikari.max_extinction")],-1)),i[1621]||(i[1621]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1623]||(i[1623]=s("p",null,"Get the maximum extinction coefficient in the volume",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1622]||(i[1622]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L53",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ln,[s("summary",null,[i[1624]||(i[1624]=s("a",{id:"Hikari.max_value-Tuple{Hikari.RGBIlluminantSpectrum}",href:"#Hikari.max_value-Tuple{Hikari.RGBIlluminantSpectrum}"},[s("span",{class:"jlbinding"},"Hikari.max_value")],-1)),i[1625]||(i[1625]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1627]||(i[1627]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">max_value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBIlluminantSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Maximum value of the spectrum, matching pbrt-v4&#39;s RGBIlluminantSpectrum::MaxValue(): scale * rsp.MaxValue() * illuminant-&gt;MaxValue()</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1626]||(i[1626]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L355-L360",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",wn,[s("summary",null,[i[1628]||(i[1628]=s("a",{id:"Hikari.max_value-Tuple{Hikari.RGBSigmoidPolynomial}",href:"#Hikari.max_value-Tuple{Hikari.RGBSigmoidPolynomial}"},[s("span",{class:"jlbinding"},"Hikari.max_value")],-1)),i[1629]||(i[1629]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1631]||(i[1631]=s("p",null,"Maximum value of the spectrum (for normalization)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1630]||(i[1630]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L38",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Rn,[s("summary",null,[i[1632]||(i[1632]=s("a",{id:"Hikari.medium_direct_lighting_inner!-Tuple{Any, Hikari.VPMediumScatterWorkItem, Any, Any, Any, Any, Int32, Int32, Int32, Any, Any}",href:"#Hikari.medium_direct_lighting_inner!-Tuple{Any, Hikari.VPMediumScatterWorkItem, Any, Any, Any, Any, Int32, Int32, Int32, Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.medium_direct_lighting_inner!")],-1)),i[1633]||(i[1633]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1635]||(i[1635]=s("p",null,"Inner function for medium direct lighting - can use return statements.",-1)),i[1636]||(i[1636]=s("p",null,"Uses power-weighted light sampling via alias table for better importance sampling in scenes with lights of varying intensities (pbrt-v4's PowerLightSampler approach).",-1)),i[1637]||(i[1637]=s("p",null,"Now uses pre-computed Sobol samples from pixel_samples (pbrt-v4 RaySamples style).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1634]||(i[1634]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/medium-scatter.jl#L8-L15",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Nn,[s("summary",null,[i[1638]||(i[1638]=s("a",{id:"Hikari.medium_scatter_inner!-Tuple{Any, Hikari.VPMediumScatterWorkItem, Int32, Any}",href:"#Hikari.medium_scatter_inner!-Tuple{Any, Hikari.VPMediumScatterWorkItem, Int32, Any}"},[s("span",{class:"jlbinding"},"Hikari.medium_scatter_inner!")],-1)),i[1639]||(i[1639]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1641]||(i[1641]=s("p",null,"Inner function for medium scatter - can use return statements.",-1)),i[1642]||(i[1642]=s("p",null,"Now uses pre-computed Sobol samples from pixel_samples (pbrt-v4 RaySamples style).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1640]||(i[1640]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/medium-scatter.jl#L144-L148",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",On,[s("summary",null,[i[1643]||(i[1643]=s("a",{id:"Hikari.mis_weight_spectral-Tuple{Float32, Float32}",href:"#Hikari.mis_weight_spectral-Tuple{Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.mis_weight_spectral")],-1)),i[1644]||(i[1644]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1646]||(i[1646]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mis_weight_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pdf_f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pdf_g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute MIS weight using power heuristic (beta=2). Returns weight for strategy f: w_f = pdf_f^2 / (pdf_f^2 + pdf_g^2)</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1645]||(i[1645]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L473-L478",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Jn,[s("summary",null,[i[1647]||(i[1647]=s("a",{id:"Hikari.mix_bits-Tuple{UInt64}",href:"#Hikari.mix_bits-Tuple{UInt64}"},[s("span",{class:"jlbinding"},"Hikari.mix_bits")],-1)),i[1648]||(i[1648]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1650]||(i[1650]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mix_bits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt64</span></span></code></pre></div><p>Bit mixing function from pbrt-v4&#39;s hash.h. Reference: <a href="http://zimbry.blogspot.ch/2011/09/better-bit-mixing-improving-on.html" target="_blank" rel="noreferrer">http://zimbry.blogspot.ch/2011/09/better-bit-mixing-improving-on.html</a></p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1649]||(i[1649]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L635-L640",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Wn,[s("summary",null,[i[1651]||(i[1651]=s("a",{id:"Hikari.mix_hash_float-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Raycore.SetKey, Raycore.SetKey}",href:"#Hikari.mix_hash_float-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Raycore.SetKey, Raycore.SetKey}"},[s("span",{class:"jlbinding"},"Hikari.mix_hash_float")],-1)),i[1652]||(i[1652]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1654]||(i[1654]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">mix_hash_float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Generate a deterministic pseudo-random float in [0, 1) for material selection. Uses a simple but effective hash function based on pbrt-v4&#39;s HashFloat.</p><p>The hash is deterministic: same position, direction, and materials always produce the same result, ensuring consistent rendering across samples.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1653]||(i[1653]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/mix-material.jl#L107-L115",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Un,[s("summary",null,[i[1655]||(i[1655]=s("a",{id:"Hikari.murmur_hash_64a-Union{Tuple{NTuple{N, UInt8}}, Tuple{N}, Tuple{NTuple{N, UInt8}, UInt64}} where N",href:"#Hikari.murmur_hash_64a-Union{Tuple{NTuple{N, UInt8}}, Tuple{N}, Tuple{NTuple{N, UInt8}, UInt64}} where N"},[s("span",{class:"jlbinding"},"Hikari.murmur_hash_64a")],-1)),i[1656]||(i[1656]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1658]||(i[1658]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">murmur_hash_64a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NTuple{N,UInt8}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, seed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt64</span></span></code></pre></div><p>MurmurHash2 64-bit hash function, exactly matching pbrt-v4&#39;s MurmurHash64A. Reference: <a href="https://github.com/explosion/murmurhash/blob/master/murmurhash/MurmurHash2.cpp" target="_blank" rel="noreferrer">https://github.com/explosion/murmurhash/blob/master/murmurhash/MurmurHash2.cpp</a></p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1657]||(i[1657]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L569-L574",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",qn,[s("summary",null,[i[1659]||(i[1659]=s("a",{id:"Hikari.nanovdb_get_value-Tuple{Hikari.NanoVDBMedium, Any, Tuple{Int32, Int32, Int32}}",href:"#Hikari.nanovdb_get_value-Tuple{Hikari.NanoVDBMedium, Any, Tuple{Int32, Int32, Int32}}"},[s("span",{class:"jlbinding"},"Hikari.nanovdb_get_value")],-1)),i[1660]||(i[1660]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1662]||(i[1662]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nanovdb_get_value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(medium</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NanoVDBMedium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, media, ijk</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NTuple{3, Int32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get the voxel value at integer index coordinates using full tree traversal. Matches pbrt-v4/NanoVDB&#39;s Tree::getValue exactly.</p><p>The <code>media</code> parameter is used to deref TextureRef fields when NanoVDBMedium is stored in a MultiTypeSet.</p><p>Uses pointer(buffer) with as_pointer for type conversion - works on both CPU and GPU.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1661]||(i[1661]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L305-L314",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",zn,[s("summary",null,[i[1663]||(i[1663]=s("a",{id:"Hikari.next_ray_queue-Tuple{Hikari.VolPathState}",href:"#Hikari.next_ray_queue-Tuple{Hikari.VolPathState}"},[s("span",{class:"jlbinding"},"Hikari.next_ray_queue")],-1)),i[1664]||(i[1664]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1666]||(i[1666]=s("p",null,"Get the next ray queue (the one not currently active).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1665]||(i[1665]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath-state.jl#L192",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Kn,[s("summary",null,[i[1667]||(i[1667]=s("a",{id:"Hikari.node_importance-Tuple{Hikari.LightBVHNode, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.node_importance-Tuple{Hikari.LightBVHNode, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.node_importance")],-1)),i[1668]||(i[1668]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1670]||(i[1670]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">node_importance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LightBVHNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute importance of a BVH node at shading point <code>p</code> with normal <code>n</code>. Operates directly on unquantized node fields.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1669]||(i[1669]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/bvh-light-sampler.jl#L52-L57",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Zn,[s("summary",null,[i[1671]||(i[1671]=s("a",{id:"Hikari.parse_nanovdb_buffer-Tuple{String}",href:"#Hikari.parse_nanovdb_buffer-Tuple{String}"},[s("span",{class:"jlbinding"},"Hikari.parse_nanovdb_buffer")],-1)),i[1672]||(i[1672]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1674]||(i[1674]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse_nanovdb_buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filepath</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (buffer, metadata)</span></span></code></pre></div><p>Parse a NanoVDB file and return the decompressed buffer along with metadata. Returns raw buffer suitable for GPU upload.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1673]||(i[1673]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L1079-L1084",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xn,[s("summary",null,[i[1675]||(i[1675]=s("a",{id:"Hikari.pbrt_hash-Tuple{Float32}",href:"#Hikari.pbrt_hash-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.pbrt_hash")],-1)),i[1676]||(i[1676]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1678]||(i[1678]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pbrt_hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt64</span></span></code></pre></div><p>Hash function matching pbrt-v4&#39;s variadic Hash() template. Packs arguments into a byte buffer and applies MurmurHash64A. Uses GPU-compatible bit manipulation instead of reinterpret.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1677]||(i[1677]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L683-L689",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Yn,[s("summary",null,[i[1679]||(i[1679]=s("a",{id:"Hikari.pcg32_init-Tuple{UInt64, UInt64}",href:"#Hikari.pcg32_init-Tuple{UInt64, UInt64}"},[s("span",{class:"jlbinding"},"Hikari.pcg32_init")],-1)),i[1680]||(i[1680]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1682]||(i[1682]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pcg32_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(seq_index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, seed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PCG32State</span></span></code></pre></div><p>Initialize PCG32 with sequence index and seed, matching pbrt-v4&#39;s SetSequence. Returns initialized state.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1681]||(i[1681]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L760-L765",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Qn,[s("summary",null,[i[1683]||(i[1683]=s("a",{id:"Hikari.pcg32_uniform_f32-Tuple{Hikari.PCG32State}",href:"#Hikari.pcg32_uniform_f32-Tuple{Hikari.PCG32State}"},[s("span",{class:"jlbinding"},"Hikari.pcg32_uniform_f32")],-1)),i[1684]||(i[1684]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1686]||(i[1686]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pcg32_uniform_f32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PCG32State</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Float32, PCG32State)</span></span></code></pre></div><p>Generate uniform random Float32 in [0, 1) and return new state. Matching pbrt-v4&#39;s Uniform&lt;float&gt;().</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1685]||(i[1685]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L804-L809",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$n,[s("summary",null,[i[1687]||(i[1687]=s("a",{id:"Hikari.pcg32_uniform_u32-Tuple{Hikari.PCG32State}",href:"#Hikari.pcg32_uniform_u32-Tuple{Hikari.PCG32State}"},[s("span",{class:"jlbinding"},"Hikari.pcg32_uniform_u32")],-1)),i[1688]||(i[1688]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1690]||(i[1690]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pcg32_uniform_u32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PCG32State</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (UInt32, PCG32State)</span></span></code></pre></div><p>Generate uniform random UInt32 and return new state. Matching pbrt-v4&#39;s Uniform&lt;uint32_t&gt;().</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1689]||(i[1689]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L786-L791",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ir,[s("summary",null,[i[1691]||(i[1691]=s("a",{id:"Hikari.pdf-Tuple{Hikari.Distribution1D, Float32}",href:"#Hikari.pdf-Tuple{Hikari.Distribution1D, Float32}"},[s("span",{class:"jlbinding"},"Hikari.pdf")],-1)),i[1692]||(i[1692]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1694]||(i[1694]=s("p",null,"Compute PDF for sampling a specific value from Distribution1D.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1693]||(i[1693]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sampling.jl#L154-L156",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",sr,[s("summary",null,[i[1695]||(i[1695]=s("a",{id:"Hikari.pdf-Tuple{Hikari.Distribution2D, GeometryBasics.Point{2, Float32}, Any}",href:"#Hikari.pdf-Tuple{Hikari.Distribution2D, GeometryBasics.Point{2, Float32}, Any}"},[s("span",{class:"jlbinding"},"Hikari.pdf")],-1)),i[1696]||(i[1696]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1698]||(i[1698]=s("p",null,[a("Compute PDF for sampling a specific 2D point from flat distribution. The "),s("code",null,"textures"),a(" parameter is used to deref TextureRef fields when Distribution2D is stored in a MultiTypeSet.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1697]||(i[1697]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sampling.jl#L347-L350",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",er,[s("summary",null,[i[1699]||(i[1699]=s("a",{id:"Hikari.pdf_dielectric_interface",href:"#Hikari.pdf_dielectric_interface"},[s("span",{class:"jlbinding"},"Hikari.pdf_dielectric_interface")],-1)),i[1700]||(i[1700]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[1702]||(i[1702]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pdf_dielectric_interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, wi, alpha_x, alpha_y, eta, refl_trans_flags) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute PDF of dielectric interface sampling.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1701]||(i[1701]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1488-L1492",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",tr,[s("summary",null,[i[1703]||(i[1703]=s("a",{id:"Hikari.pdf_diffuse_interface-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.pdf_diffuse_interface-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.pdf_diffuse_interface")],-1)),i[1704]||(i[1704]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1706]||(i[1706]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pdf_diffuse_interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, wi) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute PDF of diffuse sampling.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1705]||(i[1705]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1189-L1193",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ar,[s("summary",null,[i[1707]||(i[1707]=s("a",{id:"Hikari.pdf_fresnel_microfacet-Tuple{Hikari.UberBxDF, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.pdf_fresnel_microfacet-Tuple{Hikari.UberBxDF, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.pdf_fresnel_microfacet")],-1)),i[1708]||(i[1708]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1710]||(i[1710]=s("p",null,"Compute PDF for FresnelMicrofacet given a direction pair.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1709]||(i[1709]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/microfacet.jl#L452-L454",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",lr,[s("summary",null,[i[1711]||(i[1711]=s("a",{id:"Hikari.pdf_is_nonzero-Tuple{Hikari.SampledWavelengths{4}, Int64}",href:"#Hikari.pdf_is_nonzero-Tuple{Hikari.SampledWavelengths{4}, Int64}"},[s("span",{class:"jlbinding"},"Hikari.pdf_is_nonzero")],-1)),i[1712]||(i[1712]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1714]||(i[1714]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pdf_is_nonzero</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bool</span></span></code></pre></div><p>Check if wavelength i has non-zero PDF (should contribute).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1713]||(i[1713]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/spectral.jl#L264-L268",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",nr,[s("summary",null,[i[1715]||(i[1715]=s("a",{id:"Hikari.pdf_layered_bsdf-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32, Float32, Int64, Int64, Hikari.SampledSpectrum{4}, Bool, Float32, Float32}",href:"#Hikari.pdf_layered_bsdf-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32, Float32, Int64, Int64, Hikari.SampledSpectrum{4}, Bool, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.pdf_layered_bsdf")],-1)),i[1716]||(i[1716]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1718]||(i[1718]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pdf_layered_bsdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute PDF for LayeredBxDF using Monte Carlo estimation. This is a simplified version of pbrt-v4&#39;s LayeredBxDF::PDF.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1717]||(i[1717]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1842-L1847",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",rr,[s("summary",null,[i[1719]||(i[1719]=s("a",{id:"Hikari.pdf_li-Tuple{Hikari.EnvironmentLight, Hikari.Interaction, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.pdf_li-Tuple{Hikari.EnvironmentLight, Hikari.Interaction, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.pdf_li")],-1)),i[1720]||(i[1720]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1722]||(i[1722]=s("p",null,"PDF for sampling a particular direction from the environment light. Returns the probability density for importance sampling this direction.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1721]||(i[1721]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/environment.jl#L139-L142",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",pr,[s("summary",null,[i[1723]||(i[1723]=s("a",{id:"Hikari.pdf_li_spectral-Tuple{Any, Hikari.EnvironmentLight, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.pdf_li_spectral-Tuple{Any, Hikari.EnvironmentLight, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.pdf_li_spectral")],-1)),i[1724]||(i[1724]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1726]||(i[1726]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pdf_li_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lights, light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EnvironmentLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>PDF for sampling direction wi from environment light.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1725]||(i[1725]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L331-L335",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",or,[s("summary",null,[i[1727]||(i[1727]=s("a",{id:"Hikari.pdf_li_spectral-Tuple{Hikari.DirectionalLight, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.pdf_li_spectral-Tuple{Hikari.DirectionalLight, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.pdf_li_spectral")],-1)),i[1728]||(i[1728]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1730]||(i[1730]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pdf_li_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DirectionalLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>PDF for sampling direction wi from directional light (always delta).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1729]||(i[1729]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L310-L314",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",dr,[s("summary",null,[i[1731]||(i[1731]=s("a",{id:"Hikari.pdf_li_spectral-Tuple{Hikari.PointLight, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.pdf_li_spectral-Tuple{Hikari.PointLight, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.pdf_li_spectral")],-1)),i[1732]||(i[1732]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1734]||(i[1734]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pdf_li_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PointLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>PDF for sampling direction wi from point light (always delta).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1733]||(i[1733]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L303-L307",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",kr,[s("summary",null,[i[1735]||(i[1735]=s("a",{id:"Hikari.pdf_li_spectral-Tuple{Hikari.SpotLight, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.pdf_li_spectral-Tuple{Hikari.SpotLight, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.pdf_li_spectral")],-1)),i[1736]||(i[1736]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1738]||(i[1738]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pdf_li_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpotLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>PDF for sampling direction wi from spotlight (always delta).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1737]||(i[1737]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L324-L328",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",hr,[s("summary",null,[i[1739]||(i[1739]=s("a",{id:"Hikari.pdf_li_spectral-Tuple{Hikari.SunLight, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.pdf_li_spectral-Tuple{Hikari.SunLight, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.pdf_li_spectral")],-1)),i[1740]||(i[1740]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1742]||(i[1742]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pdf_li_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SunLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>PDF for sampling direction wi from sun light (always delta).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1741]||(i[1741]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L317-L321",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ur,[s("summary",null,[i[1743]||(i[1743]=s("a",{id:"Hikari.perlin3d-Tuple{Any, Any, Any}",href:"#Hikari.perlin3d-Tuple{Any, Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.perlin3d")],-1)),i[1744]||(i[1744]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1746]||(i[1746]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">perlin3d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y, z) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float64</span></span></code></pre></div><p>Classic 3D Perlin noise. Returns values in approximately [-1, 1].</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1745]||(i[1745]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/random.jl#L32-L36",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",gr,[s("summary",null,[i[1747]||(i[1747]=s("a",{id:"Hikari.pixel_coords_from_index-Tuple{Int32, Int32}",href:"#Hikari.pixel_coords_from_index-Tuple{Int32, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pixel_coords_from_index")],-1)),i[1748]||(i[1748]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1750]||(i[1750]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pixel_coords_from_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert linear pixel index to x,y coordinates (1-based).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1749]||(i[1749]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/camera.jl#L131-L135",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",cr,[s("summary",null,[i[1751]||(i[1751]=s("a",{id:"Hikari.pixel_index_from_coords-Tuple{Int32, Int32, Int32}",href:"#Hikari.pixel_index_from_coords-Tuple{Int32, Int32, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pixel_index_from_coords")],-1)),i[1752]||(i[1752]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1754]||(i[1754]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pixel_index_from_coords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Int32</span></span></code></pre></div><p>Convert x,y coordinates to linear pixel index (1-based).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1753]||(i[1753]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/camera.jl#L143-L147",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",br,[s("summary",null,[i[1755]||(i[1755]=s("a",{id:"Hikari.pixel_offset_2d-Tuple{Int32, Int32, Int32}",href:"#Hikari.pixel_offset_2d-Tuple{Int32, Int32, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pixel_offset_2d")],-1)),i[1756]||(i[1756]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1758]||(i[1758]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pixel_offset_2d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Tuple{Float32, Float32}</span></span></code></pre></div><p>Compute a deterministic 2D offset for Cranley-Patterson rotation based on pixel coordinates.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1757]||(i[1757]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L142-L146",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",yr,[s("summary",null,[i[1759]||(i[1759]=s("a",{id:"Hikari.planckian_xy-Tuple{Float32}",href:"#Hikari.planckian_xy-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.planckian_xy")],-1)),i[1760]||(i[1760]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1762]||(i[1762]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">planckian_xy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (x, y)</span></span></code></pre></div><p>Compute CIE xy chromaticity coordinates for a Planckian (blackbody) radiator at temperature T in Kelvin. Valid for 1667K to 25000K.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1761]||(i[1761]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L463-L468",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",mr,[s("summary",null,[i[1763]||(i[1763]=s("a",{id:"Hikari.pmf-Tuple{Hikari.AliasTable, Int32}",href:"#Hikari.pmf-Tuple{Hikari.AliasTable, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pmf")],-1)),i[1764]||(i[1764]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1766]||(i[1766]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pmf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AliasTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get the PMF for index <code>idx</code> (1-based).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1765]||(i[1765]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L155-L159",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fr,[s("summary",null,[i[1767]||(i[1767]=s("a",{id:"Hikari.pmf-Tuple{Hikari.PowerLightSampler, Int32}",href:"#Hikari.pmf-Tuple{Hikari.PowerLightSampler, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pmf")],-1)),i[1768]||(i[1768]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1770]||(i[1770]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pmf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PowerLightSampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, light_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get PMF for a specific light index.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1769]||(i[1769]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L356-L360",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Er,[s("summary",null,[i[1771]||(i[1771]=s("a",{id:"Hikari.pmf-Tuple{Hikari.UniformLightSampler, Int32}",href:"#Hikari.pmf-Tuple{Hikari.UniformLightSampler, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pmf")],-1)),i[1772]||(i[1772]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1774]||(i[1774]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pmf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UniformLightSampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, light_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>PMF for any light is 1/N.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1773]||(i[1773]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L208-L212",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_r,[s("summary",null,[i[1775]||(i[1775]=s("a",{id:"Hikari.postprocess!-Tuple{Hikari.Film}",href:"#Hikari.postprocess!-Tuple{Hikari.Film}"},[s("span",{class:"jlbinding"},"Hikari.postprocess!")],-1)),i[1776]||(i[1776]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1778]||(i[1778]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">postprocess!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Film</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; exposure</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tonemap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:aces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, gamma</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.2f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, white_point</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.0f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sensor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Apply postprocessing to film.framebuffer and write result to film.postprocess.</p><p>This function is non-destructive: the original framebuffer is preserved, allowing you to call postprocess! multiple times with different parameters.</p><p>Works on both CPU and GPU arrays via KernelAbstractions.</p><p><strong>Arguments</strong></p><ul><li><p><code>film</code>: The Film containing rendered data</p></li><li><p><code>exposure</code>: Exposure multiplier applied before tonemapping (default: 1.0)</p></li><li><p><code>tonemap</code>: Tonemapping method (default: :aces)</p><ul><li><p><code>:reinhard</code> - Simple Reinhard L/(1+L)</p></li><li><p><code>:reinhard_extended</code> - Extended Reinhard with white point</p></li><li><p><code>:aces</code> - ACES filmic (industry standard)</p></li><li><p><code>:uncharted2</code> - Uncharted 2 filmic</p></li><li><p><code>:filmic</code> - Hejl-Dawson filmic</p></li><li><p><code>nothing</code> - No tonemapping (linear clamp)</p></li></ul></li><li><p><code>gamma</code>: Gamma correction value (default: 2.2, use <code>nothing</code> to skip)</p></li><li><p><code>white_point</code>: White point for extended Reinhard (default: 4.0)</p></li><li><p><code>sensor</code>: FilmSensor for pbrt-style sensor simulation (ISO, white balance)</p></li><li><p><code>background</code>: When set to an <code>RGB{Float32}</code>, pixels where <code>film.depth</code> is <code>Inf</code> (escaped rays) are replaced with this color instead of being tonemapped. Useful for compositing.</p></li></ul><p><strong>Example</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Render once</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">integrator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene, film, camera)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">to_framebuffer!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Try different postprocessing settings</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">postprocess!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film; exposure</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tonemap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:aces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">postprocess)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># With pbrt-style sensor (bunny-cloud scene settings)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sensor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> FilmSensor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iso</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">90</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, white_balance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">postprocess!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film; sensor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sensor, tonemap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:aces</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(film</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">postprocess)</span></span></code></pre></div>`,8)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1777]||(i[1777]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/postprocess.jl#L251-L292",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Tr,[s("summary",null,[i[1779]||(i[1779]=s("a",{id:"Hikari.power-Tuple{Hikari.PointLight}",href:"#Hikari.power-Tuple{Hikari.PointLight}"},[s("span",{class:"jlbinding"},"Hikari.power")],-1)),i[1780]||(i[1780]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1782]||(i[1782]=s("p",null,"Total power emitted by the light source over the entire sphere of directions.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1781]||(i[1781]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/point.jl#L121-L123",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",jr,[s("summary",null,[i[1783]||(i[1783]=s("a",{id:"Hikari.power-Tuple{Hikari.SpotLight}",href:"#Hikari.power-Tuple{Hikari.SpotLight}"},[s("span",{class:"jlbinding"},"Hikari.power")],-1)),i[1784]||(i[1784]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1786]||(i[1786]=s("p",null,"Total power emitted by the spotlight.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1785]||(i[1785]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/spot.jl#L145-L147",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fr,[s("summary",null,[i[1787]||(i[1787]=s("a",{id:"Hikari.power-Union{Tuple{S}, Tuple{Hikari.DirectionalLight{S}, Hikari.AbstractScene}} where S<:Hikari.Spectrum",href:"#Hikari.power-Union{Tuple{S}, Tuple{Hikari.DirectionalLight{S}, Hikari.AbstractScene}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.power")],-1)),i[1788]||(i[1788]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1790]||(i[1790]=s("p",null,[a("The total power emitted by the directional light is related to the spatial extent of the scene and equals the amount of power arriving at the inscribed by bounding sphere disk: "),s("code",null,"scale * I * π * r^2"),a(".")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1789]||(i[1789]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/directional.jl#L88-L92",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Cr,[s("summary",null,[i[1791]||(i[1791]=s("a",{id:"Hikari.power-Union{Tuple{S}, Tuple{Hikari.EnvironmentLight{S, E} where E<:Hikari.EnvironmentMap{S, T} where T<:AbstractMatrix{S}, Hikari.Scene}} where S<:Hikari.Spectrum",href:"#Hikari.power-Union{Tuple{S}, Tuple{Hikari.EnvironmentLight{S, E} where E<:Hikari.EnvironmentMap{S, T} where T<:AbstractMatrix{S}, Hikari.Scene}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.power")],-1)),i[1792]||(i[1792]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1794]||(i[1794]=s("p",null,"Total power emitted by the environment light. For an environment light, this is approximated as the average radiance times the surface area of the bounding sphere.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1793]||(i[1793]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/environment.jl#L155-L159",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",vr,[s("summary",null,[i[1795]||(i[1795]=s("a",{id:"Hikari.power_heuristic",href:"#Hikari.power_heuristic"},[s("span",{class:"jlbinding"},"Hikari.power_heuristic")],-1)),i[1796]||(i[1796]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[1798]||(i[1798]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">power_heuristic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pdf_f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pdf_g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, beta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Power heuristic for MIS: w_f = pdf_f^beta / (pdf_f^beta + pdf_g^beta) Default beta=2 (squared terms).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1797]||(i[1797]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/workitems.jl#L258-L263",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Hr,[s("summary",null,[i[1799]||(i[1799]=s("a",{id:"Hikari.power_heuristic-Tuple{Int64, Float32, Int64, Float32}",href:"#Hikari.power_heuristic-Tuple{Int64, Float32, Int64, Float32}"},[s("span",{class:"jlbinding"},"Hikari.power_heuristic")],-1)),i[1800]||(i[1800]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1802]||(i[1802]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">power_heuristic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nf, fPdf, ng, gPdf) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Balance heuristic for MIS with power=2.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1801]||(i[1801]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1201-L1205",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ar,[s("summary",null,[i[1803]||(i[1803]=s("a",{id:"Hikari.pw_accumulate_sample_to_rgb!-Tuple{Any, AbstractVector{Float32}, AbstractVector{Float32}, AbstractVector{Float32}, AbstractVector{Float32}, Hikari.CIEXYZTable, Int32}",href:"#Hikari.pw_accumulate_sample_to_rgb!-Tuple{Any, AbstractVector{Float32}, AbstractVector{Float32}, AbstractVector{Float32}, AbstractVector{Float32}, Hikari.CIEXYZTable, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pw_accumulate_sample_to_rgb!")],-1)),i[1804]||(i[1804]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1806]||(i[1806]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_accumulate_sample_to_rgb!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, pixel_rgb, pixel_L, wavelengths_per_pixel,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                              pdf_per_pixel, cie_table, num_pixels)</span></span></code></pre></div><p>High-level wrapper to accumulate spectral sample to RGB buffer.</p>`,2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1805]||(i[1805]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L68-L73",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Sr,[s("summary",null,[i[1807]||(i[1807]=s("a",{id:"Hikari.pw_accumulate_sample_to_rgb_kernel!-Tuple{Any}",href:"#Hikari.pw_accumulate_sample_to_rgb_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_accumulate_sample_to_rgb_kernel!")],-1)),i[1808]||(i[1808]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1810]||(i[1810]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_accumulate_sample_to_rgb_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pixel_rgb, pixel_L, wavelengths_per_pixel,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                     pdf_per_pixel, cie_x, cie_y, cie_z, num_pixels)</span></span></code></pre></div><p>Convert this sample&#39;s spectral radiance to RGB using PER-PIXEL wavelengths and accumulate into pixel_rgb buffer.</p><p>This is the key operation that pbrt-v4 does: spectral-to-RGB conversion happens IMMEDIATELY after each sample, using THAT PIXEL&#39;s wavelengths. The RGB values are then accumulated across samples.</p><p>Each pixel has independently sampled wavelengths, which decorrelates color noise and results in much faster convergence than using shared wavelengths.</p><p>Arguments:</p><ul><li><p><code>pixel_rgb</code>: RGB accumulation buffer (3 × num_pixels, interleaved R,G,B)</p></li><li><p><code>pixel_L</code>: Spectral radiance for this sample (4 × num_pixels, interleaved)</p></li><li><p><code>wavelengths_per_pixel</code>: Wavelengths for each pixel (4 × num_pixels)</p></li><li><p><code>pdf_per_pixel</code>: PDF for each wavelength sample (4 × num_pixels)</p></li><li><p><code>cie_x</code>, <code>cie_y</code>, <code>cie_z</code>: CIE XYZ color matching function arrays</p></li><li><p><code>num_pixels</code>: Total number of pixels</p></li></ul>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1809]||(i[1809]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L14-L35",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xr,[s("summary",null,[i[1811]||(i[1811]=s("a",{id:"Hikari.pw_accumulate_samples!-Tuple{Any, AbstractVector{Float32}, AbstractVector{Float32}, Int32}",href:"#Hikari.pw_accumulate_samples!-Tuple{Any, AbstractVector{Float32}, AbstractVector{Float32}, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pw_accumulate_samples!")],-1)),i[1812]||(i[1812]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1814]||(i[1814]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_accumulate_samples!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, pixel_L_accum, pixel_L_sample, num_pixels)</span></span></code></pre></div><p>Add new sample results to accumulated film values.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1813]||(i[1813]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L387-L391",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Br,[s("summary",null,[i[1815]||(i[1815]=s("a",{id:"Hikari.pw_accumulate_to_film_kernel!-Tuple{Any}",href:"#Hikari.pw_accumulate_to_film_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_accumulate_to_film_kernel!")],-1)),i[1816]||(i[1816]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1818]||(i[1818]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_accumulate_to_film_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pixel_L_accum, pixel_L_sample, num_pixels)</span></span></code></pre></div><p>Accumulate sample results into the film accumulator. Adds new sample&#39;s spectral values to existing accumulated values.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1817]||(i[1817]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L273-L278",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Dr,[s("summary",null,[i[1819]||(i[1819]=s("a",{id:"Hikari.pw_apply_exposure!-Tuple{Any, Hikari.Film, Float32}",href:"#Hikari.pw_apply_exposure!-Tuple{Any, Hikari.Film, Float32}"},[s("span",{class:"jlbinding"},"Hikari.pw_apply_exposure!")],-1)),i[1820]||(i[1820]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1822]||(i[1822]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_apply_exposure!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, film</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Film</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, exposure</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Apply exposure adjustment to film framebuffer.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1821]||(i[1821]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L553-L557",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ir,[s("summary",null,[i[1823]||(i[1823]=s("a",{id:"Hikari.pw_apply_exposure_kernel!-Tuple{Any}",href:"#Hikari.pw_apply_exposure_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_apply_exposure_kernel!")],-1)),i[1824]||(i[1824]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1826]||(i[1826]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_apply_exposure_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(framebuffer, exposure)</span></span></code></pre></div><p>Apply exposure adjustment to framebuffer (in-place).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1825]||(i[1825]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L533-L537",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Mr,[s("summary",null,[i[1827]||(i[1827]=s("a",{id:"Hikari.pw_apply_srgb_gamma!-Tuple{Any, Hikari.Film}",href:"#Hikari.pw_apply_srgb_gamma!-Tuple{Any, Hikari.Film}"},[s("span",{class:"jlbinding"},"Hikari.pw_apply_srgb_gamma!")],-1)),i[1828]||(i[1828]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1830]||(i[1830]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_apply_srgb_gamma!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, film</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Film</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Apply sRGB gamma to framebuffer and store in postprocess buffer.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1829]||(i[1829]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L589-L593",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Gr,[s("summary",null,[i[1831]||(i[1831]=s("a",{id:"Hikari.pw_apply_srgb_gamma_kernel!-Tuple{Any}",href:"#Hikari.pw_apply_srgb_gamma_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_apply_srgb_gamma_kernel!")],-1)),i[1832]||(i[1832]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1834]||(i[1834]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_apply_srgb_gamma_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(output, input)</span></span></code></pre></div><p>Apply sRGB gamma curve to convert from linear to display sRGB.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1833]||(i[1833]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L569-L573",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Pr,[s("summary",null,[i[1835]||(i[1835]=s("a",{id:"Hikari.pw_clear_film!-Tuple{Any, AbstractVector{Float32}, Int32}",href:"#Hikari.pw_clear_film!-Tuple{Any, AbstractVector{Float32}, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pw_clear_film!")],-1)),i[1836]||(i[1836]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1838]||(i[1838]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_clear_film!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, pixel_L, num_pixels)</span></span></code></pre></div><p>Clear film accumulator to zero for a new render.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1837]||(i[1837]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L410-L414",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Vr,[s("summary",null,[i[1839]||(i[1839]=s("a",{id:"Hikari.pw_clear_film_kernel!-Tuple{Any}",href:"#Hikari.pw_clear_film_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_clear_film_kernel!")],-1)),i[1840]||(i[1840]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1842]||(i[1842]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_clear_film_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pixel_L, num_pixels)</span></span></code></pre></div><p>Clear accumulated spectral radiance to zero for new render.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1841]||(i[1841]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L295-L299",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Lr,[s("summary",null,[i[1843]||(i[1843]=s("a",{id:"Hikari.pw_evaluate_materials!",href:"#Hikari.pw_evaluate_materials!"},[s("span",{class:"jlbinding"},"Hikari.pw_evaluate_materials!")],-1)),i[1844]||(i[1844]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[1846]||(i[1846]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_evaluate_materials!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, next_ray_queue, pixel_L, material_queue, materials, rgb2spec_table, max_depth, regularize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Evaluate materials and spawn continuation rays.</p><p>When <code>regularize=true</code>, near-specular BSDFs are roughened after the first non-specular bounce to reduce fireflies (matches pbrt-v4&#39;s BSDF::Regularize).</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1845]||(i[1845]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-eval.jl#L202-L209",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",wr,[s("summary",null,[i[1847]||(i[1847]=s("a",{id:"Hikari.pw_evaluate_materials_kernel!-Tuple{Any}",href:"#Hikari.pw_evaluate_materials_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_evaluate_materials_kernel!")],-1)),i[1848]||(i[1848]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1850]||(i[1850]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_evaluate_materials_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(next_ray_queue, pixel_L, material_queue, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Evaluate materials for all work items:</p><ol><li><p>Sample BSDF for indirect lighting direction</p></li><li><p>Apply Russian roulette for path termination</p></li><li><p>Create continuation ray if path should continue</p></li></ol>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1849]||(i[1849]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-eval.jl#L87-L94",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Rr,[s("summary",null,[i[1851]||(i[1851]=s("a",{id:"Hikari.pw_finalize_film!-Tuple{Any, Hikari.Film, AbstractVector{Float32}, Int32}",href:"#Hikari.pw_finalize_film!-Tuple{Any, Hikari.Film, AbstractVector{Float32}, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pw_finalize_film!")],-1)),i[1852]||(i[1852]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1854]||(i[1854]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_finalize_film!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, film, pixel_rgb, samples_per_pixel)</span></span></code></pre></div><p>Copy accumulated RGB values to film framebuffer, dividing by sample count.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1853]||(i[1853]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L134-L138",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Nr,[s("summary",null,[i[1855]||(i[1855]=s("a",{id:"Hikari.pw_finalize_film_kernel!-Tuple{Any}",href:"#Hikari.pw_finalize_film_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_finalize_film_kernel!")],-1)),i[1856]||(i[1856]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1858]||(i[1858]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_finalize_film_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(framebuffer, pixel_rgb, inv_samples, width, height)</span></span></code></pre></div><p>Copy accumulated RGB values to film framebuffer, dividing by sample count.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1857]||(i[1857]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L103-L107",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Or,[s("summary",null,[i[1859]||(i[1859]=s("a",{id:"Hikari.pw_generate_camera_rays!-Tuple{Any, Hikari.WorkQueue{Hikari.PWRayWorkItem, V} where V<:AbstractVector{Hikari.PWRayWorkItem}, AbstractVector{Float32}, AbstractVector{Float32}, Int32, Int32, Any, Int32, UInt32}",href:"#Hikari.pw_generate_camera_rays!-Tuple{Any, Hikari.WorkQueue{Hikari.PWRayWorkItem, V} where V<:AbstractVector{Hikari.PWRayWorkItem}, AbstractVector{Float32}, AbstractVector{Float32}, Int32, Int32, Any, Int32, UInt32}"},[s("span",{class:"jlbinding"},"Hikari.pw_generate_camera_rays!")],-1)),i[1860]||(i[1860]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1862]||(i[1862]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_generate_camera_rays!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, ray_queue, wavelengths_per_pixel, pdf_per_pixel,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                          width, height, camera, sample_idx, rng_base)</span></span></code></pre></div><p>Generate camera rays with per-pixel wavelength sampling (pbrt-v4 style). Each pixel samples its own wavelengths, which are stored for later film accumulation.</p>`,2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1861]||(i[1861]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/camera.jl#L89-L95",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Jr,[s("summary",null,[i[1863]||(i[1863]=s("a",{id:"Hikari.pw_generate_camera_rays_kernel!-Tuple{Any}",href:"#Hikari.pw_generate_camera_rays_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_generate_camera_rays_kernel!")],-1)),i[1864]||(i[1864]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1866]||(i[1866]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_generate_camera_rays_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ray_queue, wavelengths_per_pixel, pdf_per_pixel,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                 width, height, camera, sample_idx, rng_base)</span></span></code></pre></div><p>Generate camera rays for all pixels with PER-PIXEL wavelength sampling. Each thread generates one camera ray with independently sampled wavelengths.</p><p>This matches pbrt-v4&#39;s approach where each pixel samples its own wavelengths, which decorrelates color noise across pixels for faster convergence.</p>`,3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1865]||(i[1865]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/camera.jl#L12-L21",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Wr,[s("summary",null,[i[1867]||(i[1867]=s("a",{id:"Hikari.pw_handle_escaped_rays!-Tuple{Any, AbstractVector{Float32}, Hikari.WorkQueue{Hikari.PWEscapedRayWorkItem, V} where V<:AbstractVector{Hikari.PWEscapedRayWorkItem}, Any, Hikari.RGBToSpectrumTable}",href:"#Hikari.pw_handle_escaped_rays!-Tuple{Any, AbstractVector{Float32}, Hikari.WorkQueue{Hikari.PWEscapedRayWorkItem, V} where V<:AbstractVector{Hikari.PWEscapedRayWorkItem}, Any, Hikari.RGBToSpectrumTable}"},[s("span",{class:"jlbinding"},"Hikari.pw_handle_escaped_rays!")],-1)),i[1868]||(i[1868]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1870]||(i[1870]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_handle_escaped_rays!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, pixel_L, escaped_queue, lights, rgb2spec_table)</span></span></code></pre></div><p>Evaluate environment lights for escaped rays.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1869]||(i[1869]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L474-L478",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ur,[s("summary",null,[i[1871]||(i[1871]=s("a",{id:"Hikari.pw_handle_escaped_rays_kernel!-Tuple{Any}",href:"#Hikari.pw_handle_escaped_rays_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_handle_escaped_rays_kernel!")],-1)),i[1872]||(i[1872]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1874]||(i[1874]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_handle_escaped_rays_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pixel_L, escaped_queue, lights, rgb2spec_table, max_queued)</span></span></code></pre></div><p>Handle rays that escaped the scene by evaluating environment lights.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1873]||(i[1873]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L284-L288",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",qr,[s("summary",null,[i[1875]||(i[1875]=s("a",{id:"Hikari.pw_handle_hit_area_lights!-Tuple{Any, AbstractVector{Float32}, Hikari.WorkQueue{Hikari.PWHitAreaLightWorkItem, V} where V<:AbstractVector{Hikari.PWHitAreaLightWorkItem}, Any, Any}",href:"#Hikari.pw_handle_hit_area_lights!-Tuple{Any, AbstractVector{Float32}, Hikari.WorkQueue{Hikari.PWHitAreaLightWorkItem, V} where V<:AbstractVector{Hikari.PWHitAreaLightWorkItem}, Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_handle_hit_area_lights!")],-1)),i[1876]||(i[1876]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1878]||(i[1878]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_handle_hit_area_lights!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, pixel_L, hit_light_queue, rgb2spec_table, materials)</span></span></code></pre></div><p>Evaluate emission for rays that hit area lights.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1877]||(i[1877]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L501-L505",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",zr,[s("summary",null,[i[1879]||(i[1879]=s("a",{id:"Hikari.pw_handle_hit_area_lights_kernel!-Tuple{Any}",href:"#Hikari.pw_handle_hit_area_lights_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_handle_hit_area_lights_kernel!")],-1)),i[1880]||(i[1880]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1882]||(i[1882]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_handle_hit_area_lights_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pixel_L, hit_light_queue, rgb2spec_table, materials, max_queued)</span></span></code></pre></div><p>Handle rays that hit emissive surfaces.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1881]||(i[1881]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L364-L368",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Kr,[s("summary",null,[i[1883]||(i[1883]=s("a",{id:"Hikari.pw_populate_aux_buffers!-Tuple{Any, AbstractVector{Float32}, AbstractVector{Float32}, AbstractVector{Float32}, Hikari.WorkQueue{Hikari.PWMaterialEvalWorkItem, V} where V<:AbstractVector{Hikari.PWMaterialEvalWorkItem}, Any, Hikari.RGBToSpectrumTable}",href:"#Hikari.pw_populate_aux_buffers!-Tuple{Any, AbstractVector{Float32}, AbstractVector{Float32}, AbstractVector{Float32}, Hikari.WorkQueue{Hikari.PWMaterialEvalWorkItem, V} where V<:AbstractVector{Hikari.PWMaterialEvalWorkItem}, Any, Hikari.RGBToSpectrumTable}"},[s("span",{class:"jlbinding"},"Hikari.pw_populate_aux_buffers!")],-1)),i[1884]||(i[1884]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1886]||(i[1886]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_populate_aux_buffers!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, aux_albedo, aux_normal, aux_depth,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                          material_queue, materials, rgb2spec_table)</span></span></code></pre></div><p>Populate auxiliary buffers for denoising.</p>`,2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1885]||(i[1885]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-eval.jl#L296-L301",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Zr,[s("summary",null,[i[1887]||(i[1887]=s("a",{id:"Hikari.pw_populate_aux_buffers_kernel!-Tuple{Any}",href:"#Hikari.pw_populate_aux_buffers_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_populate_aux_buffers_kernel!")],-1)),i[1888]||(i[1888]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1890]||(i[1890]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_populate_aux_buffers_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(aux_albedo, aux_normal, aux_depth, material_queue, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Populate auxiliary buffers for denoising on first bounce. Only processes depth=0 items (primary ray hits).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1889]||(i[1889]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-eval.jl#L242-L247",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xr,[s("summary",null,[i[1891]||(i[1891]=s("a",{id:"Hikari.pw_sample_direct_lighting!-Tuple{Any, Hikari.WorkQueue{Hikari.PWShadowRayWorkItem, V} where V<:AbstractVector{Hikari.PWShadowRayWorkItem}, Hikari.WorkQueue{Hikari.PWMaterialEvalWorkItem, V} where V<:AbstractVector{Hikari.PWMaterialEvalWorkItem}, Any, Any, Hikari.RGBToSpectrumTable}",href:"#Hikari.pw_sample_direct_lighting!-Tuple{Any, Hikari.WorkQueue{Hikari.PWShadowRayWorkItem, V} where V<:AbstractVector{Hikari.PWShadowRayWorkItem}, Hikari.WorkQueue{Hikari.PWMaterialEvalWorkItem, V} where V<:AbstractVector{Hikari.PWMaterialEvalWorkItem}, Any, Any, Hikari.RGBToSpectrumTable}"},[s("span",{class:"jlbinding"},"Hikari.pw_sample_direct_lighting!")],-1)),i[1892]||(i[1892]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1894]||(i[1894]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_sample_direct_lighting!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, shadow_queue, material_queue, materials, lights, rgb2spec_table)</span></span></code></pre></div><p>Sample direct lighting for all material work items.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1893]||(i[1893]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-eval.jl#L165-L169",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Yr,[s("summary",null,[i[1895]||(i[1895]=s("a",{id:"Hikari.pw_sample_direct_lighting_kernel!-Tuple{Any}",href:"#Hikari.pw_sample_direct_lighting_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_sample_direct_lighting_kernel!")],-1)),i[1896]||(i[1896]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1898]||(i[1898]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_sample_direct_lighting_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(shadow_queue, material_queue, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sample direct lighting for all material evaluation work items. For each item, selects a light, samples a direction, evaluates BSDF, and creates a shadow ray work item.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1897]||(i[1897]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-eval.jl#L11-L17",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Qr,[s("summary",null,[i[1899]||(i[1899]=s("a",{id:"Hikari.pw_trace_rays!-Tuple{Any, Hikari.WorkQueue{Hikari.PWEscapedRayWorkItem, V} where V<:AbstractVector{Hikari.PWEscapedRayWorkItem}, Hikari.WorkQueue{Hikari.PWHitAreaLightWorkItem, V} where V<:AbstractVector{Hikari.PWHitAreaLightWorkItem}, Hikari.WorkQueue{Hikari.PWMaterialEvalWorkItem, V} where V<:AbstractVector{Hikari.PWMaterialEvalWorkItem}, Hikari.WorkQueue{Hikari.PWRayWorkItem, V} where V<:AbstractVector{Hikari.PWRayWorkItem}, Any, Any}",href:"#Hikari.pw_trace_rays!-Tuple{Any, Hikari.WorkQueue{Hikari.PWEscapedRayWorkItem, V} where V<:AbstractVector{Hikari.PWEscapedRayWorkItem}, Hikari.WorkQueue{Hikari.PWHitAreaLightWorkItem, V} where V<:AbstractVector{Hikari.PWHitAreaLightWorkItem}, Hikari.WorkQueue{Hikari.PWMaterialEvalWorkItem, V} where V<:AbstractVector{Hikari.PWMaterialEvalWorkItem}, Hikari.WorkQueue{Hikari.PWRayWorkItem, V} where V<:AbstractVector{Hikari.PWRayWorkItem}, Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_trace_rays!")],-1)),i[1900]||(i[1900]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1902]||(i[1902]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_trace_rays!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, escaped_queue, hit_light_queue, material_queue,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               ray_queue, accel, materials)</span></span></code></pre></div><p>Trace all rays in ray_queue and populate output queues.</p>`,2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1901]||(i[1901]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L416-L421",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$r,[s("summary",null,[i[1903]||(i[1903]=s("a",{id:"Hikari.pw_trace_rays_kernel!-Tuple{Any}",href:"#Hikari.pw_trace_rays_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_trace_rays_kernel!")],-1)),i[1904]||(i[1904]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1906]||(i[1906]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_trace_rays_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Trace rays from ray_queue, handle hits and misses:</p><ul><li><p>Misses -&gt; push to escaped_ray_queue (for environment light)</p></li><li><p>Hits on emissive -&gt; push to hit_area_light_queue</p></li><li><p>Hits on non-emissive -&gt; push to material_eval_queue</p></li></ul><p>This kernel does NOT generate shadow rays - that happens in direct lighting.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1905]||(i[1905]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L8-L17",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ip,[s("summary",null,[i[1907]||(i[1907]=s("a",{id:"Hikari.pw_trace_shadow_rays!-Tuple{Any, AbstractVector{Float32}, Hikari.WorkQueue{Hikari.PWShadowRayWorkItem, V} where V<:AbstractVector{Hikari.PWShadowRayWorkItem}, Any}",href:"#Hikari.pw_trace_shadow_rays!-Tuple{Any, AbstractVector{Float32}, Hikari.WorkQueue{Hikari.PWShadowRayWorkItem, V} where V<:AbstractVector{Hikari.PWShadowRayWorkItem}, Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_trace_shadow_rays!")],-1)),i[1908]||(i[1908]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1910]||(i[1910]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_trace_shadow_rays!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, pixel_L, shadow_queue, accel)</span></span></code></pre></div><p>Trace shadow rays and accumulate unoccluded contributions.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1909]||(i[1909]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L453-L457",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",sp,[s("summary",null,[i[1911]||(i[1911]=s("a",{id:"Hikari.pw_trace_shadow_rays_kernel!-Tuple{Any}",href:"#Hikari.pw_trace_shadow_rays_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_trace_shadow_rays_kernel!")],-1)),i[1912]||(i[1912]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1914]||(i[1914]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_trace_shadow_rays_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(pixel_L, shadow_queue, accel, max_queued)</span></span></code></pre></div><p>Trace shadow rays and accumulate unoccluded contributions to pixel buffer.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1913]||(i[1913]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/intersection.jl#L233-L237",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ep,[s("summary",null,[i[1915]||(i[1915]=s("a",{id:"Hikari.pw_update_aux_from_material_queue!-Tuple{Any, Hikari.Film, Hikari.WorkQueue{Hikari.PWMaterialEvalWorkItem, V} where V<:AbstractVector{Hikari.PWMaterialEvalWorkItem}, Any, Hikari.RGBToSpectrumTable}",href:"#Hikari.pw_update_aux_from_material_queue!-Tuple{Any, Hikari.Film, Hikari.WorkQueue{Hikari.PWMaterialEvalWorkItem, V} where V<:AbstractVector{Hikari.PWMaterialEvalWorkItem}, Any, Hikari.RGBToSpectrumTable}"},[s("span",{class:"jlbinding"},"Hikari.pw_update_aux_from_material_queue!")],-1)),i[1916]||(i[1916]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1918]||(i[1918]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_update_aux_from_material_queue!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, film, material_queue, materials, rgb2spec_table)</span></span></code></pre></div><p>Update film auxiliary buffers (albedo, normal, depth) from first-bounce material hits.</p><p>This extracts albedo from materials during the wavefront pipeline, unlike the separate fill_aux_buffers! which traces primary rays again.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1917]||(i[1917]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L435-L442",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",tp,[s("summary",null,[i[1919]||(i[1919]=s("a",{id:"Hikari.pw_update_aux_kernel!-Tuple{Any}",href:"#Hikari.pw_update_aux_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_update_aux_kernel!")],-1)),i[1920]||(i[1920]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1922]||(i[1922]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_update_aux_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(aux_albedo, aux_normal, aux_depth,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                       material_queue_items, material_queue_size,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                       materials, rgb2spec_table,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                       width, height, max_queued)</span></span></code></pre></div><p>Kernel to update auxiliary buffers from depth=0 material queue items.</p>`,2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1921]||(i[1921]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L472-L479",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ap,[s("summary",null,[i[1923]||(i[1923]=s("a",{id:"Hikari.pw_update_film_perPixel!-Tuple{Any, Hikari.Film, AbstractVector{Float32}, AbstractVector{Float32}, AbstractVector{Float32}, Hikari.CIEXYZTable, Int32}",href:"#Hikari.pw_update_film_perPixel!-Tuple{Any, Hikari.Film, AbstractVector{Float32}, AbstractVector{Float32}, AbstractVector{Float32}, Hikari.CIEXYZTable, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pw_update_film_perPixel!")],-1)),i[1924]||(i[1924]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1926]||(i[1926]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_update_film_perPixel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, film, pixel_L, wavelengths_per_pixel,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                          pdf_per_pixel, cie_table, samples_accumulated)</span></span></code></pre></div><p>Update film framebuffer with per-pixel wavelength data. Uses proper kernel with CIE table arrays passed explicitly.</p>`,2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1925]||(i[1925]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L315-L321",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",lp,[s("summary",null,[i[1927]||(i[1927]=s("a",{id:"Hikari.pw_update_film_spectral_kernel!-Tuple{Any}",href:"#Hikari.pw_update_film_spectral_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_update_film_spectral_kernel!")],-1)),i[1928]||(i[1928]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1930]||(i[1930]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_update_film_spectral_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(framebuffer, pixel_L, wavelengths_per_pixel,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                 pdf_per_pixel, cie_x, cie_y, cie_z,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                 samples_accumulated, width, height)</span></span></code></pre></div><p>Convert accumulated spectral radiance to RGB and update film framebuffer.</p><p>Each pixel stores 4 spectral values in pixel_L (interleaved), and wavelengths_per_pixel stores the sampled wavelengths. Uses CIE XYZ color matching for accurate conversion.</p>`,3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1929]||(i[1929]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L166-L175",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",np,[s("summary",null,[i[1931]||(i[1931]=s("a",{id:"Hikari.pw_update_film_uniform!-Tuple{Any, Hikari.Film, AbstractVector{Float32}, Hikari.CIEXYZTable, Hikari.SampledWavelengths{4}, Int32}",href:"#Hikari.pw_update_film_uniform!-Tuple{Any, Hikari.Film, AbstractVector{Float32}, Hikari.CIEXYZTable, Hikari.SampledWavelengths{4}, Int32}"},[s("span",{class:"jlbinding"},"Hikari.pw_update_film_uniform!")],-1)),i[1932]||(i[1932]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1934]||(i[1934]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_update_film_uniform!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, film, pixel_L, cie_table, lambda, samples_accumulated)</span></span></code></pre></div><p>Update film framebuffer using uniform wavelength sampling (all pixels share wavelengths).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1933]||(i[1933]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L353-L357",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",rp,[s("summary",null,[i[1935]||(i[1935]=s("a",{id:"Hikari.pw_update_film_uniform_kernel!-Tuple{Any}",href:"#Hikari.pw_update_film_uniform_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.pw_update_film_uniform_kernel!")],-1)),i[1936]||(i[1936]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1938]||(i[1938]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">pw_update_film_uniform_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(framebuffer, pixel_L, cie_x, cie_y, cie_z,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                                lambda, samples_accumulated, width, height)</span></span></code></pre></div><p>Convert accumulated spectral radiance to RGB using uniform wavelength sampling.</p><p>When using stratified wavelength sampling, all pixels share the same wavelengths within a sample iteration. This kernel uses a single Wavelengths value for all pixels.</p>`,3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1937]||(i[1937]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/film-update.jl#L222-L230",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",pp,[s("summary",null,[i[1939]||(i[1939]=s("a",{id:"Hikari.r2_sample-Tuple{Int32}",href:"#Hikari.r2_sample-Tuple{Int32}"},[s("span",{class:"jlbinding"},"Hikari.r2_sample")],-1)),i[1940]||(i[1940]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1942]||(i[1942]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">r2_sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Tuple{Float32, Float32}</span></span></code></pre></div><p>Generate the n-th point of the R2 quasi-random sequence. The R2 sequence has excellent 2D discrepancy properties.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1941]||(i[1941]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L115-L120",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",op,[s("summary",null,[i[1943]||(i[1943]=s("a",{id:"Hikari.r2_sample_rotated-Tuple{Int32, Float32, Float32}",href:"#Hikari.r2_sample_rotated-Tuple{Int32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.r2_sample_rotated")],-1)),i[1944]||(i[1944]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1946]||(i[1946]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">r2_sample_rotated</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, offset_x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, offset_y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Tuple{Float32, Float32}</span></span></code></pre></div><p>Generate the n-th point of the R2 sequence with Cranley-Patterson rotation. The offset is typically derived from a hash of the pixel coordinates.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1945]||(i[1945]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L128-L133",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",dp,[s("summary",null,[i[1947]||(i[1947]=s("a",{id:"Hikari.ray_bounds_intersect-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Raycore.Bounds3}",href:"#Hikari.ray_bounds_intersect-Tuple{GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Raycore.Bounds3}"},[s("span",{class:"jlbinding"},"Hikari.ray_bounds_intersect")],-1)),i[1948]||(i[1948]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1950]||(i[1950]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ray_bounds_intersect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ray_o, ray_d, bounds) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (t_min, t_max)</span></span></code></pre></div><p>Compute ray-AABB intersection. Returns (Inf, -Inf) if no intersection. Uses scalar operations for GPU compatibility.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1949]||(i[1949]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1698-L1703",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",kp,[s("summary",null,[i[1951]||(i[1951]=s("a",{id:"Hikari.ray_majorant_next-Union{Tuple{M}, Tuple{Hikari.RayMajorantIterator{M}, Any}} where M",href:"#Hikari.ray_majorant_next-Union{Tuple{M}, Tuple{Hikari.RayMajorantIterator{M}, Any}} where M"},[s("span",{class:"jlbinding"},"Hikari.ray_majorant_next")],-1)),i[1952]||(i[1952]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1954]||(i[1954]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ray_majorant_next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RayMajorantIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, media) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (RayMajorantSegment, RayMajorantIterator, Bool)</span></span></code></pre></div><p>Advance the unified iterator and return the next majorant segment. Dispatches internally based on mode (homogeneous vs DDA). Returns (segment, new_iter, valid) where valid=false means exhausted.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1953]||(i[1953]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L618-L624",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",hp,[s("summary",null,[i[1955]||(i[1955]=s("a",{id:"Hikari.reflect-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.reflect-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.reflect")],-1)),i[1956]||(i[1956]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1958]||(i[1958]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reflect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, n) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> wi</span></span></code></pre></div><p>Compute reflected direction: wi = -wo + 2_dot(wo,n)_n</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1957]||(i[1957]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1122-L1126",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",up,[s("summary",null,[i[1959]||(i[1959]=s("a",{id:"Hikari.refract-Tuple{GeometryBasics.Vec{3, Float32}, Raycore.Normal3f, Float32}",href:"#Hikari.refract-Tuple{GeometryBasics.Vec{3, Float32}, Raycore.Normal3f, Float32}"},[s("span",{class:"jlbinding"},"Hikari.refract")],-1)),i[1960]||(i[1960]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1962]||(i[1962]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">refract</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Normal3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, eta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (valid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute refracted direction <code>wt</code> given an incident direction <code>wi</code>, surface normal <code>n</code>, and <code>eta</code> = n_t / n_i (ratio of transmitted to incident IOR).</p><p>This matches pbrt-v4&#39;s Refract() function exactly:</p><ul><li><p>If wi comes from below the surface (cos_θi &lt; 0), the interface is flipped</p></li><li><p>Returns (false, zero) for total internal reflection</p></li><li><p>Returns (true, wt) with the refracted direction otherwise</p></li></ul><p>The convention is: eta = n_transmitted / n_incident</p><ul><li><p>For ray entering glass (n_i=1, n_t=1.5): eta = 1.5</p></li><li><p>For ray exiting glass (n_i=1.5, n_t=1): eta = 1/1.5 ≈ 0.67</p></li></ul>',6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1961]||(i[1961]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/bxdf.jl#L14-L28",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",gp,[s("summary",null,[i[1963]||(i[1963]=s("a",{id:"Hikari.refract_microfacet-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32}",href:"#Hikari.refract_microfacet-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.refract_microfacet")],-1)),i[1964]||(i[1964]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1966]||(i[1966]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">refract_microfacet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, wm, eta) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (valid, wi, etap)</span></span></code></pre></div><p>Compute refracted direction through a microfacet with normal wm.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1965]||(i[1965]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1095-L1099",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",cp,[s("summary",null,[i[1967]||(i[1967]=s("a",{id:"Hikari.refract_pbrt-Tuple{GeometryBasics.Vec{3, Float32}, Float32}",href:"#Hikari.refract_pbrt-Tuple{GeometryBasics.Vec{3, Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.refract_pbrt")],-1)),i[1968]||(i[1968]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1970]||(i[1970]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">refract_pbrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, eta) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (valid, wi, etap)</span></span></code></pre></div><p>Compute refracted direction using pbrt-v4 convention. eta = n_transmitted / n_incident Returns (valid, wi, effective_eta).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1969]||(i[1969]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1065-L1071",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",bp,[s("summary",null,[i[1971]||(i[1971]=s("a",{id:"Hikari.regularize_alpha-Tuple{Float32}",href:"#Hikari.regularize_alpha-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.regularize_alpha")],-1)),i[1972]||(i[1972]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1974]||(i[1974]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">regularize_alpha</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(α</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Regularize a microfacet distribution alpha value to reduce fireflies from near-specular paths. Matches pbrt-v4&#39;s TrowbridgeReitzDistribution::Regularize().</p><p>If α &lt; 0.3, doubles it and clamps to [0.1, 0.3]. This increases the roughness of near-specular surfaces after the first non-specular bounce, reducing variance from paths that hit nearly-specular surfaces.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1973]||(i[1973]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/microfacet.jl#L87-L96",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",yp,[s("summary",null,[i[1975]||(i[1975]=s("a",{id:"Hikari.render!-Tuple{Hikari.VolPath, Hikari.AbstractScene, Hikari.Film, Hikari.Camera}",href:"#Hikari.render!-Tuple{Hikari.VolPath, Hikari.AbstractScene, Hikari.Film, Hikari.Camera}"},[s("span",{class:"jlbinding"},"Hikari.render!")],-1)),i[1976]||(i[1976]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1978]||(i[1978]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">render!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VolPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, scene, film, camera)</span></span></code></pre></div><p>Render one iteration/sample using volumetric spectral wavefront path tracing.</p><p>This function is allocation-free and renders a single sample, accumulating results in the film. The iteration index is read from and incremented in <code>film.iteration_index</code>.</p><p>For progressive rendering, call this repeatedly. For complete rendering, use the main call function <code>(vp::VolPath)(scene, film, camera)</code> which wraps this in a loop.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1977]||(i[1977]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath.jl#L441-L453",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",mp,[s("summary",null,[i[1979]||(i[1979]=s("a",{id:"Hikari.reset_film!-Tuple{Hikari.VolPathState}",href:"#Hikari.reset_film!-Tuple{Hikari.VolPathState}"},[s("span",{class:"jlbinding"},"Hikari.reset_film!")],-1)),i[1980]||(i[1980]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1982]||(i[1982]=s("p",null,"Reset film buffer for a new sample.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1981]||(i[1981]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath-state.jl#L224",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fp,[s("summary",null,[i[1983]||(i[1983]=s("a",{id:"Hikari.reset_iteration_queues!-Tuple{Hikari.VolPathState}",href:"#Hikari.reset_iteration_queues!-Tuple{Hikari.VolPathState}"},[s("span",{class:"jlbinding"},"Hikari.reset_iteration_queues!")],-1)),i[1984]||(i[1984]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1986]||(i[1986]=s("p",null,"Reset iteration queues before ray tracing.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1985]||(i[1985]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath-state.jl#L213",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ep,[s("summary",null,[i[1987]||(i[1987]=s("a",{id:"Hikari.reset_processing_queues!-Tuple{Hikari.VolPathState}",href:"#Hikari.reset_processing_queues!-Tuple{Hikari.VolPathState}"},[s("span",{class:"jlbinding"},"Hikari.reset_processing_queues!")],-1)),i[1988]||(i[1988]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1990]||(i[1990]=s("p",null,"Reset all processing queues for a new bounce.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1989]||(i[1989]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath-state.jl#L202",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_p,[s("summary",null,[i[1991]||(i[1991]=s("a",{id:"Hikari.reset_queues!-Union{Tuple{N}, Tuple{Any, Hikari.MultiMaterialQueue{N}}} where N",href:"#Hikari.reset_queues!-Union{Tuple{N}, Tuple{Any, Hikari.MultiMaterialQueue{N}}} where N"},[s("span",{class:"jlbinding"},"Hikari.reset_queues!")],-1)),i[1992]||(i[1992]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1994]||(i[1994]=s("p",null,"Reset all queues",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1993]||(i[1993]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/multi-material-eval.jl#L42",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Tp,[s("summary",null,[i[1995]||(i[1995]=s("a",{id:"Hikari.resolve_mix_material-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.resolve_mix_material-Tuple{Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.resolve_mix_material")],-1)),i[1996]||(i[1996]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[1998]||(i[1998]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">resolve_mix_material</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p, wo, uv) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SetKey</span></span></code></pre></div><p>Resolve any MixMaterial chain to get the final material index. Handles nested MixMaterials by iterating until a non-mix material is found. <code>materials</code> is used both for material lookup and texture evaluation.</p><p>This should be called at intersection time before creating material work items.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[1997]||(i[1997]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/mix-material.jl#L244-L252",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",jp,[s("summary",null,[i[1999]||(i[1999]=s("a",{id:"Hikari.rgb_illuminant_spectrum-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32}",href:"#Hikari.rgb_illuminant_spectrum-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.rgb_illuminant_spectrum")],-1)),i[2e3]||(i[2e3]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2002]||(i[2002]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_illuminant_spectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, r, g, b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBIlluminantSpectrum</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_illuminant_spectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBIlluminantSpectrum</span></span></code></pre></div><p>Create an illuminant spectrum from RGB values, matching pbrt-v4&#39;s RGBIlluminantSpectrum constructor.</p>`,2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2001]||(i[2001]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L365-L370",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fp,[s("summary",null,[i[2003]||(i[2003]=s("a",{id:"Hikari.rgb_to_spectral-Tuple{Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}",href:"#Hikari.rgb_to_spectral-Tuple{Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectral")],-1)),i[2004]||(i[2004]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2006]||(i[2006]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Convert Hikari&#39;s RGBSpectrum to spectral radiance at given wavelengths.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2005]||(i[2005]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L72-L76",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Cp,[s("summary",null,[i[2007]||(i[2007]=s("a",{id:"Hikari.rgb_to_spectral_at_wavelength-NTuple{4, Float32}",href:"#Hikari.rgb_to_spectral_at_wavelength-NTuple{4, Float32}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectral_at_wavelength")],-1)),i[2008]||(i[2008]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2010]||(i[2010]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectral_at_wavelength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, g, b, λ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get spectral value at a single wavelength from RGB. Uses smooth blending between spectral bands.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2009]||(i[2009]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L38-L43",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",vp,[s("summary",null,[i[2011]||(i[2011]=s("a",{id:"Hikari.rgb_to_spectral_sigmoid-Tuple{Float32, Float32, Float32, Hikari.SampledWavelengths{4}}",href:"#Hikari.rgb_to_spectral_sigmoid-Tuple{Float32, Float32, Float32, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectral_sigmoid")],-1)),i[2012]||(i[2012]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2014]||(i[2014]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectral_sigmoid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Convert RGB to spectral radiance using sigmoid polynomial method (pbrt-v4 style). This provides the smoothest spectra and lowest variance for spectral rendering.</p><p>Note: Uses global table, not GPU-compatible. Use the version with explicit table for GPU kernels.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2013]||(i[2013]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L237-L244",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Hp,[s("summary",null,[i[2015]||(i[2015]=s("a",{id:"Hikari.rgb_to_spectral_sigmoid-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32, Hikari.SampledWavelengths{4}}",href:"#Hikari.rgb_to_spectral_sigmoid-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectral_sigmoid")],-1)),i[2016]||(i[2016]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2018]||(i[2018]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectral_sigmoid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, r, g, b, lambda) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>GPU-compatible version that takes an explicit table parameter.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2017]||(i[2017]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L250-L254",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ap,[s("summary",null,[i[2019]||(i[2019]=s("a",{id:"Hikari.rgb_to_spectral_sigmoid_illuminant-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32, Hikari.SampledWavelengths{4}}",href:"#Hikari.rgb_to_spectral_sigmoid_illuminant-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectral_sigmoid_illuminant")],-1)),i[2020]||(i[2020]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2022]||(i[2022]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectral_sigmoid_illuminant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, r, g, b, lambda) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Convert RGB to spectral radiance for illuminants/light sources. Following pbrt-v4&#39;s RGBIlluminantSpectrum: multiplies sigmoid polynomial by D65 illuminant.</p><p>This is the correct conversion for environment maps and other light sources that are specified in sRGB. The D65 multiplication is necessary because sRGB&#39;s white point is D65, so an RGB=(1,1,1) light source should emit a D65-like spectrum.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2021]||(i[2021]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L504-L513",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Sp,[s("summary",null,[i[2023]||(i[2023]=s("a",{id:"Hikari.rgb_to_spectral_sigmoid_unbounded-Tuple{Float32, Float32, Float32, Hikari.SampledWavelengths{4}}",href:"#Hikari.rgb_to_spectral_sigmoid_unbounded-Tuple{Float32, Float32, Float32, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectral_sigmoid_unbounded")],-1)),i[2024]||(i[2024]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2026]||(i[2026]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectral_sigmoid_unbounded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Convert RGB to spectral radiance for unbounded values (emission/illumination). Scales the spectrum to preserve the maximum RGB component.</p><p>Note: Uses global table, not GPU-compatible. Use the version with explicit table for GPU kernels.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2025]||(i[2025]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L268-L275",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xp,[s("summary",null,[i[2027]||(i[2027]=s("a",{id:"Hikari.rgb_to_spectral_sigmoid_unbounded-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32, Hikari.SampledWavelengths{4}}",href:"#Hikari.rgb_to_spectral_sigmoid_unbounded-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectral_sigmoid_unbounded")],-1)),i[2028]||(i[2028]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2030]||(i[2030]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectral_sigmoid_unbounded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, r, g, b, lambda) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>GPU-compatible version that takes an explicit table parameter.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2029]||(i[2029]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L281-L285",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Bp,[s("summary",null,[i[2031]||(i[2031]=s("a",{id:"Hikari.rgb_to_spectral_simple-Tuple{Float32, Float32, Float32, Hikari.SampledWavelengths{4}}",href:"#Hikari.rgb_to_spectral_simple-Tuple{Float32, Float32, Float32, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectral_simple")],-1)),i[2032]||(i[2032]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2034]||(i[2034]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectral_simple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Convert RGB to spectral radiance using a simple piecewise linear model. This is a simplified uplift that treats RGB as spectral bands.</p><p>For each wavelength λ:</p><ul><li><p>Blue region (380-490nm): primarily B channel</p></li><li><p>Green region (490-580nm): primarily G channel</p></li><li><p>Red region (580-780nm): primarily R channel</p></li></ul><p>With smooth transitions between regions.</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2033]||(i[2033]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L14-L26",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Dp,[s("summary",null,[i[2035]||(i[2035]=s("a",{id:"Hikari.rgb_to_spectral_smits-Tuple{Float32, Float32, Float32, Hikari.SampledWavelengths{4}}",href:"#Hikari.rgb_to_spectral_smits-Tuple{Float32, Float32, Float32, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectral_smits")],-1)),i[2036]||(i[2036]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2038]||(i[2038]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectral_smits</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, g</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Convert RGB to spectral radiance using Smits&#39; method. More accurate than the simple piecewise linear approach.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2037]||(i[2037]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L155-L160",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ip,[s("summary",null,[i[2039]||(i[2039]=s("a",{id:"Hikari.rgb_to_spectral_smits_at_wavelength-NTuple{4, Float32}",href:"#Hikari.rgb_to_spectral_smits_at_wavelength-NTuple{4, Float32}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectral_smits_at_wavelength")],-1)),i[2040]||(i[2040]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2042]||(i[2042]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectral_smits_at_wavelength</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, g, b, λ) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute spectral value at wavelength λ using Smits&#39; method.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2041]||(i[2041]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L172-L176",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Mp,[s("summary",null,[i[2043]||(i[2043]=s("a",{id:"Hikari.rgb_to_spectrum-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32}",href:"#Hikari.rgb_to_spectrum-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectrum")],-1)),i[2044]||(i[2044]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2046]||(i[2046]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, rgb) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBSigmoidPolynomial</span></span></code></pre></div><p>Convert an RGB color to a sigmoid polynomial spectrum representation. RGB values should be in [0, 1] range.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2045]||(i[2045]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L77-L82",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Gp,[s("summary",null,[i[2047]||(i[2047]=s("a",{id:"Hikari.rgb_to_spectrum_coeffs-Tuple{AbstractVector{Float32}, AbstractArray{Float32, 5}, Int32, Float32, Float32, Float32}",href:"#Hikari.rgb_to_spectrum_coeffs-Tuple{AbstractVector{Float32}, AbstractArray{Float32, 5}, Int32, Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.rgb_to_spectrum_coeffs")],-1)),i[2048]||(i[2048]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2050]||(i[2050]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb_to_spectrum_coeffs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scale, coeffs, res, r, g, b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (c0, c1, c2)</span></span></code></pre></div><p>GPU-compatible version that takes raw arrays and returns coefficient tuple.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2049]||(i[2049]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L177-L181",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Pp,[s("summary",null,[i[2051]||(i[2051]=s("a",{id:"Hikari.rgb_unbounded_spectrum-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32}",href:"#Hikari.rgb_unbounded_spectrum-Tuple{Hikari.RGBToSpectrumTable, Float32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.rgb_unbounded_spectrum")],-1)),i[2052]||(i[2052]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2054]||(i[2054]=s("p",null,"Create unbounded spectrum from RGB (for lights/emission)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2053]||(i[2053]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L304",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Vp,[s("summary",null,[i[2055]||(i[2055]=s("a",{id:"Hikari.rotation_matrix-Tuple{Real, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.rotation_matrix-Tuple{Real, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.rotation_matrix")],-1)),i[2056]||(i[2056]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2058]||(i[2058]=s("p",null,"Create rotation matrix from axis-angle representation (like pbrt's Rotate command). angle: rotation angle in degrees axis: rotation axis (will be normalized)",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2057]||(i[2057]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L47-L51",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Lp,[s("summary",null,[i[2059]||(i[2059]=s("a",{id:"Hikari.roughness_to_α-Tuple{Float32}",href:"#Hikari.roughness_to_α-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.roughness_to_α")],-1)),i[2060]||(i[2060]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2062]||(i[2062]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">roughness_to_α</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(roughness</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Map [0, 1] scalar roughness to microfacet distribution alpha parameter.</p><p>Matches pbrt-v4&#39;s TrowbridgeReitzDistribution::RoughnessToAlpha which uses sqrt(roughness). This provides a more intuitive perceptual mapping where roughness values close to zero give near-perfect specular reflection.</p><p>Note: pbrt-v4 comments suggest Sqr(roughness) might be more perceptually uniform, but sqrt is retained for compatibility with existing scenes.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2061]||(i[2061]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/microfacet.jl#L71-L82",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",wp,[s("summary",null,[i[2063]||(i[2063]=s("a",{id:"Hikari.russian_roulette_spectral",href:"#Hikari.russian_roulette_spectral"},[s("span",{class:"jlbinding"},"Hikari.russian_roulette_spectral")],-1)),i[2064]||(i[2064]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2066]||(i[2066]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">russian_roulette_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(beta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpectralRadiance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rr_sample</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_depth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Apply Russian roulette for path termination. Returns (should_continue::Bool, new_beta::SpectralRadiance).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2065]||(i[2065]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L257-L262",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Rp,[s("summary",null,[i[2067]||(i[2067]=s("a",{id:"Hikari.same_hemisphere-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.same_hemisphere-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.same_hemisphere")],-1)),i[2068]||(i[2068]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2070]||(i[2070]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">same_hemisphere</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w1, w2) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bool</span></span></code></pre></div><p>Check if two directions are in the same hemisphere (both have same sign of z).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2069]||(i[2069]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1131-L1135",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Np,[s("summary",null,[i[2071]||(i[2071]=s("a",{id:"Hikari.sample-Tuple{Hikari.AliasTable, Float32}",href:"#Hikari.sample-Tuple{Hikari.AliasTable, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample")],-1)),i[2072]||(i[2072]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2074]||(i[2074]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AliasTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pmf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sample from the alias table using uniform random <code>u ∈ [0,1)</code>. Returns 1-based index and its PMF.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2073]||(i[2073]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L122-L127",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Op,[s("summary",null,[i[2075]||(i[2075]=s("a",{id:"Hikari.sample-Tuple{Hikari.EnvironmentMap, GeometryBasics.Vec{3, Float32}, Any}",href:"#Hikari.sample-Tuple{Hikari.EnvironmentMap, GeometryBasics.Vec{3, Float32}, Any}"},[s("span",{class:"jlbinding"},"Hikari.sample")],-1)),i[2076]||(i[2076]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2078]||(i[2078]=s("p",null,"Sample method alias for compatibility.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2077]||(i[2077]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L336-L338",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Jp,[s("summary",null,[i[2079]||(i[2079]=s("a",{id:"Hikari.sample-Tuple{Hikari.PowerLightSampler, Float32}",href:"#Hikari.sample-Tuple{Hikari.PowerLightSampler, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample")],-1)),i[2080]||(i[2080]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2082]||(i[2082]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PowerLightSampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (light_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pmf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sample a light with probability proportional to power.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2081]||(i[2081]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L347-L351",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Wp,[s("summary",null,[i[2083]||(i[2083]=s("a",{id:"Hikari.sample-Tuple{Hikari.UniformLightSampler, Float32}",href:"#Hikari.sample-Tuple{Hikari.UniformLightSampler, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample")],-1)),i[2084]||(i[2084]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2086]||(i[2086]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sampler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UniformLightSampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (light_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pmf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sample a light uniformly. Returns 1-based index and PMF.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2085]||(i[2085]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L194-L198",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Up,[s("summary",null,[i[2087]||(i[2087]=s("a",{id:"Hikari.sample_1d-Tuple{Hikari.SobolRNG, Vararg{Int32, 4}}",href:"#Hikari.sample_1d-Tuple{Hikari.SobolRNG, Vararg{Int32, 4}}"},[s("span",{class:"jlbinding"},"Hikari.sample_1d")],-1)),i[2088]||(i[2088]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2090]||(i[2090]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_1d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SobolRNG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Generate a 1D Sobol sample for the given pixel and dimension.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2089]||(i[2089]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L409-L413",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",qp,[s("summary",null,[i[2091]||(i[2091]=s("a",{id:"Hikari.sample_2d-Tuple{Hikari.SobolRNG, Vararg{Int32, 4}}",href:"#Hikari.sample_2d-Tuple{Hikari.SobolRNG, Vararg{Int32, 4}}"},[s("span",{class:"jlbinding"},"Hikari.sample_2d")],-1)),i[2092]||(i[2092]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2094]||(i[2094]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_2d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SobolRNG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Tuple{Float32, Float32}</span></span></code></pre></div><p>Generate a 2D Sobol sample for the given pixel and dimension.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2093]||(i[2093]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L418-L422",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",zp,[s("summary",null,[i[2095]||(i[2095]=s("a",{id:"Hikari.sample_Le-Tuple{Any, Hikari.RGBGridMedium, GeometryBasics.Point{3, Float32}}",href:"#Hikari.sample_Le-Tuple{Any, Hikari.RGBGridMedium, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_Le")],-1)),i[2096]||(i[2096]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2098]||(i[2098]=s("p",null,"Sample Le at a point using trilinear interpolation. Returns RGBSpectrum(0.0) if Le_grid is nothing.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2097]||(i[2097]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1266-L1269",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Kp,[s("summary",null,[i[2099]||(i[2099]=s("a",{id:"Hikari.sample_T_maj_loop!-Tuple{Hikari.RayMajorantIterator, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, UInt64, Any, Any, Hikari.VPMediumSampleWorkItem, Any, Raycore.SetKey, Any, Int32, Int32}",href:"#Hikari.sample_T_maj_loop!-Tuple{Hikari.RayMajorantIterator, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, UInt64, Any, Any, Hikari.VPMediumSampleWorkItem, Any, Raycore.SetKey, Any, Int32, Int32}"},[s("span",{class:"jlbinding"},"Hikari.sample_T_maj_loop!")],-1)),i[2100]||(i[2100]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2102]||(i[2102]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_T_maj_loop!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(iter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RayMajorantIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SampleTMajResult</span></span></code></pre></div><p>Delta tracking loop using the unified RayMajorantIterator. Handles both homogeneous media (single segment) and heterogeneous media (DDA traversal). Uses deterministic LCG RNG for medium sampling (pbrt-v4 pattern).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2101]||(i[2101]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/delta-tracking.jl#L230-L236",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Zp,[s("summary",null,[i[2103]||(i[2103]=s("a",{id:"Hikari.sample_bounce-Tuple{Hikari.CloudVolume, Raycore.RayDifferentials, Hikari.SurfaceInteraction, Hikari.AbstractScene, Hikari.RGBSpectrum, Int32}",href:"#Hikari.sample_bounce-Tuple{Hikari.CloudVolume, Raycore.RayDifferentials, Hikari.SurfaceInteraction, Hikari.AbstractScene, Hikari.RGBSpectrum, Int32}"},[s("span",{class:"jlbinding"},"Hikari.sample_bounce")],-1)),i[2104]||(i[2104]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2106]||(i[2106]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_bounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cloud</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CloudVolume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ray, si, scene, beta, depth) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (should_bounce, new_ray, new_beta, new_depth)</span></span></code></pre></div><p>For volumes, we handle everything in shade() including the continuation ray, so no bounce is needed here.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2105]||(i[2105]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L402-L407",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xp,[s("summary",null,[i[2107]||(i[2107]=s("a",{id:"Hikari.sample_bounce-Tuple{Hikari.Material, Raycore.RayDifferentials, Hikari.SurfaceInteraction, Hikari.Scene, Hikari.RGBSpectrum, Int32}",href:"#Hikari.sample_bounce-Tuple{Hikari.Material, Raycore.RayDifferentials, Hikari.SurfaceInteraction, Hikari.Scene, Hikari.RGBSpectrum, Int32}"},[s("span",{class:"jlbinding"},"Hikari.sample_bounce")],-1)),i[2108]||(i[2108]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2110]||(i[2110]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_bounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(material</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Material</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ray, si, scene, beta, depth) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (should_bounce, new_ray, new_beta, new_depth)</span></span></code></pre></div><p>Sample BSDF to generate a bounce ray for path continuation.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2109]||(i[2109]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/material.jl#L286-L290",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Yp,[s("summary",null,[i[2111]||(i[2111]=s("a",{id:"Hikari.sample_bsdf_spectral",href:"#Hikari.sample_bsdf_spectral"},[s("span",{class:"jlbinding"},"Hikari.sample_bsdf_spectral")],-1)),i[2112]||(i[2112]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2114]||(i[2114]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MatteMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, n, uv, lambda, sample_u, rng) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralBSDFSample</span></span></code></pre></div><p>Sample diffuse BSDF with spectral evaluation. Uses pbrt-v4 convention: work in local shading space where n = (0,0,1).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2113]||(i[2113]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L36-L41",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Qp,[s("summary",null,[i[2115]||(i[2115]=s("a",{id:"Hikari.sample_bsdf_spectral-2",href:"#Hikari.sample_bsdf_spectral-2"},[s("span",{class:"jlbinding"},"Hikari.sample_bsdf_spectral")],-1)),i[2116]||(i[2116]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2118]||(i[2118]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiffuseTransmissionMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, n, uv, lambda, sample_u, rng, regularize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralBSDFSample</span></span></code></pre></div><p>Sample diffuse transmission BSDF matching pbrt-v4&#39;s DiffuseTransmissionBxDF::Sample_f.</p><p>This material diffusely scatters light in both reflection (same hemisphere) and transmission (opposite hemisphere). Sampling is proportional to max(R) and max(T).</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2117]||(i[2117]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L2075-L2082",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$p,[s("summary",null,[i[2119]||(i[2119]=s("a",{id:"Hikari.sample_bsdf_spectral-3",href:"#Hikari.sample_bsdf_spectral-3"},[s("span",{class:"jlbinding"},"Hikari.sample_bsdf_spectral")],-1)),i[2120]||(i[2120]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2122]||(i[2122]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, n, uv, lambda, sample_u, rng, regularize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralBSDFSample</span></span></code></pre></div><p>Sample CoatedConductor BSDF using pbrt-v4&#39;s LayeredBxDF approach.</p><p>This is a layered material with:</p><ul><li><p>Top layer: Dielectric coating (can be rough or smooth)</p></li><li><p>Bottom layer: Conductor (metal) with complex Fresnel</p></li></ul><p>Key pbrt-v4 details (materials.cpp lines 345-392):</p><ul><li><p>Conductor eta/k are scaled by interface IOR: ce /= ieta, ck /= ieta</p></li><li><p>If reflectance mode: k = 2 * sqrt(r) / sqrt(1 - r), eta = 1</p></li></ul><p>When <code>regularize=true</code>, both interface and conductor microfacet alphas are increased to reduce fireflies from near-specular paths (matches pbrt-v4 BSDF::Regularize).</p>',7)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2121]||(i[2121]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L2861-L2876",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",io,[s("summary",null,[i[2123]||(i[2123]=s("a",{id:"Hikari.sample_bsdf_spectral-4",href:"#Hikari.sample_bsdf_spectral-4"},[s("span",{class:"jlbinding"},"Hikari.sample_bsdf_spectral")],-1)),i[2124]||(i[2124]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2126]||(i[2126]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CoatedDiffuseMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, n, uv, lambda, sample_u, rng, regularize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralBSDFSample</span></span></code></pre></div><p>Sample CoatedDiffuse BSDF using pbrt-v4&#39;s LayeredBxDF random walk algorithm.</p><p>This is a 100% port of pbrt-v4&#39;s LayeredBxDF::Sample_f. The algorithm:</p><ol><li><p>Sample entrance interface (top dielectric for wo.z &gt; 0)</p></li><li><p>If reflection at entrance: return immediately with pdfIsProportional=true</p></li><li><p>If transmission: start random walk through layers</p></li><li><p>At each depth: possibly scatter in medium, then sample interface</p></li><li><p>When ray exits through transmission: return the accumulated sample</p></li><li><p>Russian roulette for path termination</p></li></ol><p>When <code>regularize=true</code>, the coating&#39;s microfacet alpha is increased to reduce fireflies.</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2125]||(i[2125]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1217-L1231",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",so,[s("summary",null,[i[2127]||(i[2127]=s("a",{id:"Hikari.sample_bsdf_spectral-5",href:"#Hikari.sample_bsdf_spectral-5"},[s("span",{class:"jlbinding"},"Hikari.sample_bsdf_spectral")],-1)),i[2128]||(i[2128]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2130]||(i[2130]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sample_bsdf_spectral </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MediumInterface </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> forwards to wrapped material.</span></span></code></pre></div>',1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2129]||(i[2129]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3456-L3458",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",eo,[s("summary",null,[i[2131]||(i[2131]=s("a",{id:"Hikari.sample_bsdf_spectral-6",href:"#Hikari.sample_bsdf_spectral-6"},[s("span",{class:"jlbinding"},"Hikari.sample_bsdf_spectral")],-1)),i[2132]||(i[2132]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2134]||(i[2134]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConductorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, n, uv, lambda, sample_u, rng, regularize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralBSDFSample</span></span></code></pre></div><p>Sample metal BSDF with conductor Fresnel. Matches pbrt-v4&#39;s ConductorBxDF::Sample_f exactly.</p><p>The implementation works in local shading coordinates where n = (0,0,1), then transforms back.</p><p>When <code>regularize=true</code>, the microfacet alpha is increased to reduce fireflies from near-specular paths (matches pbrt-v4 BSDF::Regularize).</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2133]||(i[2133]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L212-L222",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",to,[s("summary",null,[i[2135]||(i[2135]=s("a",{id:"Hikari.sample_bsdf_spectral-7",href:"#Hikari.sample_bsdf_spectral-7"},[s("span",{class:"jlbinding"},"Hikari.sample_bsdf_spectral")],-1)),i[2136]||(i[2136]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2138]||(i[2138]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ThinDielectricMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, n, uv, lambda, sample_u, rng, regularize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralBSDFSample</span></span></code></pre></div><p>Sample thin dielectric BSDF matching pbrt-v4&#39;s ThinDielectricBxDF::Sample_f.</p><p>Thin dielectric surfaces model materials like window glass where light can either reflect or transmit straight through (no refraction bend).</p><p>Key physics (pbrt-v4 lines 225-230):</p><ul><li><p>R₀ = FrDielectric(|cos_θ|, eta)</p></li><li><p>R = R₀ + T₀²R₀/(1 - R₀²) where T₀ = 1 - R₀</p></li><li><p>T = 1 - R</p></li><li><p>Transmitted direction: wi = -wo (straight through)</p></li><li><p>Reflected direction: wi = (-wo.x, -wo.y, wo.z) (mirror reflection in local coords)</p></li></ul>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2137]||(i[2137]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1960-L1974",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ao,[s("summary",null,[i[2139]||(i[2139]=s("a",{id:"Hikari.sample_bsdf_spectral-8",href:"#Hikari.sample_bsdf_spectral-8"},[s("span",{class:"jlbinding"},"Hikari.sample_bsdf_spectral")],-1)),i[2140]||(i[2140]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2142]||(i[2142]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MirrorMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, n, uv, lambda, sample_u, rng) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralBSDFSample</span></span></code></pre></div><p>Sample perfect specular reflection with spectral evaluation.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2141]||(i[2141]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L103-L107",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",lo,[s("summary",null,[i[2143]||(i[2143]=s("a",{id:"Hikari.sample_bsdf_spectral-9",href:"#Hikari.sample_bsdf_spectral-9"},[s("span",{class:"jlbinding"},"Hikari.sample_bsdf_spectral")],-1)),i[2144]||(i[2144]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2146]||(i[2146]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_bsdf_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GlassMaterial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, textures, wo, n, uv, lambda, sample_u, rng) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralBSDFSample</span></span></code></pre></div><p>Sample glass BSDF with reflection or refraction. Uses Fresnel to choose between reflection and transmission.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2145]||(i[2145]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L134-L139",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",no,[s("summary",null,[i[2147]||(i[2147]=s("a",{id:"Hikari.sample_cie_x-Tuple{Hikari.CIEXYZTable, Float32}",href:"#Hikari.sample_cie_x-Tuple{Hikari.CIEXYZTable, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_cie_x")],-1)),i[2148]||(i[2148]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2150]||(i[2150]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_cie_x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CIEXYZTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Sample CIE X color matching function at wavelength lambda (in nm). Uses nearest-neighbor lookup into tabulated data.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2149]||(i[2149]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L358-L363",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ro,[s("summary",null,[i[2151]||(i[2151]=s("a",{id:"Hikari.sample_cie_xyz-Tuple{Hikari.CIEXYZTable, Float32}",href:"#Hikari.sample_cie_xyz-Tuple{Hikari.CIEXYZTable, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_cie_xyz")],-1)),i[2152]||(i[2152]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2154]||(i[2154]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_cie_xyz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CIEXYZTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Sample CIE XYZ color matching functions at a single wavelength. Returns Vec3f(X, Y, Z) values at that wavelength.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2153]||(i[2153]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L398-L403",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",po,[s("summary",null,[i[2155]||(i[2155]=s("a",{id:"Hikari.sample_cie_y-Tuple{Hikari.CIEXYZTable, Float32}",href:"#Hikari.sample_cie_y-Tuple{Hikari.CIEXYZTable, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_cie_y")],-1)),i[2156]||(i[2156]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2158]||(i[2158]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_cie_y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CIEXYZTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Sample CIE Y color matching function at wavelength lambda (in nm).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2157]||(i[2157]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L372-L376",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",oo,[s("summary",null,[i[2159]||(i[2159]=s("a",{id:"Hikari.sample_cie_z-Tuple{Hikari.CIEXYZTable, Float32}",href:"#Hikari.sample_cie_z-Tuple{Hikari.CIEXYZTable, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_cie_z")],-1)),i[2160]||(i[2160]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2162]||(i[2162]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_cie_z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CIEXYZTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Sample CIE Z color matching function at wavelength lambda (in nm).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2161]||(i[2161]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L385-L389",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ko,[s("summary",null,[i[2163]||(i[2163]=s("a",{id:"Hikari.sample_conditional_1d-Tuple{AbstractMatrix{Float32}, AbstractMatrix{Float32}, Float32, Int32, Float32, Int32, Float32, Float32}",href:"#Hikari.sample_conditional_1d-Tuple{AbstractMatrix{Float32}, AbstractMatrix{Float32}, Float32, Int32, Float32, Int32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_conditional_1d")],-1)),i[2164]||(i[2164]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2166]||(i[2166]=s("p",null,"Sample 1D from conditional distribution (row of 2D distribution).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2165]||(i[2165]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L785-L787",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ho,[s("summary",null,[i[2167]||(i[2167]=s("a",{id:"Hikari.sample_continuous-Tuple{Hikari.Distribution1D, Float32}",href:"#Hikari.sample_continuous-Tuple{Hikari.Distribution1D, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_continuous")],-1)),i[2168]||(i[2168]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2170]||(i[2170]=s("p",null,"Sample continuous value from Distribution1D. Returns (sampled value in [0,1], pdf, offset index).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2169]||(i[2169]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sampling.jl#L128-L131",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",uo,[s("summary",null,[i[2171]||(i[2171]=s("a",{id:"Hikari.sample_continuous-Tuple{Hikari.Distribution2D, GeometryBasics.Point{2, Float32}, Any}",href:"#Hikari.sample_continuous-Tuple{Hikari.Distribution2D, GeometryBasics.Point{2, Float32}, Any}"},[s("span",{class:"jlbinding"},"Hikari.sample_continuous")],-1)),i[2172]||(i[2172]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2174]||(i[2174]=s("p",null,[a("Sample a 2D point from the flat distribution. Returns (Point2f(u, v), pdf). The "),s("code",null,"textures"),a(" parameter is used to deref TextureRef fields when Distribution2D is stored in a MultiTypeSet.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2173]||(i[2173]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sampling.jl#L265-L269",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",go,[s("summary",null,[i[2175]||(i[2175]=s("a",{id:"Hikari.sample_d65-Tuple{Float32}",href:"#Hikari.sample_d65-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_d65")],-1)),i[2176]||(i[2176]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2178]||(i[2178]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_d65</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Sample the D65 illuminant spectrum at wavelength lambda (nm). Uses linear interpolation between tabulated values.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2177]||(i[2177]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L431-L436",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",co,[s("summary",null,[i[2179]||(i[2179]=s("a",{id:"Hikari.sample_d65_spectral-Tuple{Hikari.SampledWavelengths{4}}",href:"#Hikari.sample_d65_spectral-Tuple{Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.sample_d65_spectral")],-1)),i[2180]||(i[2180]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2182]||(i[2182]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_d65_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Sample D65 illuminant at multiple wavelengths. Returns raw D65 values (around 80-120 across visible spectrum, normalized to 100 at 560nm). Matches pbrt-v4&#39;s illuminant-&gt;Sample(lambda) behavior.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2181]||(i[2181]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L459-L465",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",bo,[s("summary",null,[i[2183]||(i[2183]=s("a",{id:"Hikari.sample_density-Tuple{Any, Hikari.GridMedium, GeometryBasics.Point{3, Float32}}",href:"#Hikari.sample_density-Tuple{Any, Hikari.GridMedium, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_density")],-1)),i[2184]||(i[2184]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2186]||(i[2186]=s("p",null,"Sample density at a point using trilinear interpolation.",-1)),i[2187]||(i[2187]=s("p",null,"Uses pbrt-v4's cell-centered interpretation:",-1)),i[2188]||(i[2188]=s("ul",null,[s("li",null,[s("p",null,"p ∈ [0,1]³ is normalized position within bounds")]),s("li",null,[s("p",null,"Grid has nx×ny×nz voxels (1-indexed in Julia)")]),s("li",null,[s("p",null,"Voxel i is centered at (i - 0.5) / n in normalized space")]),s("li",null,[s("p",null,"Interpolation uses 8 neighboring voxels with proper clamping at boundaries")])],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2185]||(i[2185]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1535-L1543",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",yo,[s("summary",null,[i[2189]||(i[2189]=s("a",{id:"Hikari.sample_density-Tuple{Hikari.CloudVolume, GeometryBasics.Point{3, Float32}}",href:"#Hikari.sample_density-Tuple{Hikari.CloudVolume, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_density")],-1)),i[2190]||(i[2190]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2192]||(i[2192]=s("p",null,"Sample density at a world position using trilinear interpolation",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2191]||(i[2191]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L58",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",mo,[s("summary",null,[i[2193]||(i[2193]=s("a",{id:"Hikari.sample_dielectric_interface-Tuple{GeometryBasics.Vec{3, Float32}, Float32, GeometryBasics.Point{2, Float32}, Float32, Float32, Float32, UInt8}",href:"#Hikari.sample_dielectric_interface-Tuple{GeometryBasics.Vec{3, Float32}, Float32, GeometryBasics.Point{2, Float32}, Float32, Float32, Float32, UInt8}"},[s("span",{class:"jlbinding"},"Hikari.sample_dielectric_interface")],-1)),i[2194]||(i[2194]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2196]||(i[2196]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_dielectric_interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, uc, u, alpha_x, alpha_y, eta, refl_trans_flags) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LayeredBSDFSample</span></span></code></pre></div><p>Sample the dielectric coating interface (top layer in CoatedDiffuse). Handles both smooth (specular) and rough (microfacet) dielectric surfaces.</p><p>This matches pbrt-v4&#39;s DielectricBxDF::Sample_f exactly.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2195]||(i[2195]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L965-L972",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fo,[s("summary",null,[i[2197]||(i[2197]=s("a",{id:"Hikari.sample_dielectric_transmission_spectral-Tuple{Float32, GeometryBasics.Vec{3, Float32}, Float32}",href:"#Hikari.sample_dielectric_transmission_spectral-Tuple{Float32, GeometryBasics.Vec{3, Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_dielectric_transmission_spectral")],-1)),i[2198]||(i[2198]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2200]||(i[2200]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_dielectric_transmission_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(eta, wo, uc) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (wi, T, valid)</span></span></code></pre></div><p>Sample transmission through a dielectric interface. Returns transmitted direction, transmittance, and validity flag.</p><p>Uses pbrt-v4 convention: eta = n_t / n_i (transmitted IOR / incident IOR). The wo direction is in local shading space where z is the surface normal.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2199]||(i[2199]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L885-L893",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Eo,[s("summary",null,[i[2201]||(i[2201]=s("a",{id:"Hikari.sample_diffuse_interface-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, Hikari.SampledSpectrum{4}, UInt8}",href:"#Hikari.sample_diffuse_interface-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, Hikari.SampledSpectrum{4}, UInt8}"},[s("span",{class:"jlbinding"},"Hikari.sample_diffuse_interface")],-1)),i[2202]||(i[2202]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2204]||(i[2204]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_diffuse_interface</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, u, reflectance) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LayeredBSDFSample</span></span></code></pre></div><p>Sample the diffuse base layer (bottom in CoatedDiffuse). This is a simple cosine-weighted hemisphere sampler.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2203]||(i[2203]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L1138-L1143",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_o,[s("summary",null,[i[2205]||(i[2205]=s("a",{id:"Hikari.sample_diffuse_transmission_bottom-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, Float32, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Float32, Float32, UInt8}",href:"#Hikari.sample_diffuse_transmission_bottom-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, Float32, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Float32, Float32, UInt8}"},[s("span",{class:"jlbinding"},"Hikari.sample_diffuse_transmission_bottom")],-1)),i[2206]||(i[2206]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2208]||(i[2208]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_diffuse_transmission_bottom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, u, uc, reflectance, transmittance, refl_trans_flags) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LayeredBSDFSample</span></span></code></pre></div><p>Sample the diffuse transmission bottom layer for the LayeredBxDF walk. Handles both reflection (R/π, same hemisphere) and transmission (T/π, opposite hemisphere).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2207]||(i[2207]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L2251-L2256",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",To,[s("summary",null,[i[2209]||(i[2209]=s("a",{id:"Hikari.sample_exponential-Tuple{Float32, Float32}",href:"#Hikari.sample_exponential-Tuple{Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_exponential")],-1)),i[2210]||(i[2210]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2212]||(i[2212]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_exponential</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Sample from exponential distribution with rate parameter a. Returns -log(1-u)/a, matching pbrt-v4&#39;s SampleExponential.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2211]||(i[2211]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L817-L822",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",jo,[s("summary",null,[i[2213]||(i[2213]=s("a",{id:"Hikari.sample_f-Tuple{Hikari.BSDF, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, UInt8}",href:"#Hikari.sample_f-Tuple{Hikari.BSDF, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, UInt8}"},[s("span",{class:"jlbinding"},"Hikari.sample_f")],-1)),i[2214]||(i[2214]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2216]||(i[2216]=s("p",null,"Compute incident ray direction for a given outgoing direction and a given mode of light scattering corresponding to perfect specular reflection or refraction.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2215]||(i[2215]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/bsdf.jl#L138-L142",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fo,[s("summary",null,[i[2217]||(i[2217]=s("a",{id:"Hikari.sample_filter-Tuple{Hikari.FilterSampler{Hikari.BoxFilter, Nothing}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_filter-Tuple{Hikari.FilterSampler{Hikari.BoxFilter, Nothing}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_filter")],-1)),i[2218]||(i[2218]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2220]||(i[2220]=s("p",null,"Sample the filter using the FilterSampler. Returns FilterSample with position and weight.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2219]||(i[2219]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L537-L540",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Co,[s("summary",null,[i[2221]||(i[2221]=s("a",{id:"Hikari.sample_fresnel_microfacet-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where S<:Hikari.Spectrum",href:"#Hikari.sample_fresnel_microfacet-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.sample_fresnel_microfacet")],-1)),i[2222]||(i[2222]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2224]||(i[2224]=s("p",null,"Sample FresnelMicrofacet using Fresnel-weighted probability to choose between reflection and transmission.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2223]||(i[2223]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/microfacet.jl#L389-L392",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",vo,[s("summary",null,[i[2225]||(i[2225]=s("a",{id:"Hikari.sample_fresnel_specular-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where S<:Hikari.Spectrum",href:"#Hikari.sample_fresnel_specular-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.sample_fresnel_specular")],-1)),i[2226]||(i[2226]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2228]||(i[2228]=s("p",null,"Compute the direction of incident light wi, given an outgoing direction wo and return the value of BxDF for the pair of directions.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2227]||(i[2227]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/specular.jl#L103-L106",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ho,[s("summary",null,[i[2229]||(i[2229]=s("a",{id:"Hikari.sample_ggx_vndf-Tuple{GeometryBasics.Vec{3, Float32}, Float32, Float32, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_ggx_vndf-Tuple{GeometryBasics.Vec{3, Float32}, Float32, Float32, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_ggx_vndf")],-1)),i[2230]||(i[2230]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2232]||(i[2232]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_ggx_vndf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, alpha_x, alpha_y, u) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Sample visible normal from GGX distribution.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2231]||(i[2231]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3538-L3542",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ao,[s("summary",null,[i[2233]||(i[2233]=s("a",{id:"Hikari.sample_hg-Tuple{Float32, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_hg-Tuple{Float32, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_hg")],-1)),i[2234]||(i[2234]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2236]||(i[2236]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_hg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, wo, u) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (wi, pdf)</span></span></code></pre></div><p>Importance sample the Henyey-Greenstein phase function. Returns sampled direction and PDF.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2235]||(i[2235]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L36-L41",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",So,[s("summary",null,[i[2237]||(i[2237]=s("a",{id:"Hikari.sample_hg_phase_spectral-Tuple{Float32, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_hg_phase_spectral-Tuple{Float32, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_hg_phase_spectral")],-1)),i[2238]||(i[2238]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2240]||(i[2240]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_hg_phase_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(g, wo, u) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (wi, phase_pdf)</span></span></code></pre></div><p>Sample direction from Henyey-Greenstein phase function.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2239]||(i[2239]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L842-L846",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xo,[s("summary",null,[i[2241]||(i[2241]=s("a",{id:"Hikari.sample_le-Union{Tuple{S}, Tuple{Hikari.EnvironmentLight{S, E} where E<:Hikari.EnvironmentMap{S, T} where T<:AbstractMatrix{S}, GeometryBasics.Point{2, Float32}, GeometryBasics.Point{2, Float32}, Float32, Hikari.Scene}} where S",href:"#Hikari.sample_le-Union{Tuple{S}, Tuple{Hikari.EnvironmentLight{S, E} where E<:Hikari.EnvironmentMap{S, T} where T<:AbstractMatrix{S}, GeometryBasics.Point{2, Float32}, GeometryBasics.Point{2, Float32}, Float32, Hikari.Scene}} where S"},[s("span",{class:"jlbinding"},"Hikari.sample_le")],-1)),i[2242]||(i[2242]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2244]||(i[2244]=s("p",null,"Sample a ray leaving the environment light (for photon mapping / light tracing). Uses importance sampling based on environment map luminance.",-1)),i[2245]||(i[2245]=s("p",null,"The ray is sampled by:",-1)),i[2246]||(i[2246]=s("ol",null,[s("li",null,[s("p",null,"Importance sampling a direction from the environment map")]),s("li",null,[s("p",null,"Placing a disk of radius scene_radius centered at scene_center, perpendicular to that direction")]),s("li",null,[s("p",null,"Sampling a point on the disk and shooting a ray inward")])],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2243]||(i[2243]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/environment.jl#L75-L84",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Bo,[s("summary",null,[i[2247]||(i[2247]=s("a",{id:"Hikari.sample_li-Tuple{Hikari.AmbientLight, Hikari.Interaction, GeometryBasics.Point{2, Float32}, Hikari.AbstractScene}",href:"#Hikari.sample_li-Tuple{Hikari.AmbientLight, Hikari.Interaction, GeometryBasics.Point{2, Float32}, Hikari.AbstractScene}"},[s("span",{class:"jlbinding"},"Hikari.sample_li")],-1)),i[2248]||(i[2248]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2250]||(i[2250]=n('<p>Compute radiance arriving at <code>ref.p</code> interaction point at <code>ref.time</code> time due to the ambient light.</p><p><strong>Args</strong></p><ul><li><p><code>a::AmbientLight</code>: Ambient light which illuminates the interaction point <code>ref</code>.</p></li><li><p><code>ref::Interaction</code>: Interaction point for which to compute radiance.</p></li><li><p><code>u::Point2f</code>: Sampling point that is ignored for <code>AmbientLight</code>, since it emits light uniformly.</p></li></ul><p><strong>Returns</strong></p><p><code>Tuple{S, Vec3f, Float32, VisibilityTester} where S &lt;: Spectrum</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `S`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Computed radiance.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `Vec3f`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Incident direction to the light source </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`wi`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `Float32`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Probability density </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> the light sample that was taken.</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    For </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`AmbientLight`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> it is always </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`1`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `VisibilityTester`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Initialized visibility tester that holds the</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    shadow ray that must be traced to verify that</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    there are no occluding objects between the light and reference point.</span></span></code></pre></div>',6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2249]||(i[2249]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/ambient.jl#L36-L58",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Do,[s("summary",null,[i[2251]||(i[2251]=s("a",{id:"Hikari.sample_li-Tuple{Hikari.PointLight, Hikari.Interaction, GeometryBasics.Point{2, Float32}, Hikari.AbstractScene}",href:"#Hikari.sample_li-Tuple{Hikari.PointLight, Hikari.Interaction, GeometryBasics.Point{2, Float32}, Hikari.AbstractScene}"},[s("span",{class:"jlbinding"},"Hikari.sample_li")],-1)),i[2252]||(i[2252]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2254]||(i[2254]=n('<p>Compute radiance arriving at <code>ref.p</code> interaction point at <code>ref.time</code> time due to that light, assuming there are no occluding objects between them.</p><p><strong>Args</strong></p><ul><li><p><code>p::PointLight</code>: Light which illuminates the interaction point <code>ref</code>.</p></li><li><p><code>ref::Interaction</code>: Interaction point for which to compute radiance.</p></li><li><p><code>u::Point2f</code>: Sampling point that is ignored for <code>PointLight</code>, since it has no area.</p></li></ul><p><strong>Returns</strong></p><p><code>Tuple{S, Vec3f, Float32, VisibilityTester} where S &lt;: Spectrum</code>:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `S`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Computed radiance.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `Vec3f`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Incident direction to the light source </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`wi`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `Float32`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Probability density </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> the light sample that was taken.</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    For </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`PointLight`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> it is always </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`1`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `VisibilityTester`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Initialized visibility tester that holds the</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    shadow ray that must be traced to verify that</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    there are no occluding objects between the light and reference point.</span></span></code></pre></div>',6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2253]||(i[2253]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/point.jl#L77-L99",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Io,[s("summary",null,[i[2255]||(i[2255]=s("a",{id:"Hikari.sample_li-Union{Tuple{S}, Tuple{Hikari.EnvironmentLight{S, E} where E<:Hikari.EnvironmentMap{S, T} where T<:AbstractMatrix{S}, Hikari.Interaction, GeometryBasics.Point{2, Float32}, Hikari.AbstractScene}} where S",href:"#Hikari.sample_li-Union{Tuple{S}, Tuple{Hikari.EnvironmentLight{S, E} where E<:Hikari.EnvironmentMap{S, T} where T<:AbstractMatrix{S}, Hikari.Interaction, GeometryBasics.Point{2, Float32}, Hikari.AbstractScene}} where S"},[s("span",{class:"jlbinding"},"Hikari.sample_li")],-1)),i[2256]||(i[2256]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2258]||(i[2258]=n("<p>Compute radiance arriving at interaction point from the environment light. Uses importance sampling based on environment map luminance.</p><p><strong>Args</strong></p><ul><li><p><code>e::EnvironmentLight</code>: Environment light.</p></li><li><p><code>ref::Interaction</code>: Interaction point for which to compute radiance.</p></li><li><p><code>u::Point2f</code>: Random sample for direction selection.</p></li></ul><p><strong>Returns</strong></p><p>Tuple of (radiance, incident direction, pdf, visibility tester)</p>",5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2257]||(i[2257]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/environment.jl#L37-L48",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Mo,[s("summary",null,[i[2259]||(i[2259]=s("a",{id:"Hikari.sample_light_sampler-Tuple{AbstractVector{Float32}, AbstractVector{Float32}, AbstractVector{Int32}, Float32}",href:"#Hikari.sample_light_sampler-Tuple{AbstractVector{Float32}, AbstractVector{Float32}, AbstractVector{Int32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_light_sampler")],-1)),i[2260]||(i[2260]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2262]||(i[2262]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_light_sampler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p, q, alias, u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (light_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pmf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>GPU-compatible light sampling using pre-computed alias table arrays.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2261]||(i[2261]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/light-sampler.jl#L506-L510",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Go,[s("summary",null,[i[2263]||(i[2263]=s("a",{id:"Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.AmbientLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.AmbientLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_light_spectral")],-1)),i[2264]||(i[2264]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2266]||(i[2266]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_light_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, lights, light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AmbientLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sample ambient light spectrally (uniform sphere). NOTE: Ambient light represents uniform illumination from all directions. We sample the full sphere uniformly - the BSDF evaluation will naturally give zero for directions below the surface, and cos_theta weighting handles the rest.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2265]||(i[2265]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L191-L198",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Po,[s("summary",null,[i[2267]||(i[2267]=s("a",{id:"Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.DiffuseAreaLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.DiffuseAreaLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_light_spectral")],-1)),i[2268]||(i[2268]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2270]||(i[2270]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_light_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, lights, light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DiffuseAreaLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p, lambda, u)</span></span></code></pre></div><p>Sample a diffuse area light spectrally. Uniformly samples a point on the triangle and converts area PDF to solid angle PDF.</p><p>Following pbrt-v4&#39;s DiffuseAreaLight::SampleLi + Triangle::Sample (uniform area).</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2269]||(i[2269]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L227-L234",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Vo,[s("summary",null,[i[2271]||(i[2271]=s("a",{id:"Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.DirectionalLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.DirectionalLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_light_spectral")],-1)),i[2272]||(i[2272]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2274]||(i[2274]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_light_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, lights, light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DirectionalLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sample a directional light spectrally.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2273]||(i[2273]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L107-L111",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Lo,[s("summary",null,[i[2275]||(i[2275]=s("a",{id:"Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.EnvironmentLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.EnvironmentLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_light_spectral")],-1)),i[2276]||(i[2276]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2278]||(i[2278]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_light_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, lights, light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">EnvironmentLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sample environment light spectrally with importance sampling.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2277]||(i[2277]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L153-L157",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",wo,[s("summary",null,[i[2279]||(i[2279]=s("a",{id:"Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.PointLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.PointLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_light_spectral")],-1)),i[2280]||(i[2280]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2282]||(i[2282]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_light_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, lights, light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PointLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sample a point light spectrally.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2281]||(i[2281]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L34-L38",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ro,[s("summary",null,[i[2283]||(i[2283]=s("a",{id:"Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.SpotLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.SpotLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_light_spectral")],-1)),i[2284]||(i[2284]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2286]||(i[2286]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_light_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, lights, light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpotLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sample a spotlight spectrally.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2285]||(i[2285]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L61-L65",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",No,[s("summary",null,[i[2287]||(i[2287]=s("a",{id:"Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.SunLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Any, Hikari.SunLight, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_light_spectral")],-1)),i[2288]||(i[2288]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2290]||(i[2290]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_light_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, lights, light</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SunLight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Sample a sun light spectrally.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2289]||(i[2289]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L130-L134",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Oo,[s("summary",null,[i[2291]||(i[2291]=s("a",{id:"Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Int32, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Int32, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_light_spectral")],-1)),i[2292]||(i[2292]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2294]||(i[2294]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_light_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, lights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, flat_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p, lambda, u)</span></span></code></pre></div><p>Sample a light from a StaticMultiTypeSet using a flat 1-based index. Converts flat index to SetKey internally.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2293]||(i[2293]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L380-L385",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Jo,[s("summary",null,[i[2295]||(i[2295]=s("a",{id:"Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_light_spectral-Tuple{Hikari.RGBToSpectrumTable, Raycore.StaticMultiTypeSet, Raycore.SetKey, GeometryBasics.Point{3, Float32}, Hikari.SampledWavelengths{4}, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_light_spectral")],-1)),i[2296]||(i[2296]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2298]||(i[2298]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_light_spectral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, lights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SetKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p, lambda, u)</span></span></code></pre></div><p>Sample a light from a StaticMultiTypeSet using type-stable dispatch via with_index.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2297]||(i[2297]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/lights.jl#L364-L368",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Wo,[s("summary",null,[i[2299]||(i[2299]=s("a",{id:"Hikari.sample_nanovdb_density-Tuple{Hikari.NanoVDBMedium, Any, GeometryBasics.Point{3, Float32}}",href:"#Hikari.sample_nanovdb_density-Tuple{Hikari.NanoVDBMedium, Any, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_nanovdb_density")],-1)),i[2300]||(i[2300]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2302]||(i[2302]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_nanovdb_density</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(medium</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NanoVDBMedium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, media, p_world</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Sample the density at a world-space point using trilinear interpolation. Matches pbrt-v4&#39;s SampleFromVoxels&lt;TreeT, 1, false&gt; sampler.</p><p>The <code>media</code> parameter is used to deref TextureRef fields when NanoVDBMedium is stored in a MultiTypeSet.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2301]||(i[2301]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L418-L425",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Uo,[s("summary",null,[i[2303]||(i[2303]=s("a",{id:"Hikari.sample_piecewise_1d-Tuple{AbstractVector{Float32}, AbstractVector{Float32}, Float32, Float32, Int32, Float32, Float32}",href:"#Hikari.sample_piecewise_1d-Tuple{AbstractVector{Float32}, AbstractVector{Float32}, Float32, Float32, Int32, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_piecewise_1d")],-1)),i[2304]||(i[2304]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2306]||(i[2306]=s("p",null,"Sample 1D piecewise constant distribution (pbrt-v4 compatible). Returns (continuous_position, pdf, cell_index).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2305]||(i[2305]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L748-L751",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",qo,[s("summary",null,[i[2307]||(i[2307]=s("a",{id:"Hikari.sample_piecewise_2d-Tuple{Hikari.PiecewiseConstant2D, GeometryBasics.Point{2, Float32}}",href:"#Hikari.sample_piecewise_2d-Tuple{Hikari.PiecewiseConstant2D, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_piecewise_2d")],-1)),i[2308]||(i[2308]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2310]||(i[2310]=s("p",null,"Sample from the 2D distribution using inverse CDF sampling. Returns (point, pdf, grid_index).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2309]||(i[2309]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L418-L421",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",zo,[s("summary",null,[i[2311]||(i[2311]=s("a",{id:"Hikari.sample_segment!-Tuple{Hikari.RayMajorantSegment, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, UInt64, Any, Any, Hikari.VPMediumSampleWorkItem, Any, Raycore.SetKey, Any, Int32, Int32, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.sample_segment!-Tuple{Hikari.RayMajorantSegment, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, Hikari.SampledSpectrum{4}, UInt64, Any, Any, Hikari.VPMediumSampleWorkItem, Any, Raycore.SetKey, Any, Int32, Int32, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_segment!")],-1)),i[2312]||(i[2312]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2314]||(i[2314]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_segment!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(seg, T_maj_accum, beta, r_u, r_l, rng_state, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SampleTMajResult</span></span></code></pre></div><p>Sample interactions within a single majorant segment. Following pbrt-v4&#39;s inner loop of SampleT_maj. Uses deterministic LCG RNG for medium sampling (pbrt-v4 pattern).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2313]||(i[2313]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/delta-tracking.jl#L297-L303",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ko,[s("summary",null,[i[2315]||(i[2315]=s("a",{id:"Hikari.sample_spectral_material",href:"#Hikari.sample_spectral_material"},[s("span",{class:"jlbinding"},"Hikari.sample_spectral_material")],-1)),i[2316]||(i[2316]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2318]||(i[2318]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_spectral_material</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table, materials</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">StaticMultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, idx, wo, ns, tfc, lambda, u, rng, regularize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Type-stable dispatch for spectral BSDF sampling. Returns SpectralBSDFSample from the appropriate material type.</p><p>When <code>regularize=true</code>, near-specular BSDFs will be roughened to reduce fireflies.</p><p>Arguments:</p><ul><li><code>tfc::TextureFilterContext</code>: Contains UV coordinates and screen-space derivatives for texture filtering.</li></ul>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2317]||(i[2317]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L12-L22",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Zo,[s("summary",null,[i[2319]||(i[2319]=s("a",{id:"Hikari.sample_specular_reflection-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where S<:Hikari.Spectrum",href:"#Hikari.sample_specular_reflection-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.sample_specular_reflection")],-1)),i[2320]||(i[2320]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2322]||(i[2322]=s("p",null,[a("Compute the direction of incident light wi, given an outgoing direction wo and return the value of BxDF for the pair of directions. "),s("code",null,"sample"),a(" parameter isn't needed for the δ-distribution.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2321]||(i[2321]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/specular.jl#L44-L48",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xo,[s("summary",null,[i[2323]||(i[2323]=s("a",{id:"Hikari.sample_specular_transmission-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where S",href:"#Hikari.sample_specular_transmission-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}}} where S"},[s("span",{class:"jlbinding"},"Hikari.sample_specular_transmission")],-1)),i[2324]||(i[2324]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2326]||(i[2326]=s("p",null,[a("Compute the direction of incident light wi, given an outgoing direction wo and return the value of BxDF for the pair of directions. "),s("code",null,"sample"),a(" parameter isn't needed for the δ-distribution.")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2325]||(i[2325]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/specular.jl#L67-L71",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Yo,[s("summary",null,[i[2327]||(i[2327]=s("a",{id:"Hikari.sample_tent-Tuple{Float32, Float32}",href:"#Hikari.sample_tent-Tuple{Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_tent")],-1)),i[2328]||(i[2328]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2330]||(i[2330]=s("p",null,"Sample tent distribution for one dimension. Uses inverse CDF sampling of the triangle distribution.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2329]||(i[2329]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/filter.jl#L97-L100",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Qo,[s("summary",null,[i[2331]||(i[2331]=s("a",{id:"Hikari.sample_visible_wavelengths-Tuple{Float32}",href:"#Hikari.sample_visible_wavelengths-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_visible_wavelengths")],-1)),i[2332]||(i[2332]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2334]||(i[2334]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_visible_wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Sample a single wavelength using importance sampling for visible light. Inverse CDF of the hyperbolic secant squared distribution.</p><p>From pbrt-v4: lambda = 538 - 138.888889 * atanh(0.85691062 - 1.82750197 * u)</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2333]||(i[2333]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/spectral.jl#L202-L209",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$o,[s("summary",null,[i[2335]||(i[2335]=s("a",{id:"Hikari.sample_wavelengths_stratified-Tuple{NTuple{4, Float32}}",href:"#Hikari.sample_wavelengths_stratified-Tuple{NTuple{4, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_wavelengths_stratified")],-1)),i[2336]||(i[2336]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2338]||(i[2338]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_wavelengths_stratified</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NTuple{4, Float32}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Wavelengths</span></span></code></pre></div><p>Sample 4 wavelengths with stratified sampling (one per stratum).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2337]||(i[2337]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/spectral.jl#L157-L161",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",id,[s("summary",null,[i[2339]||(i[2339]=s("a",{id:"Hikari.sample_wavelengths_uniform-Tuple{Float32}",href:"#Hikari.sample_wavelengths_uniform-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_wavelengths_uniform")],-1)),i[2340]||(i[2340]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2342]||(i[2342]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_wavelengths_uniform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Wavelengths</span></span></code></pre></div><p>Sample 4 wavelengths using hero wavelength sampling with stratified offsets. This gives better spectral coverage than independent uniform samples.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2341]||(i[2341]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/spectral.jl#L133-L138",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",sd,[s("summary",null,[i[2343]||(i[2343]=s("a",{id:"Hikari.sample_wavelengths_visible-Tuple{Float32}",href:"#Hikari.sample_wavelengths_visible-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.sample_wavelengths_visible")],-1)),i[2344]||(i[2344]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2346]||(i[2346]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample_wavelengths_visible</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(u</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Wavelengths</span></span></code></pre></div><p>Sample 4 wavelengths using importance sampling with hero wavelength method. Uses pbrt-v4&#39;s visible wavelength distribution for reduced variance.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2345]||(i[2345]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/spectral.jl#L215-L220",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ed,[s("summary",null,[i[2347]||(i[2347]=s("a",{id:"Hikari.sample_σ_a-Tuple{Any, Hikari.RGBGridMedium, GeometryBasics.Point{3, Float32}}",href:"#Hikari.sample_σ_a-Tuple{Any, Hikari.RGBGridMedium, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_σ_a")],-1)),i[2348]||(i[2348]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2350]||(i[2350]=s("p",null,"Sample σ_a at a point using trilinear interpolation. Returns default RGBSpectrum(1.0) if σ_a_grid is nothing.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2349]||(i[2349]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1248-L1251",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",td,[s("summary",null,[i[2351]||(i[2351]=s("a",{id:"Hikari.sample_σ_s-Tuple{Any, Hikari.RGBGridMedium, GeometryBasics.Point{3, Float32}}",href:"#Hikari.sample_σ_s-Tuple{Any, Hikari.RGBGridMedium, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sample_σ_s")],-1)),i[2352]||(i[2352]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2354]||(i[2354]=s("p",null,"Sample σ_s at a point using trilinear interpolation. Returns default RGBSpectrum(1.0) if σ_s_grid is nothing.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2353]||(i[2353]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/media.jl#L1257-L1260",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ad,[s("summary",null,[i[2355]||(i[2355]=s("a",{id:"Hikari.sampler_hash",href:"#Hikari.sampler_hash"},[s("span",{class:"jlbinding"},"Hikari.sampler_hash")],-1)),i[2356]||(i[2356]=a()),t(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),i[2358]||(i[2358]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sampler_hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, seed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt64</span></span></code></pre></div><p>Hash function for stratified sampler, matching pbrt-v4&#39;s Hash() behavior. Produces deterministic, well-distributed hash for (pixel, sample, dimension) tuples.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2357]||(i[2357]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L40-L45",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ld,[s("summary",null,[i[2359]||(i[2359]=s("a",{id:"Hikari.sampler_hash_2d-NTuple{4, Int32}",href:"#Hikari.sampler_hash_2d-NTuple{4, Int32}"},[s("span",{class:"jlbinding"},"Hikari.sampler_hash_2d")],-1)),i[2360]||(i[2360]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2362]||(i[2362]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sampler_hash_2d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt64</span></span></code></pre></div><p>Simplified hash for 2D samples where we need two correlated values.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2361]||(i[2361]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L58-L62",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",nd,[s("summary",null,[i[2363]||(i[2363]=s("a",{id:"Hikari.save_nanovdb-Tuple{String, Array{Float32, 3}, Any, Any}",href:"#Hikari.save_nanovdb-Tuple{String, Array{Float32, 3}, Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.save_nanovdb")],-1)),i[2364]||(i[2364]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2366]||(i[2366]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">save_nanovdb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filepath, data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Array{Float32,3}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, origin, extent)</span></span></code></pre></div><p>Build a NanoVDB tree from a dense 3D array and save to file.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2365]||(i[2365]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L938-L942",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",rd,[s("summary",null,[i[2367]||(i[2367]=s("a",{id:"Hikari.save_nanovdb-Tuple{String, Vector{UInt8}, NamedTuple}",href:"#Hikari.save_nanovdb-Tuple{String, Vector{UInt8}, NamedTuple}"},[s("span",{class:"jlbinding"},"Hikari.save_nanovdb")],-1)),i[2368]||(i[2368]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2370]||(i[2370]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">save_nanovdb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filepath, buffer, metadata)</span></span></code></pre></div><p>Save a NanoVDB buffer (from <code>build_nanovdb_from_dense</code>) to a <code>.nanovdb</code> file that can be loaded back with <code>NanoVDBMedium(filepath; ...)</code>.</p><p>Prepends GridData (672 bytes) + TreeData (64 bytes) header, compresses with zlib.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2369]||(i[2369]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L860-L867",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",pd,[s("summary",null,[i[2371]||(i[2371]=s("a",{id:"Hikari.save_srgb_table_binary-Tuple{String, Hikari.RGBToSpectrumTable}",href:"#Hikari.save_srgb_table_binary-Tuple{String, Hikari.RGBToSpectrumTable}"},[s("span",{class:"jlbinding"},"Hikari.save_srgb_table_binary")],-1)),i[2372]||(i[2372]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2374]||(i[2374]=s("p",null,"Save the sRGB spectrum table to raw binary format",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2373]||(i[2373]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L414",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",od,[s("summary",null,[i[2375]||(i[2375]=s("a",{id:"Hikari.shade-Tuple{Hikari.Emissive, Raycore.RayDifferentials, Hikari.SurfaceInteraction, Hikari.Scene, Hikari.RGBSpectrum, Int32, Int32}",href:"#Hikari.shade-Tuple{Hikari.Emissive, Raycore.RayDifferentials, Hikari.SurfaceInteraction, Hikari.Scene, Hikari.RGBSpectrum, Int32, Int32}"},[s("span",{class:"jlbinding"},"Hikari.shade")],-1)),i[2376]||(i[2376]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2378]||(i[2378]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">shade</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ray, si, scene, beta, depth, max_depth) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBSpectrum</span></span></code></pre></div><p>Shading for emissive material returns the emission directly. Emissive materials don&#39;t reflect light, they only emit.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2377]||(i[2377]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/emissive.jl#L125-L130",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",dd,[s("summary",null,[i[2379]||(i[2379]=s("a",{id:"Hikari.shade-Union{Tuple{S}, Tuple{Hikari.CloudVolume, Raycore.RayDifferentials, Hikari.SurfaceInteraction, S, Hikari.RGBSpectrum, Int32, Int32}} where S<:Hikari.AbstractScene",href:"#Hikari.shade-Union{Tuple{S}, Tuple{Hikari.CloudVolume, Raycore.RayDifferentials, Hikari.SurfaceInteraction, S, Hikari.RGBSpectrum, Int32, Int32}} where S<:Hikari.AbstractScene"},[s("span",{class:"jlbinding"},"Hikari.shade")],-1)),i[2380]||(i[2380]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2382]||(i[2382]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">shade</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cloud</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CloudVolume</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ray, si, scene, beta) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBSpectrum</span></span></code></pre></div><p>Shade a ray that hit a volume material using ray marching with single scattering. The SurfaceInteraction gives us the entry point into the volume.</p><p>This version checks for scene intersections DURING ray marching, so objects inside or in front of the volume are properly rendered with correct transmittance.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2381]||(i[2381]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/volume.jl#L263-L271",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",kd,[s("summary",null,[i[2383]||(i[2383]=s("a",{id:"Hikari.shade-Union{Tuple{S}, Tuple{Hikari.Material, Raycore.RayDifferentials, Hikari.SurfaceInteraction, S, Hikari.RGBSpectrum, Int32, Int32}} where S<:Hikari.AbstractScene",href:"#Hikari.shade-Union{Tuple{S}, Tuple{Hikari.Material, Raycore.RayDifferentials, Hikari.SurfaceInteraction, S, Hikari.RGBSpectrum, Int32, Int32}} where S<:Hikari.AbstractScene"},[s("span",{class:"jlbinding"},"Hikari.shade")],-1)),i[2384]||(i[2384]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2386]||(i[2386]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">shade</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(material</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Material</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ray, si, scene, beta, depth, max_depth) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBSpectrum</span></span></code></pre></div><p>Compute direct lighting and specular bounces for a surface hit. This is the generic implementation that works for all material types.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2385]||(i[2385]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/material.jl#L250-L255",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",hd,[s("summary",null,[i[2387]||(i[2387]=s("a",{id:"Hikari.sigmoid-Tuple{Float32}",href:"#Hikari.sigmoid-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.sigmoid")],-1)),i[2388]||(i[2388]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2390]||(i[2390]=s("p",null,"Sigmoid function for spectrum evaluation",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2389]||(i[2389]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ud,[s("summary",null,[i[2391]||(i[2391]=s("a",{id:"Hikari.sin2_theta-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.sin2_theta-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sin2_theta")],-1)),i[2392]||(i[2392]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2394]||(i[2394]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sin2_theta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get sin²(θ) of a direction in local coordinates.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2393]||(i[2393]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3605-L3609",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",gd,[s("summary",null,[i[2395]||(i[2395]=s("a",{id:"Hikari.sin_phi-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.sin_phi-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sin_phi")],-1)),i[2396]||(i[2396]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2398]||(i[2398]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sin_phi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get sin(φ) of a direction in local coordinates (matches pbrt-v4&#39;s SinPhi).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2397]||(i[2397]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3639-L3643",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",cd,[s("summary",null,[i[2399]||(i[2399]=s("a",{id:"Hikari.sin_theta-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.sin_theta-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.sin_theta")],-1)),i[2400]||(i[2400]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2402]||(i[2402]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sin_theta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get sin(θ) of a direction in local coordinates.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2401]||(i[2401]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3612-L3616",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",bd,[s("summary",null,[i[2403]||(i[2403]=s("a",{id:"Hikari.sobol_sample-Tuple{Int64, Int32, UInt32, Any}",href:"#Hikari.sobol_sample-Tuple{Int64, Int32, UInt32, Any}"},[s("span",{class:"jlbinding"},"Hikari.sobol_sample")],-1)),i[2404]||(i[2404]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2406]||(i[2406]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sobol_sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dimension</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, scramble_seed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sobol_matrices) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Generate a single Sobol sample for the given index and dimension. Reference: pbrt-v4/src/pbrt/util/lowdiscrepancy.h SobolSample (lines 167-180)</p><p>Arguments:</p><ul><li><p>a: Sample index (0-based)</p></li><li><p>dimension: Sobol dimension (0-based, max NSOBOL_DIMENSIONS-1)</p></li><li><p>scramble_seed: Seed for FastOwen scrambling</p></li><li><p>sobol_matrices: The Sobol generator matrices array (must be GPU-accessible)</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2405]||(i[2405]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L96-L107",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",yd,[s("summary",null,[i[2407]||(i[2407]=s("a",{id:"Hikari.sobol_sample_unscrambled-Tuple{Int64, Int32}",href:"#Hikari.sobol_sample_unscrambled-Tuple{Int64, Int32}"},[s("span",{class:"jlbinding"},"Hikari.sobol_sample_unscrambled")],-1)),i[2408]||(i[2408]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2410]||(i[2410]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sobol_sample_unscrambled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dimension</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Generate an unscrambled Sobol sample (for debugging/comparison).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2409]||(i[2409]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L132-L136",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",md,[s("summary",null,[i[2411]||(i[2411]=s("a",{id:"Hikari.spawn_spectral_ray-Tuple{Hikari.PWMaterialEvalWorkItem, GeometryBasics.Vec{3, Float32}, Hikari.SampledSpectrum{4}, Bool, Float32, Float32}",href:"#Hikari.spawn_spectral_ray-Tuple{Hikari.PWMaterialEvalWorkItem, GeometryBasics.Vec{3, Float32}, Hikari.SampledSpectrum{4}, Bool, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.spawn_spectral_ray")],-1)),i[2412]||(i[2412]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2414]||(i[2414]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">spawn_spectral_ray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PWMaterialEvalWorkItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, wi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, new_beta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpectralRadiance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                   is_specular</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, pdf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, eta_scale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PWRayWorkItem</span></span></code></pre></div><p>Create a new ray work item for indirect lighting from a material evaluation.</p>`,2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2413]||(i[2413]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/physical-wavefront/material-dispatch.jl#L198-L203",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fd,[s("summary",null,[i[2415]||(i[2415]=s("a",{id:"Hikari.spectral_to_linear_rgb-Tuple{Hikari.CIEXYZTable, Hikari.SampledSpectrum{4}, Hikari.SampledWavelengths{4}}",href:"#Hikari.spectral_to_linear_rgb-Tuple{Hikari.CIEXYZTable, Hikari.SampledSpectrum{4}, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.spectral_to_linear_rgb")],-1)),i[2416]||(i[2416]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2418]||(i[2418]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">spectral_to_linear_rgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CIEXYZTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpectralRadiance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Convert spectral radiance to linear RGB (no gamma):</p><ol><li><p>Convert to XYZ using color matching functions</p></li><li><p>Transform XYZ to linear sRGB using standard matrix (D65 white point)</p></li></ol><p>This matches pbrt-v4&#39;s RGBFilm::ToSensorRGB → outputRGBFromSensorRGB pipeline.</p><p>The light sources use <code>uplift_rgb_illuminant</code> which multiplies by D65 illuminant spectrum (RGBIlluminantSpectrum), so no chromatic adaptation is needed here. D65-shaped spectra integrated under CIE XYZ naturally produce the correct white balance when transformed using the standard sRGB matrix.</p>',5)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2417]||(i[2417]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L663-L676",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ed,[s("summary",null,[i[2419]||(i[2419]=s("a",{id:"Hikari.spectral_to_linear_rgb_passthrough-Tuple{Hikari.SampledSpectrum{4}}",href:"#Hikari.spectral_to_linear_rgb_passthrough-Tuple{Hikari.SampledSpectrum{4}}"},[s("span",{class:"jlbinding"},"Hikari.spectral_to_linear_rgb_passthrough")],-1)),i[2420]||(i[2420]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2422]||(i[2422]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">spectral_to_linear_rgb_passthrough</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpectralRadiance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Pseudo-spectral passthrough: read RGB directly from spectral channels. For use when <code>uplift_rgb(...; method=:passthrough)</code> was used to store RGB directly. This matches PbrtWavefront behavior and avoids spectral-to-XYZ conversion noise.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2421]||(i[2421]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L682-L688",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_d,[s("summary",null,[i[2423]||(i[2423]=s("a",{id:"Hikari.spectral_to_srgb-Tuple{Hikari.CIEXYZTable, Hikari.SampledSpectrum{4}, Hikari.SampledWavelengths{4}}",href:"#Hikari.spectral_to_srgb-Tuple{Hikari.CIEXYZTable, Hikari.SampledSpectrum{4}, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.spectral_to_srgb")],-1)),i[2424]||(i[2424]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2426]||(i[2426]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">spectral_to_srgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CIEXYZTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpectralRadiance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Convert spectral radiance to sRGB:</p><ol><li><p>Convert to XYZ using color matching functions</p></li><li><p>Transform XYZ to linear sRGB using standard matrix (D65 white point)</p></li><li><p>Apply sRGB gamma curve</p></li></ol><p>This matches pbrt-v4&#39;s RGBFilm pipeline. Light sources use <code>uplift_rgb_illuminant</code> which multiplies by D65 illuminant spectrum, so no chromatic adaptation is needed.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2425]||(i[2425]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L642-L652",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Td,[s("summary",null,[i[2427]||(i[2427]=s("a",{id:"Hikari.spectral_to_xyz-Tuple{Hikari.CIEXYZTable, Hikari.SampledSpectrum{4}, Hikari.SampledWavelengths{4}}",href:"#Hikari.spectral_to_xyz-Tuple{Hikari.CIEXYZTable, Hikari.SampledSpectrum{4}, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.spectral_to_xyz")],-1)),i[2428]||(i[2428]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2430]||(i[2430]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">spectral_to_xyz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CIEXYZTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, L</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpectralRadiance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Convert spectral radiance to CIE XYZ using the pbrt-v4 algorithm.</p><p>The formula is: XYZ = (1/CIE_Y_integral) * Average(SafeDiv(CMF * L, pdf))</p><p>where CMF is the color matching function and pdf is the wavelength sampling PDF.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2429]||(i[2429]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L416-L425",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",jd,[s("summary",null,[i[2431]||(i[2431]=s("a",{id:"Hikari.spectrum_to_photometric-Tuple{Hikari.RGBSpectrum}",href:"#Hikari.spectrum_to_photometric-Tuple{Hikari.RGBSpectrum}"},[s("span",{class:"jlbinding"},"Hikari.spectrum_to_photometric")],-1)),i[2432]||(i[2432]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2434]||(i[2434]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">spectrum_to_photometric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Spectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute photometric luminance of a spectrum, matching pbrt-v4&#39;s SpectrumToPhotometric.</p><p>For RGBIlluminantSpectrum, this extracts only the D65 illuminant component (ignoring the RGB multiplier), matching pbrt-v4&#39;s behavior where SpectrumToPhotometric extracts s.Illuminant() first.</p><p>This is used for light normalization: <code>scale = 1 / spectrum_to_photometric(spectrum)</code></p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2433]||(i[2433]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L597-L607",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fd,[s("summary",null,[i[2435]||(i[2435]=s("a",{id:"Hikari.specular_bounce-Union{Tuple{S}, Tuple{Any, Hikari.BSDF, Raycore.RayDifferentials, Hikari.SurfaceInteraction, S, Hikari.RGBSpectrum, Int32, Int32}} where S<:Hikari.AbstractScene",href:"#Hikari.specular_bounce-Union{Tuple{S}, Tuple{Any, Hikari.BSDF, Raycore.RayDifferentials, Hikari.SurfaceInteraction, S, Hikari.RGBSpectrum, Int32, Int32}} where S<:Hikari.AbstractScene"},[s("span",{class:"jlbinding"},"Hikari.specular_bounce")],-1)),i[2436]||(i[2436]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2438]||(i[2438]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">specular_bounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(type, bsdf, ray, si, scene, beta, depth, max_depth) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBSpectrum</span></span></code></pre></div><p>Compute specular reflection or transmission contribution by tracing a bounce ray.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2437]||(i[2437]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/material.jl#L154-L158",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Cd,[s("summary",null,[i[2439]||(i[2439]=s("a",{id:"Hikari.specular_differentials-Tuple{Hikari.Reflect, Vararg{Any, 6}}",href:"#Hikari.specular_differentials-Tuple{Hikari.Reflect, Vararg{Any, 6}}"},[s("span",{class:"jlbinding"},"Hikari.specular_differentials")],-1)),i[2440]||(i[2440]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2442]||(i[2442]=s("p",null,"Compute ray differentials for specular reflection.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2441]||(i[2441]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/material.jl#L201-L203",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",vd,[s("summary",null,[i[2443]||(i[2443]=s("a",{id:"Hikari.specular_differentials-Tuple{Hikari.Transmit, Vararg{Any, 6}}",href:"#Hikari.specular_differentials-Tuple{Hikari.Transmit, Vararg{Any, 6}}"},[s("span",{class:"jlbinding"},"Hikari.specular_differentials")],-1)),i[2444]||(i[2444]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2446]||(i[2446]=s("p",null,"Compute ray differentials for specular transmission.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2445]||(i[2445]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/material.jl#L220-L222",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Hd,[s("summary",null,[i[2447]||(i[2447]=s("a",{id:"Hikari.srgb_gamma_to_linear-Tuple{Float32}",href:"#Hikari.srgb_gamma_to_linear-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.srgb_gamma_to_linear")],-1)),i[2448]||(i[2448]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2450]||(i[2450]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">srgb_gamma_to_linear</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Remove sRGB gamma curve from an sRGB value to get linear RGB.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2449]||(i[2449]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L629-L633",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ad,[s("summary",null,[i[2451]||(i[2451]=s("a",{id:"Hikari.start_pixel-Tuple{Hikari.Sampler, GeometryBasics.Point{2, Float32}}",href:"#Hikari.start_pixel-Tuple{Hikari.Sampler, GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.start_pixel")],-1)),i[2452]||(i[2452]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2454]||(i[2454]=s("p",null,"Other samplers are required to explicitly call this, in their respective implementations.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2453]||(i[2453]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sampler.jl#L49-L52",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Sd,[s("summary",null,[i[2455]||(i[2455]=s("a",{id:"Hikari.stratified_sample_1d-NTuple{4, Int32}",href:"#Hikari.stratified_sample_1d-NTuple{4, Int32}"},[s("span",{class:"jlbinding"},"Hikari.stratified_sample_1d")],-1)),i[2456]||(i[2456]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2458]||(i[2458]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">stratified_sample_1d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Generate a deterministic 1D sample in [0, 1) for the given pixel, sample index, and dimension. This matches pbrt-v4&#39;s IndependentSampler behavior.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2457]||(i[2457]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L74-L79",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xd,[s("summary",null,[i[2459]||(i[2459]=s("a",{id:"Hikari.stratified_sample_2d-NTuple{4, Int32}",href:"#Hikari.stratified_sample_2d-NTuple{4, Int32}"},[s("span",{class:"jlbinding"},"Hikari.stratified_sample_2d")],-1)),i[2460]||(i[2460]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2462]||(i[2462]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">stratified_sample_2d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, py</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, sample_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dim</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Tuple{Float32, Float32}</span></span></code></pre></div><p>Generate a deterministic 2D sample in [0, 1)² for the given pixel, sample index, and dimension. Uses two consecutive dimensions for the two components.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2461]||(i[2461]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L86-L91",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Bd,[s("summary",null,[i[2463]||(i[2463]=s("a",{id:"Hikari.sunsky_to_envlight-Tuple{}",href:"#Hikari.sunsky_to_envlight-Tuple{}"},[s("span",{class:"jlbinding"},"Hikari.sunsky_to_envlight")],-1)),i[2464]||(i[2464]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2466]||(i[2466]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sunsky_to_envlight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(; direction, intensity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, turbidity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.5f0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (EnvironmentLight, SunLight)</span></span></code></pre></div><p>Pre-bake the Hosek-Wilkie spectral sky model into an equal-area EnvironmentMap and create a separate SunLight for the sun disk. Matches pbrt-v4&#39;s <code>makesky</code> approach: evaluate the spectral model at 13 wavelengths, convert to XYZ via CIE color matching functions (dividing by CIE_Y_integral), then to sRGB for storage.</p><p><strong>Arguments</strong></p><ul><li><p><code>direction::Vec3f</code>: Direction TO the sun (normalized internally)</p></li><li><p><code>intensity::Float32 = 1f0</code>: Overall brightness multiplier (scale parameter, default 1.0)</p></li><li><p><code>turbidity::Float32 = 2.5f0</code>: Atmospheric turbidity (1=clear, 10=hazy)</p></li><li><p><code>ground_albedo::RGBSpectrum = RGBSpectrum(0.3f0)</code>: Ground color below horizon</p></li><li><p><code>ground_enabled::Bool = true</code>: Whether to show ground below horizon</p></li><li><p><code>resolution::Int = 512</code>: Resolution of equal-area square map</p></li></ul><p><strong>Returns</strong></p><p>A tuple of <code>(EnvironmentLight, SunLight)</code> to be added to the scene.</p>',6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2465]||(i[2465]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/lights/sun_sky.jl#L339-L357",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Dd,[s("summary",null,[i[2467]||(i[2467]=s("a",{id:"Hikari.surface_direct_lighting_inner!-Tuple{Any, Hikari.VPMaterialEvalWorkItem, Any, Any, Any, Any, Any, Int32, Int32, Int32, Any, Any, Any, Int32}",href:"#Hikari.surface_direct_lighting_inner!-Tuple{Any, Hikari.VPMaterialEvalWorkItem, Any, Any, Any, Any, Any, Int32, Int32, Int32, Any, Any, Any, Int32}"},[s("span",{class:"jlbinding"},"Hikari.surface_direct_lighting_inner!")],-1)),i[2468]||(i[2468]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2470]||(i[2470]=s("p",null,"Inner function for surface direct lighting - can use return statements.",-1)),i[2471]||(i[2471]=s("p",null,"Uses BVH light sampler for spatially-aware importance sampling. Nearby lights get higher probability than distant ones (pbrt-v4's BVHLightSampler).",-1)),i[2472]||(i[2472]=s("p",null,"Now uses pre-computed Sobol samples from pixel_samples (pbrt-v4 RaySamples style).",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2469]||(i[2469]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/surface-eval.jl#L243-L250",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Id,[s("summary",null,[i[2473]||(i[2473]=s("a",{id:"Hikari.swap_ray_queues!-Tuple{Hikari.VolPathState}",href:"#Hikari.swap_ray_queues!-Tuple{Hikari.VolPathState}"},[s("span",{class:"jlbinding"},"Hikari.swap_ray_queues!")],-1)),i[2474]||(i[2474]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2476]||(i[2476]=s("p",null,"Swap the ray queue selector.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2475]||(i[2475]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath-state.jl#L197",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Md,[s("summary",null,[i[2477]||(i[2477]=s("a",{id:"Hikari.tan2_theta-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.tan2_theta-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.tan2_theta")],-1)),i[2478]||(i[2478]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2480]||(i[2480]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tan2_theta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Get tan²(θ) of a direction in local coordinates.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2479]||(i[2479]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3619-L3623",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Gd,[s("summary",null,[i[2481]||(i[2481]=s("a",{id:"Hikari.terminate_secondary_wavelengths-Tuple{Hikari.SampledWavelengths{4}}",href:"#Hikari.terminate_secondary_wavelengths-Tuple{Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.terminate_secondary_wavelengths")],-1)),i[2482]||(i[2482]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2484]||(i[2484]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">terminate_secondary_wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Wavelengths</span></span></code></pre></div><p>Set PDF to zero for secondary wavelengths when a wavelength-dependent event occurs (e.g., refraction with dispersion). This indicates that only the hero wavelength (first) should contribute to the pixel.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2483]||(i[2483]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/spectral.jl#L251-L257",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Pd,[s("summary",null,[i[2485]||(i[2485]=s("a",{id:"Hikari.to_grid-Tuple{GeometryBasics.Point{3, Float32}, Raycore.Bounds3, GeometryBasics.Point3}",href:"#Hikari.to_grid-Tuple{GeometryBasics.Point{3, Float32}, Raycore.Bounds3, GeometryBasics.Point3}"},[s("span",{class:"jlbinding"},"Hikari.to_grid")],-1)),i[2486]||(i[2486]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2488]||(i[2488]=s("p",null,[a("Calculate indices of a point "),s("code",null,"p"),a(" in grid constrained by "),s("code",null,"bounds"),a(".")],-1)),i[2489]||(i[2489]=s("p",null,[a("Computed indices are in [0, resolution), which is the correct input for "),s("code",null,"hash"),a(".")],-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2487]||(i[2487]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/sppm.jl#L529-L533",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Vd,[s("summary",null,[i[2490]||(i[2490]=s("a",{id:"Hikari.total_size-Union{Tuple{Hikari.MultiMaterialQueue{N}}, Tuple{N}} where N",href:"#Hikari.total_size-Union{Tuple{Hikari.MultiMaterialQueue{N}}, Tuple{N}} where N"},[s("span",{class:"jlbinding"},"Hikari.total_size")],-1)),i[2491]||(i[2491]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2493]||(i[2493]=s("p",null,"Get total size across all queues",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2492]||(i[2492]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/multi-material-eval.jl#L49",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ld,[s("summary",null,[i[2494]||(i[2494]=s("a",{id:"Hikari.trace_shadow_transmittance-Tuple{Any, Any, Any, Any, Any, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Hikari.SampledWavelengths{4}, Raycore.SetKey}",href:"#Hikari.trace_shadow_transmittance-Tuple{Any, Any, Any, Any, Any, GeometryBasics.Point{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Hikari.SampledWavelengths{4}, Raycore.SetKey}"},[s("span",{class:"jlbinding"},"Hikari.trace_shadow_transmittance")],-1)),i[2495]||(i[2495]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2497]||(i[2497]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trace_shadow_transmittance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(accel, media_interfaces, media, rgb2spec_table, origin, dir, t_max, lambda, medium_idx)</span></span></code></pre></div><p>Trace a shadow ray computing transmittance through media and transmissive boundaries. Returns (T_ray, r_u, r_l, visible) where:</p><ul><li><p>T_ray: spectral transmittance</p></li><li><p>r_u, r_l: MIS weight accumulators for combining with path weights</p></li><li><p>visible: false if ray hits an opaque surface</p></li></ul><p>Following pbrt-v4&#39;s TraceTransmittance: transmissive surfaces (MediumInterface) let the ray through, while opaque surfaces block it. The final contribution is computed as: Ld * T_ray / average(path_r_u * r_u + path_r_l * r_l)</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2496]||(i[2496]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L289-L301",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",wd,[s("summary",null,[i[2498]||(i[2498]=s("a",{id:"Hikari.trowbridge_reitz_d-Tuple{GeometryBasics.Vec{3, Float32}, Float32, Float32}",href:"#Hikari.trowbridge_reitz_d-Tuple{GeometryBasics.Vec{3, Float32}, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.trowbridge_reitz_d")],-1)),i[2499]||(i[2499]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2501]||(i[2501]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trowbridge_reitz_d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wm, alpha_x, alpha_y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Evaluate the TrowbridgeReitz D (normal distribution function) at microfacet normal wm. Matches pbrt-v4&#39;s TrowbridgeReitzDistribution:😄(wm).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2500]||(i[2500]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3768-L3773",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Rd,[s("summary",null,[i[2502]||(i[2502]=s("a",{id:"Hikari.trowbridge_reitz_d_pdf-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32}",href:"#Hikari.trowbridge_reitz_d_pdf-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.trowbridge_reitz_d_pdf")],-1)),i[2503]||(i[2503]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2505]||(i[2505]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trowbridge_reitz_d_pdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w, wm, alpha_x, alpha_y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Evaluate the visible normal distribution D(w, wm) for PDF computation. Matches pbrt-v4&#39;s D(w, wm) = G1(w) / AbsCosTheta(w) * D(wm) * AbsDot(w, wm).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2504]||(i[2504]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3814-L3819",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Nd,[s("summary",null,[i[2506]||(i[2506]=s("a",{id:"Hikari.trowbridge_reitz_effectively_smooth-Tuple{Float32, Float32}",href:"#Hikari.trowbridge_reitz_effectively_smooth-Tuple{Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.trowbridge_reitz_effectively_smooth")],-1)),i[2507]||(i[2507]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2509]||(i[2509]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trowbridge_reitz_effectively_smooth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(alpha_x, alpha_y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Bool</span></span></code></pre></div><p>Check if the distribution is effectively smooth (matches pbrt-v4&#39;s EffectivelySmooth).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2508]||(i[2508]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3760-L3764",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Od,[s("summary",null,[i[2510]||(i[2510]=s("a",{id:"Hikari.trowbridge_reitz_g-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32}",href:"#Hikari.trowbridge_reitz_g-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.trowbridge_reitz_g")],-1)),i[2511]||(i[2511]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2513]||(i[2513]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trowbridge_reitz_g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(wo, wi, alpha_x, alpha_y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute G(wo, wi) Smith masking-shadowing function (matches pbrt-v4&#39;s G).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2512]||(i[2512]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3806-L3810",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Jd,[s("summary",null,[i[2514]||(i[2514]=s("a",{id:"Hikari.trowbridge_reitz_g1-Tuple{GeometryBasics.Vec{3, Float32}, Float32, Float32}",href:"#Hikari.trowbridge_reitz_g1-Tuple{GeometryBasics.Vec{3, Float32}, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.trowbridge_reitz_g1")],-1)),i[2515]||(i[2515]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2517]||(i[2517]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trowbridge_reitz_g1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w, alpha_x, alpha_y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute G1(w) Smith masking function (matches pbrt-v4&#39;s G1).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2516]||(i[2516]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3798-L3802",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Wd,[s("summary",null,[i[2518]||(i[2518]=s("a",{id:"Hikari.trowbridge_reitz_lambda-Tuple{GeometryBasics.Vec{3, Float32}, Float32, Float32}",href:"#Hikari.trowbridge_reitz_lambda-Tuple{GeometryBasics.Vec{3, Float32}, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.trowbridge_reitz_lambda")],-1)),i[2519]||(i[2519]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2521]||(i[2521]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trowbridge_reitz_lambda</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w, alpha_x, alpha_y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute Lambda(w) for Smith masking-shadowing (matches pbrt-v4&#39;s Lambda).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2520]||(i[2520]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3785-L3789",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ud,[s("summary",null,[i[2522]||(i[2522]=s("a",{id:"Hikari.trowbridge_reitz_pdf-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32}",href:"#Hikari.trowbridge_reitz_pdf-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.trowbridge_reitz_pdf")],-1)),i[2523]||(i[2523]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2525]||(i[2525]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trowbridge_reitz_pdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w, wm, alpha_x, alpha_y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Compute PDF for visible normal sampling (matches pbrt-v4&#39;s PDF).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2524]||(i[2524]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3825-L3829",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",qd,[s("summary",null,[i[2526]||(i[2526]=s("a",{id:"Hikari.trowbridge_reitz_sample_wm-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, Float32, Float32}",href:"#Hikari.trowbridge_reitz_sample_wm-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Point{2, Float32}, Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.trowbridge_reitz_sample_wm")],-1)),i[2527]||(i[2527]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2529]||(i[2529]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">trowbridge_reitz_sample_wm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w, u, alpha_x, alpha_y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Sample visible normal from TrowbridgeReitz distribution (matches pbrt-v4&#39;s Sample_wm).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2528]||(i[2528]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3833-L3837",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",zd,[s("summary",null,[i[2530]||(i[2530]=s("a",{id:"Hikari.uint32_to_bytes-Tuple{UInt32}",href:"#Hikari.uint32_to_bytes-Tuple{UInt32}"},[s("span",{class:"jlbinding"},"Hikari.uint32_to_bytes")],-1)),i[2531]||(i[2531]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2533]||(i[2533]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uint32_to_bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NTuple{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,UInt8}</span></span></code></pre></div><p>GPU-compatible conversion of UInt32 to bytes.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2532]||(i[2532]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/stratified.jl#L26-L30",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Kd,[s("summary",null,[i[2534]||(i[2534]=s("a",{id:"Hikari.uint64_to_bytes-Tuple{UInt64}",href:"#Hikari.uint64_to_bytes-Tuple{UInt64}"},[s("span",{class:"jlbinding"},"Hikari.uint64_to_bytes")],-1)),i[2535]||(i[2535]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2537]||(i[2537]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uint64_to_bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NTuple{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,UInt8}</span></span></code></pre></div><p>GPU-compatible conversion of UInt64 to bytes.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2536]||(i[2536]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L665-L669",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Zd,[s("summary",null,[i[2538]||(i[2538]=s("a",{id:"Hikari.uplift_rgb-Tuple{Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}",href:"#Hikari.uplift_rgb-Tuple{Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.uplift_rgb")],-1)),i[2539]||(i[2539]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2541]||(i[2541]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uplift_rgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; method</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:sigmoid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Convert Hikari RGBSpectrum to spectral radiance at given wavelengths. Uses global table - not GPU-compatible. Use the version with explicit table for GPU kernels.</p><p>Methods:</p><ul><li><p><code>:sigmoid</code> - Smooth sigmoid polynomial (pbrt-v4 style, lowest variance, default)</p></li><li><p><code>:simple</code> - Fast piecewise linear</p></li><li><p><code>:smits</code> - Smits&#39; method</p></li><li><p><code>:passthrough</code> - Store RGB directly as first 3 spectral channels (pseudo-spectral, fastest)</p></li></ul>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2540]||(i[2540]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L314-L325",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Xd,[s("summary",null,[i[2542]||(i[2542]=s("a",{id:"Hikari.uplift_rgb-Tuple{Hikari.RGBToSpectrumTable, Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}",href:"#Hikari.uplift_rgb-Tuple{Hikari.RGBToSpectrumTable, Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.uplift_rgb")],-1)),i[2543]||(i[2543]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2545]||(i[2545]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uplift_rgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>GPU-compatible version that takes an explicit table parameter. Uses sigmoid polynomial method (pbrt-v4 style, lowest variance).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2544]||(i[2544]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L342-L347",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Yd,[s("summary",null,[i[2546]||(i[2546]=s("a",{id:"Hikari.uplift_rgb_illuminant-Tuple{Hikari.RGBToSpectrumTable, Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}",href:"#Hikari.uplift_rgb_illuminant-Tuple{Hikari.RGBToSpectrumTable, Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.uplift_rgb_illuminant")],-1)),i[2547]||(i[2547]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2549]||(i[2549]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uplift_rgb_illuminant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uplift_rgb_illuminant</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBIlluminantSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Convert RGB to spectral radiance for illuminants (light sources, environment maps). Following pbrt-v4&#39;s RGBIlluminantSpectrum which multiplies by the D65 illuminant spectrum.</p><p>Use this for:</p><ul><li><p>Environment maps (ImageInfiniteLight)</p></li><li><p>Any RGB-specified light source</p></li></ul><p>Do NOT use for:</p><ul><li><p>Material reflectance/albedo (use uplift_rgb instead)</p></li><li><p>Emission from non-illuminant sources</p></li></ul>`,6)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2548]||(i[2548]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L540-L554",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Qd,[s("summary",null,[i[2550]||(i[2550]=s("a",{id:"Hikari.uplift_rgb_unbounded-Tuple{Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}",href:"#Hikari.uplift_rgb_unbounded-Tuple{Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.uplift_rgb_unbounded")],-1)),i[2551]||(i[2551]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2553]||(i[2553]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uplift_rgb_unbounded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Convert Hikari RGBSpectrum to spectral radiance for emission/illumination. Uses sigmoid polynomial method with scaling for unbounded values. Uses global table - not GPU-compatible. Use the version with explicit table for GPU kernels.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2552]||(i[2552]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L352-L358",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",$d,[s("summary",null,[i[2554]||(i[2554]=s("a",{id:"Hikari.uplift_rgb_unbounded-Tuple{Hikari.RGBToSpectrumTable, Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}",href:"#Hikari.uplift_rgb_unbounded-Tuple{Hikari.RGBToSpectrumTable, Hikari.RGBSpectrum, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.uplift_rgb_unbounded")],-1)),i[2555]||(i[2555]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2557]||(i[2557]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uplift_rgb_unbounded</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rgb</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBSpectrum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>GPU-compatible version that takes an explicit table parameter.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2556]||(i[2556]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L363-L367",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ik,[s("summary",null,[i[2558]||(i[2558]=s("a",{id:"Hikari.uplift_scalar-Tuple{Float32, Hikari.SampledWavelengths{4}}",href:"#Hikari.uplift_scalar-Tuple{Float32, Hikari.SampledWavelengths{4}}"},[s("span",{class:"jlbinding"},"Hikari.uplift_scalar")],-1)),i[2559]||(i[2559]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2561]||(i[2561]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uplift_scalar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Wavelengths</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpectralRadiance</span></span></code></pre></div><p>Convert a scalar value to uniform spectral radiance.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2560]||(i[2560]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/uplift.jl#L372-L376",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",sk,[s("summary",null,[i[2562]||(i[2562]=s("a",{id:"Hikari.uv_to_direction_equal_area-Tuple{GeometryBasics.Point{2, Float32}, StaticArraysCore.SMatrix{3, 3, Float32, 9}}",href:"#Hikari.uv_to_direction_equal_area-Tuple{GeometryBasics.Point{2, Float32}, StaticArraysCore.SMatrix{3, 3, Float32, 9}}"},[s("span",{class:"jlbinding"},"Hikari.uv_to_direction_equal_area")],-1)),i[2563]||(i[2563]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2565]||(i[2565]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uv_to_direction_equal_area</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rotation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Mat3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Convert UV to direction using equal-area (octahedral) mapping. Inverse of direction_to_uv_equal_area.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2564]||(i[2564]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L208-L213",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ek,[s("summary",null,[i[2566]||(i[2566]=s("a",{id:"Hikari.uv_to_direction_equirect-Tuple{GeometryBasics.Point{2, Float32}, StaticArraysCore.SMatrix{3, 3, Float32, 9}}",href:"#Hikari.uv_to_direction_equirect-Tuple{GeometryBasics.Point{2, Float32}, StaticArraysCore.SMatrix{3, 3, Float32, 9}}"},[s("span",{class:"jlbinding"},"Hikari.uv_to_direction_equirect")],-1)),i[2567]||(i[2567]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2569]||(i[2569]=s("p",null,"Convert equirectangular UV coordinates to a direction vector. Inverse of direction_to_uv_equirect.",-1)),i[2570]||(i[2570]=s("p",null,"The rotation matrix transforms from render space to light/map space. We apply the rotation (not inverse) to transform from light space back to render space.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2568]||(i[2568]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L264-L270",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",tk,[s("summary",null,[i[2571]||(i[2571]=s("a",{id:"Hikari.visible_wavelengths_pdf-Tuple{Float32}",href:"#Hikari.visible_wavelengths_pdf-Tuple{Float32}"},[s("span",{class:"jlbinding"},"Hikari.visible_wavelengths_pdf")],-1)),i[2572]||(i[2572]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2574]||(i[2574]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">visible_wavelengths_pdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lambda</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Float32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>PDF for importance-sampled visible wavelengths, centered at 538nm. This distribution reduces variance by sampling more where human vision is sensitive.</p><p>From pbrt-v4: PDF = 0.0039398042 / cosh²(0.0072 * (lambda - 538))</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2573]||(i[2573]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/spectral.jl#L184-L191",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ak,[s("summary",null,[i[2575]||(i[2575]=s("a",{id:"Hikari.vp_accumulate_to_rgb_kernel!-Tuple{Any}",href:"#Hikari.vp_accumulate_to_rgb_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.vp_accumulate_to_rgb_kernel!")],-1)),i[2576]||(i[2576]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2578]||(i[2578]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_accumulate_to_rgb_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Accumulate spectral radiance to RGB with filter weight support. Following pbrt-v4&#39;s film accumulation pattern:</p><ul><li><p>Convert spectral L to XYZ using CIE matching functions</p></li><li><p>Convert XYZ to linear sRGB</p></li><li><p>Apply maxComponentValue clamping for firefly suppression</p></li><li><p>Accumulate weighted RGB: rgbSum += weight * rgb</p></li><li><p>Accumulate weight: weightSum += weight</p></li></ul><p>Note: Sensor simulation (imaging_ratio, white balance) is applied in postprocessing, not here. This matches pbrt-v4&#39;s architecture where the film stores raw linear HDR values and the sensor conversion happens at output time.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2577]||(i[2577]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath.jl#L320-L334",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",lk,[s("summary",null,[i[2579]||(i[2579]=s("a",{id:"Hikari.vp_compute_geometric_normal-Tuple{Any}",href:"#Hikari.vp_compute_geometric_normal-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.vp_compute_geometric_normal")],-1)),i[2580]||(i[2580]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2582]||(i[2582]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">compute_geometric_normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Compute geometric normal from a triangle primitive.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2581]||(i[2581]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L8-L12",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",nk,[s("summary",null,[i[2583]||(i[2583]=s("a",{id:"Hikari.vp_compute_partial_derivatives-Tuple{Any}",href:"#Hikari.vp_compute_partial_derivatives-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.vp_compute_partial_derivatives")],-1)),i[2584]||(i[2584]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2586]||(i[2586]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_compute_partial_derivatives</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (dpdu, dpdv)</span></span></code></pre></div><p>Compute position partial derivatives (∂p/∂u, ∂p/∂v) from triangle vertices and UVs. These are used for texture filtering and tangent space construction. Following pbrt-v4&#39;s Triangle::InteractionFromIntersection.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2585]||(i[2585]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L39-L45",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",rk,[s("summary",null,[i[2587]||(i[2587]=s("a",{id:"Hikari.vp_compute_shading_normal-Tuple{Any, Any, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.vp_compute_shading_normal-Tuple{Any, Any, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.vp_compute_shading_normal")],-1)),i[2588]||(i[2588]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2590]||(i[2590]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_compute_shading_normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive, barycentric, geometric_normal) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Compute interpolated shading normal from vertex normals.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2589]||(i[2589]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L124-L128",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",pk,[s("summary",null,[i[2591]||(i[2591]=s("a",{id:"Hikari.vp_compute_shading_tangents-Tuple{Any, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.vp_compute_shading_tangents-Tuple{Any, Any, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.vp_compute_shading_tangents")],-1)),i[2592]||(i[2592]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2594]||(i[2594]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_compute_shading_tangents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive, barycentric, ns, dpdu, dpdv) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (dpdus, dpdvs)</span></span></code></pre></div><p>Compute shading tangent vectors from vertex tangents or geometric derivatives. Following pbrt-v4&#39;s approach: use vertex tangents if available, otherwise orthonormalize geometric dpdu/dpdv to the shading normal.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2593]||(i[2593]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L77-L83",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ok,[s("summary",null,[i[2595]||(i[2595]=s("a",{id:"Hikari.vp_compute_surface_geometry-NTuple{5, Any}",href:"#Hikari.vp_compute_surface_geometry-NTuple{5, Any}"},[s("span",{class:"jlbinding"},"Hikari.vp_compute_surface_geometry")],-1)),i[2596]||(i[2596]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2598]||(i[2598]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_compute_surface_geometry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive, barycentric, ray) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NamedTuple</span></span></code></pre></div><p>Compute all surface geometry needed for material evaluation. Returns (pi, n, dpdu, dpdv, ns, dpdus, dpdvs, uv).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2597]||(i[2597]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L152-L157",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",dk,[s("summary",null,[i[2599]||(i[2599]=s("a",{id:"Hikari.vp_compute_uv_barycentric-Tuple{Any, Any}",href:"#Hikari.vp_compute_uv_barycentric-Tuple{Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.vp_compute_uv_barycentric")],-1)),i[2600]||(i[2600]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2602]||(i[2602]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_compute_uv_barycentric</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(primitive, barycentric) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Point2f</span></span></code></pre></div><p>Compute UV coordinates using barycentric coordinates from ray intersection.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2601]||(i[2601]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L23-L27",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",kk,[s("summary",null,[i[2603]||(i[2603]=s("a",{id:"Hikari.vp_finalize_film_kernel!-Tuple{Any}",href:"#Hikari.vp_finalize_film_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.vp_finalize_film_kernel!")],-1)),i[2604]||(i[2604]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2606]||(i[2606]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_finalize_film_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Finalize film by dividing weighted RGB sum by weight sum. Following pbrt-v4&#39;s RGBFilm::GetPixelRGB:</p><ul><li>rgb = rgbSum / weightSum (if weightSum != 0)</li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2605]||(i[2605]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath.jl#L386-L392",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",hk,[s("summary",null,[i[2607]||(i[2607]=s("a",{id:"Hikari.vp_generate_camera_rays_kernel!-Tuple{Any}",href:"#Hikari.vp_generate_camera_rays_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.vp_generate_camera_rays_kernel!")],-1)),i[2608]||(i[2608]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2610]||(i[2610]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_generate_camera_rays_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate camera rays with per-pixel wavelength sampling and filter weight computation. Following pbrt-v4&#39;s GetCameraSample: samples the filter, computes offset and weight.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2609]||(i[2609]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath.jl#L119-L124",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",uk,[s("summary",null,[i[2611]||(i[2611]=s("a",{id:"Hikari.vp_generate_ray_samples!-Tuple{Any, Hikari.VolPathState, Int32, Int32, Hikari.SobolRNG}",href:"#Hikari.vp_generate_ray_samples!-Tuple{Any, Hikari.VolPathState, Int32, Int32, Hikari.SobolRNG}"},[s("span",{class:"jlbinding"},"Hikari.vp_generate_ray_samples!")],-1)),i[2612]||(i[2612]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2614]||(i[2614]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_generate_ray_samples!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, state, sample_idx, depth, sobol_rng)</span></span></code></pre></div><p>Generate pre-computed Sobol samples for all active rays at the current depth.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2613]||(i[2613]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath.jl#L281-L285",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",gk,[s("summary",null,[i[2615]||(i[2615]=s("a",{id:"Hikari.vp_generate_ray_samples_kernel!-Tuple{Any}",href:"#Hikari.vp_generate_ray_samples_kernel!-Tuple{Any}"},[s("span",{class:"jlbinding"},"Hikari.vp_generate_ray_samples_kernel!")],-1)),i[2616]||(i[2616]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2618]||(i[2618]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_generate_ray_samples_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate pre-computed Sobol samples for the current bounce. Following pbrt-v4&#39;s WavefrontPathIntegrator::GenerateRaySamples:</p><ul><li><p>For each active ray in the queue, generate 7 samples for this bounce</p></li><li><p>Samples are stored in pixel_samples indexed by pixel_index</p></li><li><p>Dimension allocation: 6 (camera) + 7 * depth</p></li></ul><p>This replaces rand() calls with correlated low-discrepancy samples.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2617]||(i[2617]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/volpath.jl#L211-L221",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",ck,[s("summary",null,[i[2619]||(i[2619]=s("a",{id:"Hikari.vp_trace_shadow_rays_kernel!-NTuple{7, Any}",href:"#Hikari.vp_trace_shadow_rays_kernel!-NTuple{7, Any}"},[s("span",{class:"jlbinding"},"Hikari.vp_trace_shadow_rays_kernel!")],-1)),i[2620]||(i[2620]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2622]||(i[2622]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">vp_trace_shadow_rays_kernel!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Trace shadow rays and accumulate unoccluded contributions. For rays through media, computes transmittance along the ray. Handles transmissive boundaries (MediumInterface) by tracing through them.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2621]||(i[2621]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/intersection.jl#L558-L564",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",bk,[s("summary",null,[i[2623]||(i[2623]=s("a",{id:"Hikari.weight_color-NTuple{4, Float32}",href:"#Hikari.weight_color-NTuple{4, Float32}"},[s("span",{class:"jlbinding"},"Hikari.weight_color")],-1)),i[2624]||(i[2624]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2626]||(i[2626]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">weight_color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lum_p, lum_q, sigma, variance) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Color/luminance edge-stopping weight. If variance &gt; 0, scales by sqrt(variance) for variance-guided filtering.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2625]||(i[2625]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/denoise.jl#L70-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",yk,[s("summary",null,[i[2627]||(i[2627]=s("a",{id:"Hikari.weight_depth-NTuple{4, Float32}",href:"#Hikari.weight_depth-NTuple{4, Float32}"},[s("span",{class:"jlbinding"},"Hikari.weight_depth")],-1)),i[2628]||(i[2628]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2630]||(i[2630]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">weight_depth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d_p, d_q, sigma, step_size) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Depth edge-stopping weight. Uses step size to adapt to increasing filter radius.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2629]||(i[2629]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/denoise.jl#L105-L110",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",mk,[s("summary",null,[i[2631]||(i[2631]=s("a",{id:"Hikari.weight_normal-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32}",href:"#Hikari.weight_normal-Tuple{GeometryBasics.Vec{3, Float32}, GeometryBasics.Vec{3, Float32}, Float32}"},[s("span",{class:"jlbinding"},"Hikari.weight_normal")],-1)),i[2632]||(i[2632]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2634]||(i[2634]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">weight_normal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n_p, n_q, sigma) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Normal edge-stopping weight using dot product. High sigma means more tolerance for normal differences.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2633]||(i[2633]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/denoise.jl#L90-L95",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",fk,[s("summary",null,[i[2635]||(i[2635]=s("a",{id:"Hikari.world_to_index_f-Tuple{Hikari.NanoVDBMedium, GeometryBasics.Point{3, Float32}}",href:"#Hikari.world_to_index_f-Tuple{Hikari.NanoVDBMedium, GeometryBasics.Point{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.world_to_index_f")],-1)),i[2636]||(i[2636]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2638]||(i[2638]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">world_to_index_f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(medium</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NanoVDBMedium</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Point3f</span></span></code></pre></div><p>Transform a point from world space to index space (floating point). Matches pbrt-v4&#39;s Grid::worldToIndexF exactly.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2637]||(i[2637]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/integrators/volpath/nanovdb.jl#L394-L399",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ek,[s("summary",null,[i[2639]||(i[2639]=s("a",{id:"Hikari.world_to_local-NTuple{4, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.world_to_local-NTuple{4, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.world_to_local")],-1)),i[2640]||(i[2640]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2642]||(i[2642]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">world_to_local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v, n, tangent, bitangent) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Transform direction from world space to local (shading) space. In local space, the normal is (0, 0, 1).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2641]||(i[2641]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/spectral-eval.jl#L3573-L3578",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",_k,[s("summary",null,[i[2643]||(i[2643]=s("a",{id:"Hikari.world_to_local-Tuple{Hikari.BSDF, GeometryBasics.Vec{3, Float32}}",href:"#Hikari.world_to_local-Tuple{Hikari.BSDF, GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.world_to_local")],-1)),i[2644]||(i[2644]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2646]||(i[2646]=s("p",null,[a("Given the orthonormal vectors s, t, n in world space, the matrix "),s("code",null,"M"),a(" that transforms vectors in world space to local reflection space is: sx, sy, sz tx, ty, tz nx, ny, nz")],-1)),i[2647]||(i[2647]=s("p",null,"Since it is an orthonormal matrix, its inverse is its transpose.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2645]||(i[2645]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/bsdf.jl#L76-L84",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Tk,[s("summary",null,[i[2648]||(i[2648]=s("a",{id:"Hikari.worley3d-Tuple{Any, Any, Any}",href:"#Hikari.worley3d-Tuple{Any, Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.worley3d")],-1)),i[2649]||(i[2649]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2651]||(i[2651]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">worley3d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y, z; seed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float64</span></span></code></pre></div><p>3D Worley (cellular) noise. Returns distance to nearest feature point in [0, ~1.5]. The characteristic &quot;cell&quot; structure creates puffy, billowy patterns ideal for clouds.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2650]||(i[2650]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/random.jl#L78-L83",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",jk,[s("summary",null,[i[2652]||(i[2652]=s("a",{id:"Hikari.worley_fbm3d-Tuple{Any, Any, Any}",href:"#Hikari.worley_fbm3d-Tuple{Any, Any, Any}"},[s("span",{class:"jlbinding"},"Hikari.worley_fbm3d")],-1)),i[2653]||(i[2653]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2655]||(i[2655]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">worley_fbm3d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y, z; octaves</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, persistence</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lacunarity</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float64</span></span></code></pre></div><p>Multi-octave Worley noise for more detailed cellular patterns.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2654]||(i[2654]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/random.jl#L111-L115",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Fk,[s("summary",null,[i[2656]||(i[2656]=s("a",{id:"Hikari.wrap_equal_area_square-Tuple{GeometryBasics.Point{2, Float32}}",href:"#Hikari.wrap_equal_area_square-Tuple{GeometryBasics.Point{2, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.wrap_equal_area_square")],-1)),i[2657]||(i[2657]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2659]||(i[2659]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">wrap_equal_area_square</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Point2f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Point2f</span></span></code></pre></div><p>Wrap UV coordinates for equal-area sphere mapping (octahedral wrapping). Handles coordinates outside [0,1]² by mirroring appropriately.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2658]||(i[2658]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/environment_map.jl#L162-L167",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ck,[s("summary",null,[i[2660]||(i[2660]=s("a",{id:"Hikari.xy_to_XYZ-Tuple{Float32, Float32}",href:"#Hikari.xy_to_XYZ-Tuple{Float32, Float32}"},[s("span",{class:"jlbinding"},"Hikari.xy_to_XYZ")],-1)),i[2661]||(i[2661]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2663]||(i[2663]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">xy_to_XYZ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x, y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (X, Y, Z)</span></span></code></pre></div><p>Convert CIE xy chromaticity to XYZ with Y=1.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2662]||(i[2662]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L495-L499",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",vk,[s("summary",null,[i[2664]||(i[2664]=s("a",{id:"Hikari.xyz_e_to_linear_srgb-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.xyz_e_to_linear_srgb-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.xyz_e_to_linear_srgb")],-1)),i[2665]||(i[2665]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2667]||(i[2667]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">xyz_e_to_linear_srgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xyz</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Convert CIE XYZ (in Equal-Energy illuminant space) to linear sRGB (D65). This applies Bradford chromatic adaptation from E to D65 before the XYZ-to-sRGB transformation. Use this for spectral rendering where wavelength sampling assumes an equal-energy white spectrum.</p><p>Matrix values are inlined for performance and to avoid const reload issues.</p>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2666]||(i[2666]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L581-L590",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Hk,[s("summary",null,[i[2668]||(i[2668]=s("a",{id:"Hikari.xyz_to_linear_srgb-Tuple{GeometryBasics.Vec{3, Float32}}",href:"#Hikari.xyz_to_linear_srgb-Tuple{GeometryBasics.Vec{3, Float32}}"},[s("span",{class:"jlbinding"},"Hikari.xyz_to_linear_srgb")],-1)),i[2669]||(i[2669]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2671]||(i[2671]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">xyz_to_linear_srgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(xyz</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vec3f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vec3f</span></span></code></pre></div><p>Convert CIE XYZ to linear sRGB color space. Uses the standard XYZ to sRGB matrix (D65 white point). Note: This assumes XYZ is already in D65 illuminant space.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2670]||(i[2670]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L565-L571",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ak,[s("summary",null,[i[2672]||(i[2672]=s("a",{id:"Hikari.zsobol_get_sample_index-Tuple{UInt64, Int32, Int32, Int32}",href:"#Hikari.zsobol_get_sample_index-Tuple{UInt64, Int32, Int32, Int32}"},[s("span",{class:"jlbinding"},"Hikari.zsobol_get_sample_index")],-1)),i[2673]||(i[2673]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2675]||(i[2675]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">zsobol_get_sample_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(morton_index, dimension, log2_spp, n_base4_digits) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt64</span></span></code></pre></div><p>Compute the permuted sample index for ZSobol sampling. Reference: pbrt-v4/src/pbrt/samplers.h ZSobolSampler::GetSampleIndex (lines 301-356)</p><p>This applies random base-4 digit permutations to the Morton-encoded index, ensuring good sample distribution across pixels while maintaining low-discrepancy.</p><p>Uses compile-time unrolled loop with branchless operations for SPIR-V compatibility.</p>',4)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2674]||(i[2674]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L203-L213",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Sk,[s("summary",null,[i[2676]||(i[2676]=s("a",{id:"Hikari.zsobol_hash-Tuple{Int32, UInt32}",href:"#Hikari.zsobol_hash-Tuple{Int32, UInt32}"},[s("span",{class:"jlbinding"},"Hikari.zsobol_hash")],-1)),i[2677]||(i[2677]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2679]||(i[2679]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">zsobol_hash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dimension</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, seed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UInt32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UInt64</span></span></code></pre></div><p>Hash function for ZSobol scrambling, matching pbrt-v4&#39;s Hash(dimension, seed). Uses MurmurHash64A on the byte representation of (dimension, seed).</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2678]||(i[2678]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L11-L16",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",xk,[s("summary",null,[i[2680]||(i[2680]=s("a",{id:"Hikari.zsobol_sample_1d-Tuple{Int32, Int32, Int32, Int32, Int32, Int32, UInt32, Any}",href:"#Hikari.zsobol_sample_1d-Tuple{Int32, Int32, Int32, Int32, Int32, Int32, UInt32, Any}"},[s("span",{class:"jlbinding"},"Hikari.zsobol_sample_1d")],-1)),i[2681]||(i[2681]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2683]||(i[2683]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">zsobol_sample_1d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px, py, sample_idx, dim, log2_spp, n_base4_digits, seed, sobol_matrices) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Float32</span></span></code></pre></div><p>Generate a 1D Sobol sample for the given pixel and sample index.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2682]||(i[2682]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L267-L271",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Bk,[s("summary",null,[i[2684]||(i[2684]=s("a",{id:"Hikari.zsobol_sample_2d-Tuple{Int32, Int32, Int32, Int32, Int32, Int32, UInt32, Any}",href:"#Hikari.zsobol_sample_2d-Tuple{Int32, Int32, Int32, Int32, Int32, Int32, UInt32, Any}"},[s("span",{class:"jlbinding"},"Hikari.zsobol_sample_2d")],-1)),i[2685]||(i[2685]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2687]||(i[2687]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">zsobol_sample_2d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(px, py, sample_idx, dim, log2_spp, n_base4_digits, seed, sobol_matrices) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Float32, Float32)</span></span></code></pre></div><p>Generate a 2D Sobol sample for the given pixel and sample index. Uses two consecutive Sobol dimensions with independent scrambling seeds.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2686]||(i[2686]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/sampler/sobol.jl#L287-L292",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Dk,[s("summary",null,[i[2688]||(i[2688]=s("a",{id:"Hikari.ρ_lambertian_reflection-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, Int32, Vector{GeometryBasics.Point{2, Float32}}}} where S<:Hikari.Spectrum",href:"#Hikari.ρ_lambertian_reflection-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, GeometryBasics.Vec{3, Float32}, Int32, Vector{GeometryBasics.Point{2, Float32}}}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.ρ_lambertian_reflection")],-1)),i[2689]||(i[2689]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2691]||(i[2691]=s("p",null,"Directional-hemisphirical reflectance value is constant.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2690]||(i[2690]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/lambertian.jl#L21-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Ik,[s("summary",null,[i[2692]||(i[2692]=s("a",{id:"Hikari.ρ_lambertian_reflection-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, Vector{GeometryBasics.Point{2, Float32}}, Vector{GeometryBasics.Point{2, Float32}}}} where S<:Hikari.Spectrum",href:"#Hikari.ρ_lambertian_reflection-Union{Tuple{S}, Tuple{Hikari.UberBxDF{S}, Vector{GeometryBasics.Point{2, Float32}}, Vector{GeometryBasics.Point{2, Float32}}}} where S<:Hikari.Spectrum"},[s("span",{class:"jlbinding"},"Hikari.ρ_lambertian_reflection")],-1)),i[2693]||(i[2693]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2695]||(i[2695]=s("p",null,"Hemispherical-hemisphirical reflectance value is constant.",-1)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2694]||(i[2694]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/reflection/lambertian.jl#L31-L33",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Mk,[s("summary",null,[i[2696]||(i[2696]=s("a",{id:"Raycore.maybe_convert_field-Tuple{Raycore.MultiTypeSet, Hikari.Texture}",href:"#Raycore.maybe_convert_field-Tuple{Raycore.MultiTypeSet, Hikari.Texture}"},[s("span",{class:"jlbinding"},"Raycore.maybe_convert_field")],-1)),i[2697]||(i[2697]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2699]||(i[2699]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Raycore</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">maybe_convert_field</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dhv</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MultiTypeSet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Texture</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert Hikari Texture to Raycore.TextureRef or raw value for MultiTypeSet storage.</p><ul><li><p>Const textures (scalars): return constval directly (no indirection needed)</p></li><li><p>Non-const textures (arrays): convert to TextureRef</p></li></ul>',3)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2698]||(i[2698]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/textures/texture-ref.jl#L199-L205",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Gk,[s("summary",null,[i[2700]||(i[2700]=s("a",{id:"Raycore.sync!-Tuple{Hikari.Scene{<:Raycore.TLAS}}",href:"#Raycore.sync!-Tuple{Hikari.Scene{<:Raycore.TLAS}}"},[s("span",{class:"jlbinding"},"Raycore.sync!")],-1)),i[2701]||(i[2701]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2703]||(i[2703]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sync!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Scene</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Build/rebuild the acceleration structure and update scene bounds. Call this after adding geometry with <code>push!</code>.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2702]||(i[2702]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/scene.jl#L138-L143",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Pk,[s("summary",null,[i[2704]||(i[2704]=s("a",{id:"Raycore.to_gpu-Tuple{Any, Hikari.CIEXYZTable}",href:"#Raycore.to_gpu-Tuple{Any, Hikari.CIEXYZTable}"},[s("span",{class:"jlbinding"},"Raycore.to_gpu")],-1)),i[2705]||(i[2705]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2707]||(i[2707]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">to_gpu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CIEXYZTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CIEXYZTable</span></span></code></pre></div><p>Convert CIEXYZTable to use GPU-compatible arrays. Uses KernelAbstractions backend for allocation.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2706]||(i[2706]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/color.jl#L34-L39",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Vk,[s("summary",null,[i[2708]||(i[2708]=s("a",{id:"Raycore.to_gpu-Tuple{Any, Hikari.Emissive}",href:"#Raycore.to_gpu-Tuple{Any, Hikari.Emissive}"},[s("span",{class:"jlbinding"},"Raycore.to_gpu")],-1)),i[2709]||(i[2709]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2711]||(i[2711]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">to_gpu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ArrayType, mat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Emissive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Convert Emissive to GPU-compatible form.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2710]||(i[2710]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/materials/emissive.jl#L143-L147",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",Lk,[s("summary",null,[i[2712]||(i[2712]=s("a",{id:"Raycore.to_gpu-Tuple{Any, Hikari.RGBToSpectrumTable}",href:"#Raycore.to_gpu-Tuple{Any, Hikari.RGBToSpectrumTable}"},[s("span",{class:"jlbinding"},"Raycore.to_gpu")],-1)),i[2713]||(i[2713]=a()),t(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[2715]||(i[2715]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">to_gpu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(backend, table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RGBToSpectrumTable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBToSpectrumTable</span></span></code></pre></div><p>Convert RGBToSpectrumTable to use GPU-compatible arrays. Uses KernelAbstractions backend for allocation.</p>',2)),t(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...i[2714]||(i[2714]=[s("a",{href:"https://github.com/JuliaGraphics/Hikari.jl/blob/5b44754d163c421ee6d82728438585ecf67fb1be/src/spectral/rgb2spec.jl#L447-L452",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const zk=r(k,[["render",wk]]);export{qk as __pageData,zk as default};
